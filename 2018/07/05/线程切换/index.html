<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="线程切换"><meta name="keywords" content="线程切换,进程挂靠"><meta name="author" content="yangruiqi,undefined"><meta name="copyright" content="yangruiqi"><title>线程切换 | manyouyou</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.5"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#关键结构体"><span class="toc-number">1.</span> <span class="toc-text">关键结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度链表"><span class="toc-number">2.</span> <span class="toc-text">调度链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化线程堆栈"><span class="toc-number">3.</span> <span class="toc-text">初始化线程堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟线程切换总结"><span class="toc-number">4.</span> <span class="toc-text">模拟线程切换总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows线程切换-主动切换"><span class="toc-number"></span> <span class="toc-text">Windows线程切换_主动切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KiSwapContext函数"><span class="toc-number">1.</span> <span class="toc-text">KiSwapContext函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SwapContext函数"><span class="toc-number">2.</span> <span class="toc-text">SwapContext函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结："><span class="toc-number">3.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows线程切换-时钟中断切换"><span class="toc-number"></span> <span class="toc-text">Windows线程切换_时钟中断切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何中断一个正在执行的程序"><span class="toc-number">1.</span> <span class="toc-text">如何中断一个正在执行的程序?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统时钟"><span class="toc-number">2.</span> <span class="toc-text">系统时钟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时钟中断的执行流程"><span class="toc-number">3.</span> <span class="toc-text">时钟中断的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结：-1"><span class="toc-number">4.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#时间片管理"><span class="toc-number"></span> <span class="toc-text">时间片管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于CPU时间片"><span class="toc-number">1.</span> <span class="toc-text">关于CPU时间片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于CPU时间片-1"><span class="toc-number">2.</span> <span class="toc-text">关于CPU时间片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程切换的三种情况："><span class="toc-number">3.</span> <span class="toc-text">线程切换的三种情况：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows线程切换-TSS"><span class="toc-number"></span> <span class="toc-text">Windows线程切换_TSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内核堆栈"><span class="toc-number">1.</span> <span class="toc-text">内核堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核堆栈的结构"><span class="toc-number">2.</span> <span class="toc-text">内核堆栈的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trap-Frame"><span class="toc-number">3.</span> <span class="toc-text">_Trap_Frame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用API进0环"><span class="toc-number">4.</span> <span class="toc-text">调用API进0环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSS"><span class="toc-number">5.</span> <span class="toc-text">TSS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程切换-FS"><span class="toc-number"></span> <span class="toc-text">线程切换_FS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程切换-线程优先级"><span class="toc-number"></span> <span class="toc-text">线程切换_线程优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#调度链表-32个"><span class="toc-number">1.</span> <span class="toc-text">调度链表(32个)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何高效查找"><span class="toc-number">2.</span> <span class="toc-text">如何高效查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果没有就绪线程怎么办"><span class="toc-number">3.</span> <span class="toc-text">如果没有就绪线程怎么办?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程挂靠"><span class="toc-number"></span> <span class="toc-text">进程挂靠</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程与线程的关系"><span class="toc-number">1.</span> <span class="toc-text">进程与线程的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程与进程如何关联"><span class="toc-number">2.</span> <span class="toc-text">线程与进程如何关联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#养父母负责提供Cr3"><span class="toc-number">3.</span> <span class="toc-text">养父母负责提供Cr3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">3.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cr3的值可以随便改吗"><span class="toc-number">4.</span> <span class="toc-text">Cr3的值可以随便改吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#将当前Cr3的值改为其他进程，称为“进程挂靠”。"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">将当前Cr3的值改为其他进程，称为“进程挂靠”。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分析NtReadVirtualMemory函数"><span class="toc-number">5.</span> <span class="toc-text">分析NtReadVirtualMemory函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结：-2"><span class="toc-number">6.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#跨进程读写内存"><span class="toc-number"></span> <span class="toc-text">跨进程读写内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#跨进程操作"><span class="toc-number">1.</span> <span class="toc-text">跨进程操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NtReadVirtualMemory流程解析："><span class="toc-number">2.</span> <span class="toc-text">NtReadVirtualMemory流程解析：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NtWriteVirtualMemory流程解析："><span class="toc-number">3.</span> <span class="toc-text">NtWriteVirtualMemory流程解析：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/%E5%A4%B4%E5%83%8F/touxiang.jpg"></div><div class="author-info__name text-center">yangruiqi</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/yangruiqiyr" target="_blank">跟随我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">25</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">36</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">12</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">相关网址</div><a class="author-info-links__name text-center" href="http://blog.topsec.com.cn/" target="_blank">天融信阿尔法实验室</a><a class="author-info-links__name text-center" href="https://www.baidu.com/" target="_blank">百度</a><a class="author-info-links__name text-center" href="https://bbs.pediy.com/" target="_blank">看雪</a><a class="author-info-links__name text-center" href="http://www.freebuf.com/" target="_blank">FreeBuf</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/主题/主题1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">manyouyou</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">档案</a><a class="site-page" href="/tags">标题</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">线程切换</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/笔记-进程与线程笔记/">笔记 - 进程与线程笔记</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="关键结构体"><a href="#关键结构体" class="headerlink" title="关键结构体"></a>关键结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程结构体(仿EHREAD)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *name;			<span class="comment">//线程名 相当于线程TID</span></span><br><span class="line">	<span class="keyword">int</span> Flags;			<span class="comment">//线程状态</span></span><br><span class="line">	<span class="keyword">int</span> SleepMillisecondDot;		<span class="comment">//休眠时间</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> *InitialStack;			<span class="comment">//线程堆栈起始位置</span></span><br><span class="line">	<span class="keyword">void</span> *StackLimit;			<span class="comment">//线程堆栈界限</span></span><br><span class="line">	<span class="keyword">void</span> *KernelStack;		<span class="comment">//线程堆栈当前位置,也就是ESP</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> *lpParameter;		<span class="comment">//线程函数的参数</span></span><br><span class="line">	<span class="keyword">void</span> (*func)(<span class="keyword">void</span> *lpParameter);	<span class="comment">//线程函数</span></span><br><span class="line">	</span><br><span class="line">&#125; GMThread_t;</span><br></pre></td></tr></table></figure>
<h2 id="调度链表"><a href="#调度链表" class="headerlink" title="调度链表"></a>调度链表</h2><p>//线程结构体数组<br>extern GMThread_t GMThreadList[MAXGMTHREAD];<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.png" alt="2"></p>
<p>从下标1开始，0是给当前线程用的。  </p>
<h2 id="初始化线程堆栈"><a href="#初始化线程堆栈" class="headerlink" title="初始化线程堆栈"></a>初始化线程堆栈</h2><p>创建完成之后，初始化堆栈<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/3.png" alt="2"></p>
<p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/4.png" alt="4"></p>
<h2 id="模拟线程切换总结"><a href="#模拟线程切换总结" class="headerlink" title="模拟线程切换总结"></a>模拟线程切换总结</h2><p>1)  线程不是被动切换的，而是主动让出CPU.</p>
<p>2)  线程切换并没有使用TSS来保存寄存器，而是使用堆栈.</p>
<p>3)  线程切换的过程就是堆栈切换的过程.</p>
<h1 id="Windows线程切换-主动切换"><a href="#Windows线程切换-主动切换" class="headerlink" title="Windows线程切换_主动切换"></a>Windows线程切换_主动切换</h1><p>在之前课程里面讲到了模拟Windows线程切换(ThreadSwitch)<br>在这个项目里面我们介绍了一个重要的函数：<br>SwitchContext<br>只有调用这个函数，就会导致线程切换<br>Windows也有类似的函数：<br>KiSwapContext</p>
<h2 id="KiSwapContext函数"><a href="#KiSwapContext函数" class="headerlink" title="KiSwapContext函数"></a>KiSwapContext函数</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/6.png" alt="6"></p>
<h2 id="SwapContext函数"><a href="#SwapContext函数" class="headerlink" title="SwapContext函数"></a>SwapContext函数</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/7.png" alt="7"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><pre><code>1) Windows中绝大部分API都调用了SwapContext函数
</code></pre><p>也就是说，当线程只要调用了API，就是导致线程切换。</p>
<pre><code>2) 线程切换时会比较是否属于同一个进程，如果不是，切换Cr3
</code></pre><p>Cr3换了，进程也就切换了。</p>
<h1 id="Windows线程切换-时钟中断切换"><a href="#Windows线程切换-时钟中断切换" class="headerlink" title="Windows线程切换_时钟中断切换"></a>Windows线程切换_时钟中断切换</h1><p>在上一节中我们讲过了，绝大部分系统内核函数都会调用SwapContext函数，来实现线程的切换，那么这种切换是线程主动调用的。<br>那如果当前的线程不去调用系统API，操作系统如何实现线程切换呢?</p>
<h2 id="如何中断一个正在执行的程序"><a href="#如何中断一个正在执行的程序" class="headerlink" title="如何中断一个正在执行的程序?"></a>如何中断一个正在执行的程序?</h2><p>1) 异常  比如缺页，或者INT N指令<br>2) 中断  比如时钟中断</p>
<h2 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h2><table>
<thead>
<tr>
<th>（IDT表）中断号</th>
<th>IRQ</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x30</td>
<td>IRQ0</td>
<td>时钟中断</td>
</tr>
</tbody>
</table>
<p>Windows系列操作系统：10 - 20 毫秒<br>如要获取当前的时钟间隔值，可使用Win32 API：<br>GetSystemTimeAdjustment</p>
<h2 id="时钟中断的执行流程"><a href="#时钟中断的执行流程" class="headerlink" title="时钟中断的执行流程"></a>时钟中断的执行流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">时钟中断执行流程：</span><br><span class="line"></span><br><span class="line">KiStartUnexpectedRange            	HalEndSystemInterrupt</span><br><span class="line"></span><br><span class="line">KiEndUnexpectedRange		KiDispatchInterrupt</span><br><span class="line"></span><br><span class="line">KiUnexpectedInterruptTail		SwapContext</span><br><span class="line"></span><br><span class="line">HalBeginSystemInterrupt</span><br></pre></td></tr></table></figure>
<h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><p>线程切换的几种情况：</p>
<p>1)  主动调用API函数</p>
<p>2)  时钟中断</p>
<p>3)  异常处理</p>
<p>如果一个线程不调用API，在代码中屏蔽中断(CLI指令),并且<br>不会出现异常，那么当前线程将永久占有CPU,单核占有率<br>100%  2核就是50%</p>
<h1 id="时间片管理"><a href="#时间片管理" class="headerlink" title="时间片管理"></a>时间片管理</h1><p>在上面我们讲过了，时钟中断会导致线程进行切换，但并不是说只要有时钟中断就一定会切换线程，时钟中断时，两种情况会导致线程切换：</p>
<pre><code>1、当前的线程CPU时间片到期

2、有备用线程(KPCR.PrcbData.NextThread)
</code></pre><h2 id="关于CPU时间片"><a href="#关于CPU时间片" class="headerlink" title="关于CPU时间片"></a>关于CPU时间片</h2><p>1) 当一个新的线程开始执行时，初始化程序会在_KTHREAD.Quantum<br>赋初始值，该值的大小由_KPROCESS.ThreadQuantum决定<br>(观察ThreadQuantum大小)</p>
<p>2) 每次时钟中断会调用KeUpdateRunTime函数，该函数每次将当前线程<br>Quantum减少3个单位，如果减到0，则将KPCR.PrcbData.QuantumEnd的值<br>设置为非0。</p>
<p>3) KiDispatchInterrupt判断时间片到期：</p>
<p>调用KiQuantumEnd(重新设置时间片、找到要运行的线程) </p>
<h2 id="关于CPU时间片-1"><a href="#关于CPU时间片-1" class="headerlink" title="关于CPU时间片"></a>关于CPU时间片</h2><p>这个值被设置时，即使当前线程的CPU时间片没有到期，仍然会被切换.</p>
<p>参见KiDispatchInterrupt代码</p>
<h2 id="线程切换的三种情况："><a href="#线程切换的三种情况：" class="headerlink" title="线程切换的三种情况："></a>线程切换的三种情况：</h2><p>(1)、当前线程主动调用API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">API函数--&gt;KiSwapThread</span><br><span class="line">KiSwapThread--&gt;KiSwapContext</span><br><span class="line">KiSwapContext--&gt;SwapContext</span><br></pre></td></tr></table></figure>
<p>(2)、当前线程时间片到期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">KiDispatchInterrupt--&gt;KiQuantumEnd</span><br><span class="line">KiQuantumEnd--&gt;SwapContext</span><br></pre></td></tr></table></figure>
<p>(3)、有备用线程(KPCR.PrcbData.NextThread)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">KiDispatchInterrupt--&gt;SwapContext</span><br></pre></td></tr></table></figure>
<h1 id="Windows线程切换-TSS"><a href="#Windows线程切换-TSS" class="headerlink" title="Windows线程切换_TSS"></a>Windows线程切换_TSS</h1><p>SwapContext这个函数是Windows线程切换的核心，无论是主动切换还是系统时钟导致的线程切换，最终都会调用这个函数。<br>在这个函数中除了切换堆栈意外，还做了很多其他的事情，了解这些细节对我们学习操作系统至关重要。</p>
<h2 id="内核堆栈"><a href="#内核堆栈" class="headerlink" title="内核堆栈"></a>内核堆栈</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/8.png" alt="8"></p>
<h2 id="内核堆栈的结构"><a href="#内核堆栈的结构" class="headerlink" title="内核堆栈的结构"></a>内核堆栈的结构</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/9.png" alt="9"></p>
<h2 id="Trap-Frame"><a href="#Trap-Frame" class="headerlink" title="_Trap_Frame"></a>_Trap_Frame</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/10.png" alt="10"></p>
<h2 id="调用API进0环"><a href="#调用API进0环" class="headerlink" title="调用API进0环"></a>调用API进0环</h2><p>普通调用：通过TSS.ESP0得到0环堆栈<br>快速调用：从MSR得到一个临时0环栈，代码执行后仍然<br>通过TSS.ESP0得到当前线程0环堆栈。  </p>
<h2 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h2><p>Intel设计TSS的目的是为了任务切换(线程切换),但Windows与Linux<br>并没有使用。而是采用堆栈来保存线程的各种寄存器。<br> 一个CPU只有一个TSS,但是线程很多，如何用一个TSS来保存所有线程的ESP0呢?<br> Tss保存的是当前线程的0环的堆栈，在线程切换时候就变了，Tss本身不切换，只是换了里面的值，找到要切换线程的栈底，放到eax，减210h是浮点寄存器，此时已经指向Trap_Frame了，又减4个单元，是为了再去除给8060的4个寄存器   </p>
<p> 所以Tss改了ESP0和CR3，IO权限位图（Win2000后不再使用）</p>
<h1 id="线程切换-FS"><a href="#线程切换-FS" class="headerlink" title="线程切换_FS"></a>线程切换_FS</h1><p>FS:[0]寄存器在3环时指向TEB,进入0环后FS:[0]指向KPCR<br>系统中同时存在很多个线程，这就意味着FS:[0]在3环时指向的TEB要有多个(每个线程一份)。<br>但在实际的使用中我们发现，当我们在3环查看不同线程的FS寄存器时，FS的段选择子都是相同的,那是如何实现通过一个FS寄存器指向多个TEB呢?<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/11.png" alt="11"></p>
<p>其实就是线程切换时候把基址改了。  </p>
<h1 id="线程切换-线程优先级"><a href="#线程切换-线程优先级" class="headerlink" title="线程切换_线程优先级"></a>线程切换_线程优先级</h1><p>(1)、当前线程主动调用API：<br>    API函数     KiSwapThread    KiSwapContext     SwapContext<br>(2)、当前线程时间片到期：<br>    KiDispatchInterrupt     KiQuantumEnd     SwapContext<br>(3)、有备用线程(KPCR.PrcbData.NextThread)<br>    KiDispatchInterrupt     SwapContext<br>    在KiSwapThread与KiQuantumEnd函数中都是通过KiFindReadyThread来找下一个要切换的线程，KiFindReadyThread是根据什么条件来选择下一个要<br>执行的线程呢?</p>
<h2 id="调度链表-32个"><a href="#调度链表-32个" class="headerlink" title="调度链表(32个)"></a>调度链表(32个)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiDispatcherReadyListHead</span><br><span class="line">8055bc20  8055bc20 8055bc20 8055bc28 8055bc28</span><br><span class="line">8055bc30  8055bc30 8055bc30 8055bc38 8055bc38</span><br><span class="line">8055bc40  8055bc40 8055bc40 8055bc48 8055bc48</span><br><span class="line">8055bc50  8055bc50 8055bc50 8055bc58 8055bc58</span><br><span class="line">8055bc60  8055bc60 8055bc60 8055bc68 8055bc68</span><br><span class="line">8055bc70  8055bc70 8055bc70 8055bc78 8055bc78</span><br><span class="line">8055bc80  8055bc80 8055bc80 8055bc88 8055bc88</span><br><span class="line">8055bc90  8055bc90 8055bc90 8055bc98 8055bc98</span><br><span class="line"></span><br><span class="line">KiFindReadyThread查找方式：</span><br><span class="line">按照优先级别进行查找：31..30..29..28.....</span><br><span class="line"></span><br><span class="line">也就是说，在本次查找中，如果级别31的链表里面有线程，那么就不会</span><br><span class="line">查找级别为30的链表！</span><br></pre></td></tr></table></figure>
<h2 id="如何高效查找"><a href="#如何高效查找" class="headerlink" title="如何高效查找"></a>如何高效查找</h2><p>调度链表有32个，每次都从头开始查找效率太低，所以Windows都过一个DWORD类型变量的变量来记录：<br>当向调度链表(32个)中挂入或者摘除某个线程时，会判断当前级别的链表是否为空，为空将DWORD变量对应位置0，否则置1。<br>如下图</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>后面全是0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这个图意思是30和28链表有值<br>这个变量：_kiReadySummary<br> 多cpu会随机寻找KiDispatcherReadyListHead指向的数组中的线程。线程可以绑定某个cpu（使用api：setThreadAffinityMask</p>
<p> 判断等待链表是否为空就是，前后值等于当前地址，就是空   </p>
<h2 id="如果没有就绪线程怎么办"><a href="#如果没有就绪线程怎么办" class="headerlink" title="如果没有就绪线程怎么办?"></a>如果没有就绪线程怎么办?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PrcbData：</span><br><span class="line"></span><br><span class="line">+0x004 CurrentThread    : Ptr32 _KTHREAD</span><br><span class="line">+0x008 NextThread       : Ptr32 _KTHREAD</span><br><span class="line">+0x00c IdleThread       : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure>
<p>当发现没有要跑的线程，就执行空闲线程，每个KPCR里都会指定一个IdleThread  </p>
<h1 id="进程挂靠"><a href="#进程挂靠" class="headerlink" title="进程挂靠"></a>进程挂靠</h1><h2 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h2><p>一个进程可以包含多个线程<br>一个进程至少要有一个线程<br>进程为线程提供资源，也就是提供Cr3的值，Cr3中存储的是页目录表基址，Cr3确定了，线程能访问的内存也就确定了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程代码：</span><br><span class="line"></span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		</span><br><span class="line"></span><br><span class="line">CPU如何解析0x12345678这个地址呢？</span><br><span class="line"></span><br><span class="line">1) CPU解析线性地址时要通过页目录表来找对应的物理页，页目录表基址存在</span><br><span class="line">Cr3寄存器中。</span><br><span class="line"></span><br><span class="line">2) 当前的Cr3的值来源于当前的进程(_KPROCESS.DirectoryTableBase(+0x018))。</span><br></pre></td></tr></table></figure>
<h2 id="线程与进程如何关联"><a href="#线程与进程如何关联" class="headerlink" title="线程与进程如何关联"></a>线程与进程如何关联</h2><p>线程怎么找到所属进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ETHREAD结构体：</span><br><span class="line"></span><br><span class="line">	+0x034 ApcState</span><br><span class="line">		+0x000 ApcListHead </span><br><span class="line">   		+0x010 Process </span><br><span class="line">   		+0x014 KernelApcInProgress</span><br><span class="line">   		+0x015 KernelApcPending</span><br><span class="line">   		+0x016 UserApcPending</span><br><span class="line"></span><br><span class="line">	+0x220 ThreadsProcess</span><br></pre></td></tr></table></figure></p>
<h2 id="养父母负责提供Cr3"><a href="#养父母负责提供Cr3" class="headerlink" title="养父母负责提供Cr3"></a>养父母负责提供Cr3</h2><p>线程切换的时候，会比较_KTHREAD结构体0x044处指定的EPROCESS是否为同一个,如果不是同一个，会将0x044处指定的EPROCESS的DirectoryTableBase的值取出，赋值给Cr3。<br>所以，线程需要的Cr3的值来源于0x044处偏移指定的EPROCESS.   </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>0x220 亲生父母：这个线程谁创建的<br>0x044 养父母：谁在为这个线程提供资源(也就是提供Cr3)<br>一般情况下，0x220与0x44指向的是同一个进程   </p>
<p>(参考SwapContext函数) </p>
<h2 id="Cr3的值可以随便改吗"><a href="#Cr3的值可以随便改吗" class="headerlink" title="Cr3的值可以随便改吗?"></a>Cr3的值可以随便改吗?</h2><p>正常情况下，Cr3的值是由养父母提供的，但Cr3的值也可以改成和当前线程毫不相干的其他进程的DirectoryTableBase。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程代码：</span><br><span class="line"></span><br><span class="line">mov cr3,A.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//A进程的0x12345678内存</span><br><span class="line">mov cr3,B.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//B进程的0x12345678内存</span><br><span class="line">mov cr3,C.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//C进程的0x12345678内存</span><br></pre></td></tr></table></figure>
<h5 id="将当前Cr3的值改为其他进程，称为“进程挂靠”。"><a href="#将当前Cr3的值改为其他进程，称为“进程挂靠”。" class="headerlink" title="将当前Cr3的值改为其他进程，称为“进程挂靠”。"></a>将当前Cr3的值改为其他进程，称为“进程挂靠”。</h5><p>为了使用别人进程内存的资源。访问其他进程   </p>
<h2 id="分析NtReadVirtualMemory函数"><a href="#分析NtReadVirtualMemory函数" class="headerlink" title="分析NtReadVirtualMemory函数"></a>分析NtReadVirtualMemory函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">NtReadVirtualMemory--&gt;KiAttachProcess</span><br><span class="line">KiAttachProcess--&gt;修改养父母</span><br><span class="line">修改养父母--&gt;修改Cr3</span><br></pre></td></tr></table></figure>
<p>可不可以只修改Cr3而不修改养父母？不可以，如果不修改养父母的值,一旦产生线程切换，就会变成自己读自己！<br>如果我们自己来写这个代码，在切换Cr3后关闭中断，并且不调用会导致线程切换的API,就可以不用修改养父母的值。</p>
<h2 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h2><p>正常情况下，当前线程使用的Cr3是由其所属进程提供的(ETHREAD 0x44偏移处指定的EPROCESS)，正是因为如此，A进程中的线程只能访问A的内存。<br>如果要让A进程中的线程能够访问B进程的内存，就必须要修改Cr3的值为B进程的页目录表基址(B.DirectoryTableBase),这就是所谓的“进程挂靠”。</p>
<h1 id="跨进程读写内存"><a href="#跨进程读写内存" class="headerlink" title="跨进程读写内存"></a>跨进程读写内存</h1><p>跨进程的本质是“进程挂靠”,正常情况下，A进程的线程只能访问A进程的地址空间，如果A进程的线程想访问B进程的地址空间，就要修改当前的Cr3的值为B进程的页目录表基值(KPROCESS.DirectoryTableBase)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即：mov cr3,B.DirectoryTableBase</span><br></pre></td></tr></table></figure></p>
<h2 id="跨进程操作"><a href="#跨进程操作" class="headerlink" title="跨进程操作"></a>跨进程操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A进制中的线程代码：</span><br><span class="line"></span><br><span class="line">mov cr3,B.DirectoryTableBase		//切换Cr3的值为B进程</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//将进程B 0x12345678的值存的eax中</span><br><span class="line">mov dword ptr ds:[0x00401234],eax		//将数据存储到0x00401234中</span><br><span class="line">mov cr3,A.DirectoryTableBase		//切换回Cr3的值	 </span><br><span class="line"></span><br><span class="line">//此时0x00401234中的数据还有吗?</span><br><span class="line"></span><br><span class="line">//如何将数据传递给A进程的变量呢?</span><br><span class="line">写到内核里可以避免切回去值没了</span><br></pre></td></tr></table></figure>
<h2 id="NtReadVirtualMemory流程解析："><a href="#NtReadVirtualMemory流程解析：" class="headerlink" title="NtReadVirtualMemory流程解析："></a>NtReadVirtualMemory流程解析：</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/12.png" alt="12">  </p>
<h2 id="NtWriteVirtualMemory流程解析："><a href="#NtWriteVirtualMemory流程解析：" class="headerlink" title="NtWriteVirtualMemory流程解析："></a>NtWriteVirtualMemory流程解析：</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/13.png" alt="13"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 滴水视频</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yangruiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/07/05/线程切换/">http://yoursite.com/2018/07/05/线程切换/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">manyouyou</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/线程切换/">线程切换</a><a class="post-meta__tags" href="/tags/进程挂靠/">进程挂靠</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/zhifubao.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/weixin.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/06/Windows消息机制/"><i class="fa fa-chevron-left">  </i><span>Windows消息机制</span></a></div><div class="next-post pull-right"><a href="/2018/07/05/等待链表-调度链表/"><span>等待链表_调度链表</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'yangruiqiyr',
  repo: 'BlogGitment',
  oauth: {
    client_id: 'dfbfacd2fb59427cee9e',
    client_secret: 'a39b872c7d6ddf551a16ebf9a3d59ce9b57508bb'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2018 By yangruiqi</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="www.yangruiqiyr.com">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.5"></script><script src="/js/fancybox.js?version=1.5.5"></script><script src="/js/sidebar.js?version=1.5.5"></script><script src="/js/copy.js?version=1.5.5"></script><script src="/js/fireworks.js?version=1.5.5"></script><script src="/js/transition.js?version=1.5.5"></script><script src="/js/scroll.js?version=1.5.5"></script><script src="/js/head.js?version=1.5.5"></script></body></html>