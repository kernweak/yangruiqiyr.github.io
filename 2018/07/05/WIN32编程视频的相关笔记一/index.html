<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="WIN32编程视频的相关笔记一"><meta name="keywords" content="WIN32,WIN32编程"><meta name="author" content="yangruiqi,undefined"><meta name="copyright" content="yangruiqi"><title>WIN32编程视频的相关笔记一 | manyouyou</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.5"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#进程的创建过程"><span class="toc-number">1.</span> <span class="toc-text">进程的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lpApplicationName"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">lpApplicationName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lpProcessAttributes"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">lpProcessAttributes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fInheritHandles"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">fInheritHandles</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DWORD-fdwCreate"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">DWORD fdwCreate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LPVOID-lpEnvironment"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">LPVOID lpEnvironment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LPCWSTR-pszImageName"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">LPCWSTR pszImageName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数-LPSTARTUPINFOW-psiStartInfo"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">参数 LPSTARTUPINFOW psiStartInfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LPPROCESS-INFORMATION-pProcInfo"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">LPPROCESS_INFORMATION pProcInfo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取线程信息"><span class="toc-number">1.1.</span> <span class="toc-text">获取线程信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#互斥体"><span class="toc-number">2.</span> <span class="toc-text">互斥体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事件"><span class="toc-number">3.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#总结："><span class="toc-number">3.1.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#窗口"><span class="toc-number">4.</span> <span class="toc-text">窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#窗口的本质-GUI（User32，画图，windows现成的界面）GDI（gdi32-绘图，自己画的）"><span class="toc-number">4.1.</span> <span class="toc-text">窗口的本质 GUI（User32，画图，windows现成的界面）GDI（gdi32 绘图，自己画的）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDI-图形设备接口（Graphics-Device-Interface）"><span class="toc-number">4.2.</span> <span class="toc-text">GDI 图形设备接口（Graphics Device Interface）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#消息队列"><span class="toc-number">5.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#消息队列：每个线程只有一个消息队列"><span class="toc-number">5.1.</span> <span class="toc-text">消息队列：每个线程只有一个消息队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一个Windows程序"><span class="toc-number">6.</span> <span class="toc-text">第一个Windows程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#消息类型"><span class="toc-number">7.</span> <span class="toc-text">消息类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子窗口"><span class="toc-number">8.</span> <span class="toc-text">子窗口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">9.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/%E5%A4%B4%E5%83%8F/touxiang.jpg"></div><div class="author-info__name text-center">yangruiqi</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/yangruiqiyr" target="_blank">跟随我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">26</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">相关网址</div><a class="author-info-links__name text-center" href="https://www.baidu.com/" target="_blank">百度</a><a class="author-info-links__name text-center" href="https://bbs.pediy.com/" target="_blank">看雪</a><a class="author-info-links__name text-center" href="http://www.freebuf.com/" target="_blank">FreeBuf</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/主题/主题1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">manyouyou</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">档案</a><a class="site-page" href="/tags">标题</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">WIN32编程视频的相关笔记一</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/笔记-WIN32编程笔记/">笔记 - WIN32编程笔记</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>编码中GB2312是利用ASIIC的127到256的两个确定一个汉字，所以不同语言不兼容，unicode只是一种编码，即所有语言符号有唯一值，而他的存储格式被分为unicode-8或者-16，即内核单元用几位，具体符号比如16的开头有个FFFE和FEFF是标志大端还是小段存储，在文本开头显示，具体存储看其的编码比如分3个段加不同的前缀，由于unicode最多四个字节存储，但有些一字节即可，所以浪费空间，网络传输一般以unicode-8传输<br>1、宽字符的使用                            </p>
<p>“中”字的编码：                            </p>
<p>ASCII：d6 d0<br>UNICODE：4e 2d                             </p>
<p>char x = ‘中’;                            </p>
<p>wchar_t x1 = ‘中’;                            </p>
<p>观察内存中的值，为什么会出现这种情况？                            </p>
<p>如何告诉编译器我们要使用的是Unicode的那张表呢？                            </p>
<p>wchar_t x1 = L’中’;                            </p>
<p>2、宽字符串的使用                            </p>
<p>char x[] = “中国”;<br>//d6 d0 b9 fa 00               使用拓展ASCII编码表  以00(\0)结尾                </p>
<p>wchar_t x1[] = L”中国”;<br>//2d 4e fd 56 00 00            使用UNICODE编码表 以00 00(\0\0)结尾                </p>
<p>3、在控制台打印                            </p>
<p>char x[] = “中国”;                            </p>
<p>wchar_t x1[] = L”中国”;                            </p>
<p>printf(“%s\n”,x);            //使用控制台默认的编码                </p>
<p>wprintf(L”%s\n”,x1);            //默认使用英文                </p>
<p>告诉编译器，使用控制台默认的编码格式                            </p>
<p>(1) 包含头文件 #include &lt;locale.h&gt;                            </p>
<p>(2) setlocale(LC_ALL,””); //使用控制台默认的编码                            </p>
<p>4、字符串长度(头文件：#include&lt;string.h&gt;)                            </p>
<p>char x[] = “中国”;                            </p>
<p>wchar_t x1[] = L”中国”;                            </p>
<p>strlen(x);            //取得多字节字符串中字符长度，不包含 00                </p>
<p>wcslen(x1);            //取得多字节字符串中字符长度，不包含 00 00                </p>
<p>5、字符串复制                            </p>
<p>char x[] = “china”;                            </p>
<p>char x1[] = “123”;                            </p>
<p>strcpy(x,x1);                            </p>
<p>wchar_t y[] = L”中国”;                            </p>
<p>wchar_t y1[] = L”好”;                            </p>
<p>wcscpy(y,y1);                            </p>
<p>C语言中的宽字符和多字符                            </p>
<p>char        wchar_t        //多字节字符类型   宽字符类型            </p>
<p>printf        wprintf        //打印到控制台函数            </p>
<p>strlen        wcslen        //获取长度            </p>
<p>strcpy        wcscpy        //字符串复制            </p>
<p>strcat        wcscat        //字符串拼接            </p>
<p>strcmp        wcscmp        //字符串比较            </p>
<p>strstr        wcsstr        //字符串查找            </p>
<p>1、什么是Win32 API？有哪些？在哪里？                </p>
<p>主要是存放在 C:\WINDOWS\system32 下面所有的dll                </p>
<p>2、非常重要的几个DLL                </p>
<p>Kernel32.dll:最核心的功能模块，比如管理内存、进程和线程相关的函数等.                </p>
<p>User32.dll:是Windows用户界面相关应用程序接口,如创建窗口和发送消息等.                </p>
<p>GDI32.dll:全称是Graphical Device Interface(图形设备接口),包含用于画图和显示文本的函数<br>    比如要显示一个程序窗口，就调用了其中的函数来画这个窗口            </p>
<p>3、Win32 API中的宽字符和多字节字符                </p>
<p>Windows是使用C语言开发的，Win32 API同时支持宽字符与多字节字符.                </p>
<p>(1) 字符类型            (2) 字符串指针    </p>
<p>char     CHAR        PSTR(LPSTR) 指向多字节字符串    </p>
<p>wchar_t  WCHAR            PWSTR(LPWSTR) 指向宽字符串    </p>
<p>宏   TCHAR            宏      PTSTR(LPTSTR)</p>
<p>字符数组赋值                </p>
<p>CHAR cha[] = “中国”;                </p>
<p>WCHAR chw[] = L”中国”;                </p>
<p>TCHAR cht[] = TEXT(“中国”);                </p>
<p>为字符串指针赋值：                </p>
<p>PSTR pszChar = “china”;                //多字节字符</p>
<p>PWSTR pszWChar = L”china”;                //宽字符</p>
<p>PTSTR pszTChar = TEXT(“china”);                //如果项目是ASCII的 相当于”china” UNICODE 相当于L”china”</p>
<p>4、各种版本的MessageBox                </p>
<p>MessageBoxA(0,”内容多字节”,”标题”,MB_OK);                </p>
<p>MessageBoxW(0,L”内容宽字节”,L”标题”,MB_OK);                </p>
<p>MessageBox(0,TEXT(“根据项目字符集决定”),TEXT(“标题”),MB_OK);                </p>
<p>Windows提供的API 凡是需要传递字符串参数的函数，都会提供两个版本和一个宏.                </p>
<p>内核对象就是创立时候会在内核里创建一个结构体的对象，看什么属于内核对象可以利用函数closehandle函数查看，或者看其创建的函数，比如第一个参数是不是安全描述符，有安全描述符参数的，一定是内核对象 很多结构体第一个参数都是当前结构体长度大小，为了以后扩容</p>
<p>句柄表作用是为了内核安全，实用句柄表访问内核对象，用户层不会知道内核对象实际地址，另外句柄表是进程私有的，即同一个进程，在不同句柄表的值不一样，内核对象只有进程才有句柄表，但是有个全局句柄表存储的PID，这个是全局的</p>
<p>CloseHandle的作用是将计数器减1，并不是直接关掉，然后为0才关闭，但是线程比较特殊，必须为0并且TerminTerminate了才关闭，所以如果只是线程只是基数为0，也没有被关闭。如果他是某进程主线程，改进程就还没死</p>
<h1 id="进程的创建过程"><a href="#进程的创建过程" class="headerlink" title="进程的创建过程"></a>进程的创建过程</h1><ol>
<li>映射EXE文件</li>
<li>创建内核对象EPROCESS</li>
<li>映射系统DLL（ntdll.dll）</li>
<li>创建线程内核对象ETHREAD</li>
<li>如果线程没有挂起为系统启动线程<br> 映射DLL（ntdll.LdrInitiailize Thunk）<br> 线程开始执行  </li>
<li>如果线程挂起方式创建的：（fdwCreate参数是CREATE_SUSPENDED）<br> 恢复以后开始执行<br> 映射DLL（ntdll.LdrInitiailize Thunk）<br> 线程开始执行  </li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR pszImageName,  </span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR pszCmdLine,  </span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES psaProcess,<span class="comment">//安全描述符   </span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES psaThread,  </span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL fInheritHandles, <span class="comment">//是否允许继承    </span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD fdwCreate, </span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID pvEnvironment,  </span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSTR pszCurDir,<span class="comment">//子进程的工作路径  </span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSTARTUPINFOW psiStartInfo,<span class="comment">//指向一个用于决定新进程的主窗体如何显示的STARTUPINFO结构体。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPPROCESS_INFORMATION pProcInfo  <span class="comment">//创建之后的返回的参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="lpApplicationName"><a href="#lpApplicationName" class="headerlink" title="lpApplicationName"></a>lpApplicationName</h4><p>指向一个NULL结尾的、用来指定可执行模块的字符串。<br>这个字符串可以是可执行模块的绝对路径，也可以是相对路径，在后一种情况下，函数使用当前驱动器和目录建立可执行模块的路径。<br>这个参数可以被设为NULL，在这种情况下，可执行模块的名字必须处于 lpCommandLine 参数最前面并由空格符与后面的字符分开。   </p>
<h4 id="lpProcessAttributes"><a href="#lpProcessAttributes" class="headerlink" title="lpProcessAttributes"></a>lpProcessAttributes</h4><p>指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。</p>
<h4 id="fInheritHandles"><a href="#fInheritHandles" class="headerlink" title="fInheritHandles"></a>fInheritHandles</h4><p>指示新进程是否从调用进程处继承了句柄。<br>如果参数的值为真，调用进程中的每一个可继承的打开句柄都将被子进程继承。被继承的句柄与原进程拥有完全相同的值和访问权限。</p>
<h4 id="DWORD-fdwCreate"><a href="#DWORD-fdwCreate" class="headerlink" title="DWORD fdwCreate"></a>DWORD fdwCreate</h4><p>指定附加的、用来控制优先类和进程的创建的标志。以下的创建标志可以以除下面列出的方式外的任何方式组合后指定。<br>比如挂起之类的（fdwCreate参数是CREATE_SUSPENDED</p>
<h4 id="LPVOID-lpEnvironment"><a href="#LPVOID-lpEnvironment" class="headerlink" title="LPVOID lpEnvironment"></a>LPVOID lpEnvironment</h4><p>指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境。</p>
<h4 id="LPCWSTR-pszImageName"><a href="#LPCWSTR-pszImageName" class="headerlink" title="LPCWSTR pszImageName"></a>LPCWSTR pszImageName</h4><p> 这个参数是模块路径，指向一个以NULL结尾的字符串，这个字符串用来指定子进程的工作路径。这个字符串必须是一个包含驱动器名的绝对路径。如果这个参数为空，新进程将使用与调用进程相同的驱动器和目录。这个选项是一个需要启动应用程序并指定它们的驱动器和工作目录的外壳程序的主要条件。</p>
<h4 id="参数-LPSTARTUPINFOW-psiStartInfo"><a href="#参数-LPSTARTUPINFOW-psiStartInfo" class="headerlink" title="参数 LPSTARTUPINFOW psiStartInfo"></a>参数 LPSTARTUPINFOW psiStartInfo</h4><p> typedef struct _STARTUPINFO {<br>DWORD cb;<br>LPTSTR lpReserved;<br>LPTSTR lpDesktop;<br>LPTSTR lpTitle;<br>DWORD dwX;<br>DWORD dwY;<br>DWORD dwXSize;<br>DWORD dwYSize;<br>DWORD dwXCountChars;<br>DWORD dwYCountChars;<br>DWORD dwFillAttribute;<br>DWORD dwFlags;<br>WORD wShowWindow;<br>WORD cbReserved2;<br>LPBYTE lpReserved2;<br>HANDLE hStdInput;<br>HANDLE hStdOutput;<br>HANDLE hStdError;<br>} STARTUPINFO, *LPSTARTUPINFO;  </p>
<h4 id="LPPROCESS-INFORMATION-pProcInfo"><a href="#LPPROCESS-INFORMATION-pProcInfo" class="headerlink" title="LPPROCESS_INFORMATION pProcInfo"></a>LPPROCESS_INFORMATION pProcInfo</h4><p>最后一个参数，是个返回的参数<br>typedef struct _PROCESS_INFORMATION {<br>  HANDLE hProcess;<br>  HANDLE hThread;<br>  DWORD dwProcessId;<br>  DWORD dwThreadId;<br>} PROCESS_INFORMATION;  </p>
<p>GetModudleFileName//得到当前模块路径</p>
<p>GetCurrentDirecttory//得到当前工作路径  </p>
<p>CreateThread原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HANDLE CreateThread(</span><br><span class="line">LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD</span><br><span class="line">SIZE_T dwStackSize,//initialstacksize 线程堆栈大小</span><br><span class="line">LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction</span><br><span class="line">LPVOID lpParameter,//threadargument //参数</span><br><span class="line">DWORD dwCreationFlags,//creationoption，创建方式，比如挂起</span><br><span class="line">LPDWORD lpThreadId//threadidentifier，返回的参数，线程ID</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>线程回调是可以没有返回值参数的，格式跟要求一样就行，可以强转，还有要传入给回调参数时，比如从主线程传入的话，要保证不要让主线程都结束了，所以有时候用全局变量传参。   </p>
<p>多个线程可以使用同一个回调函数，但是运行起来他们的栈都是不同的   </p>
<p>挂起几次，就要回复几次   </p>
<p>获取线程退出值，可以用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL   GetExitCodeThread (</span><br><span class="line"></span><br><span class="line">       HANDLE         hThread,                  // in,线程handle,也就是CreateThread()的返回值</span><br><span class="line"></span><br><span class="line">       LPDWORD      lpExitCode               //out,存储线程结束代码,也就是线程的返回值</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>等待内核对象结束，单个和多个可用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForSingleObject(</span><br><span class="line"></span><br><span class="line">HANDLE hHandle,</span><br><span class="line">DWORD dwMilliseconds//等待时间</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD WaitForMultipleObjects(</span><br><span class="line">DWORD nCount,//等待的句柄数量</span><br><span class="line">const HANDLE* lpHandles,//指向对象句柄数组的指针</span><br><span class="line">BOOL bWaitAll,//true为全部等待，false为等待第一个</span><br><span class="line">DWORD dwMilliseconds</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="获取线程信息"><a href="#获取线程信息" class="headerlink" title="获取线程信息"></a>获取线程信息</h2><p>线程必须先挂起才能获取上下文，也就是上下文环境context<br>然后context内容太多，需要设立个Flag确定得到哪部分信息<br>关键代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SuspendThread(线程ID);</span><br><span class="line">CONTEXT context;</span><br><span class="line">context.ContextFlags=CONTEXT_INTEGER;</span><br><span class="line">GetThreadContext(线程ID,&amp;context);</span><br></pre></td></tr></table></figure>
<p>能获取就能设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1、创建CRITICAL_SECTION：					</span><br><span class="line">					</span><br><span class="line">CRITICAL_SECTION cs;					</span><br><span class="line">					</span><br><span class="line">2、在使用前进行初始化					</span><br><span class="line">					</span><br><span class="line">InitializeCriticalSection(&amp;cs);					</span><br><span class="line">					</span><br><span class="line">					</span><br><span class="line">3、在函数中使用:					</span><br><span class="line">					</span><br><span class="line">DWORD WINAPI 线程A(PVOID pvParam) 					</span><br><span class="line">&#123;					</span><br><span class="line">      EnterCriticalSection(&amp;cs);					</span><br><span class="line">					</span><br><span class="line">      //对全局遍历X的操作					</span><br><span class="line">					</span><br><span class="line">      LeaveCriticalSection(&amp;cs);					</span><br><span class="line">   return(0);					</span><br><span class="line">&#125;					</span><br><span class="line">					</span><br><span class="line">					</span><br><span class="line">DWORD WINAPI 线程B(PVOID pvParam) 					</span><br><span class="line">&#123;					</span><br><span class="line">      EnterCriticalSection(&amp;g_cs);					</span><br><span class="line">					</span><br><span class="line">      //对全局遍历X的操作					</span><br><span class="line">					</span><br><span class="line">      LeaveCriticalSection(&amp;g_cs);					</span><br><span class="line">   return(0);					</span><br><span class="line">&#125;					</span><br><span class="line">					</span><br><span class="line">4、删除CRITICAL_SECTION					</span><br><span class="line">					</span><br><span class="line">VOID DeleteCriticalSection(PCRITICAL_SECTION pcs);</span><br></pre></td></tr></table></figure>
<p>下面是临界区的一个使用实例，生产消费问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//临界区		</span></span><br><span class="line">CRITICAL_SECTION g_cs;		</span><br><span class="line"><span class="keyword">int</span> g_Max = <span class="number">10</span>;	<span class="comment">//生产几个产品	</span></span><br><span class="line"><span class="keyword">int</span> g_Number = <span class="number">0</span>;<span class="comment">//容器，存储产品                      		</span></span><br><span class="line"><span class="comment">//生产者线程函数  		</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProduct</span><span class="params">(LPVOID pM)</span>  		</span></span><br><span class="line"><span class="function"></span>&#123;  		</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)		</span><br><span class="line">    &#123;  		</span><br><span class="line">        <span class="comment">//互斥的访问缓冲区  		</span></span><br><span class="line">        EnterCriticalSection(&amp;g_cs); 		</span><br><span class="line">		g_Number = <span class="number">1</span>; </span><br><span class="line">		DWORD id = GetCurrentThreadId();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"生产者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">        LeaveCriticalSection(&amp;g_cs); 		</span><br><span class="line">		</span><br><span class="line">    &#125;  		</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  		</span><br><span class="line">&#125;  		</span><br><span class="line"><span class="comment">//消费者线程函数		</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadConsumer</span><span class="params">(LPVOID pM)</span>  		</span></span><br><span class="line"><span class="function"></span>&#123;  		</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)		</span><br><span class="line">    &#123;  		</span><br><span class="line">        <span class="comment">//互斥的访问缓冲区  		</span></span><br><span class="line">        EnterCriticalSection(&amp;g_cs);  		</span><br><span class="line">		g_Number = <span class="number">0</span>; </span><br><span class="line">		DWORD id = GetCurrentThreadId();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"----消费者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">	LeaveCriticalSection(&amp;g_cs); 	</span><br><span class="line">    &#125;  		</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  		</span><br><span class="line">&#125;  		</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>		</span></span><br><span class="line"><span class="function"></span>&#123;		</span><br><span class="line">	InitializeCriticalSection(&amp;g_cs);	</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">    HANDLE hThread[<span class="number">2</span>]; 		</span><br><span class="line">		</span><br><span class="line">    hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProduct, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>); 		</span><br><span class="line">	hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadConsumer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);	</span><br><span class="line">		</span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);  		</span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);  		</span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);		</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//销毁 	</span></span><br><span class="line">    DeleteCriticalSection(&amp;g_cs);  		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程不再试图访问共享资源时<br>注意：要将对全局变量所有操作都放在临界区里，才是正确的</p>
<h1 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h1><p>上文中的临界区是在全局变量，所以只能是同一个进程同步，要使多个进程同步，临界资源就得在内核中，这就是接下来说的互斥体。   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  LPSECURITY_ATTRIBUTES lpMutexAttributes,</span><br><span class="line">  BOOL bInitialOwner,<span class="comment">//希望一创建就有信号，这里是false，</span></span><br><span class="line">  <span class="comment">//没信号互斥体就是没信号，不给信号所有线程会一直等待，</span></span><br><span class="line">  <span class="comment">//填True，如果是互斥体的拥有线程，也可以继续执行   </span></span><br><span class="line">  LPCTSTR lpName<span class="comment">//互斥体名字</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>返回值：<br>A handle to the mutex object indicates success. If the named mutex object existed before the function call, the function returns a handle to the existing object, and GetLastError returns ERROR_ALREADY_EXISTS. Otherwise, the caller created the mutex.</p>
<p>NULL indicates failure. To get extended error information, call GetLastError.</p>
<p>逻辑上的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">进程一：</span><br><span class="line"></span><br><span class="line">HANDLE g_hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE, <span class="string">"XYZ"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程二：</span><br><span class="line"></span><br><span class="line">HANDLE g_hMutex = OpenMutex(MUTEX_ALL_ACCESS,FALSE, <span class="string">"XYZ"</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(g_hMutex,INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑代码</span></span><br><span class="line"></span><br><span class="line">ReleaseMutex(g_hMutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程三：</span><br><span class="line"></span><br><span class="line">HANDLE g_hMutex = OpenMutex(MUTEX_ALL_ACCESS,FALSE, <span class="string">"XYZ"</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(g_hMutex,INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑代码</span></span><br><span class="line"></span><br><span class="line">ReleaseMutex(g_hMutex);</span><br></pre></td></tr></table></figure>
<p>下面是互斥体的生产者消费者问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥体		</span></span><br><span class="line">HANDLE hMutex;		</span><br><span class="line"><span class="keyword">int</span> g_Max = <span class="number">10</span>;		</span><br><span class="line"><span class="keyword">int</span> g_Number = <span class="number">0</span>;                      		</span><br><span class="line"><span class="comment">//生产者线程函数  		</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProduct</span><span class="params">(LPVOID pM)</span>  		</span></span><br><span class="line"><span class="function"></span>&#123;  		</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)		</span><br><span class="line">    &#123;  		</span><br><span class="line">        <span class="comment">//互斥的访问缓冲区  		</span></span><br><span class="line">        WaitForSingleObject(hMutex,INFINITE);		</span><br><span class="line">		g_Number = <span class="number">1</span>; </span><br><span class="line">		DWORD id = GetCurrentThreadId();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"生产者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">        ReleaseMutex(hMutex);		</span><br><span class="line">    &#125;  		</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  		</span><br><span class="line">&#125;  		</span><br><span class="line"><span class="comment">//消费者线程函数		</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadConsumer</span><span class="params">(LPVOID pM)</span>  		</span></span><br><span class="line"><span class="function"></span>&#123;  		</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)		</span><br><span class="line">    &#123;  		</span><br><span class="line">        <span class="comment">//互斥的访问缓冲区  		</span></span><br><span class="line">        WaitForSingleObject(hMutex,INFINITE);		</span><br><span class="line">		g_Number = <span class="number">0</span>; </span><br><span class="line">		DWORD id = GetCurrentThreadId();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"----消费者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">		ReleaseMutex(hMutex);</span><br><span class="line">    &#125;  		</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  		</span><br><span class="line">&#125;  		</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>		</span></span><br><span class="line"><span class="function"></span>&#123;		</span><br><span class="line">	<span class="comment">//创建一个互斥体	</span></span><br><span class="line">	hMutex =  CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="literal">NULL</span>);	</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">    HANDLE hThread[<span class="number">2</span>]; 		</span><br><span class="line">		</span><br><span class="line">    hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProduct, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>); 		</span><br><span class="line">	hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadConsumer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);	</span><br><span class="line">		</span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);  		</span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);  		</span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);		</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//销毁 	</span></span><br><span class="line">    CloseHandle(hMutex);		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>互斥体与临界区的区别：</p>
<p>1、临界区只能用于单个进程间的线程控制.</p>
<p>2、互斥体可以设定等待超时，但临界区不能.</p>
<p>3、线程意外终结时，Mutex可以避免无限等待.</p>
<p>4、Mutex效率没有临界区高.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(					</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hHandle,        <span class="comment">// handle to object					</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMilliseconds   <span class="comment">// time-out interval					</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;					</span><br><span class="line">					</span><br><span class="line">功能说明：					</span><br><span class="line">					</span><br><span class="line">等待函数可使线程自愿进入等待状态，直到一个特定的内核对象变为已通知状态为止.					</span><br><span class="line">					</span><br><span class="line">hHandle:					</span><br><span class="line">					</span><br><span class="line">内核对象句柄，可以是进程也可以是线程.					</span><br><span class="line">					</span><br><span class="line">dwMilliseconds:					</span><br><span class="line">					</span><br><span class="line">等待时间，单位是毫秒  INFINITE(<span class="number">-1</span>)一直等待					</span><br><span class="line">					</span><br><span class="line">返回值：					</span><br><span class="line">					</span><br><span class="line">WAIT_OBJECT_0(<span class="number">0</span>)			等待对象变为已通知		</span><br><span class="line">					</span><br><span class="line">WAIT_TIMEOUT(<span class="number">0x102</span>)			超时		</span><br><span class="line">					</span><br><span class="line">					</span><br><span class="line">特别说明：					</span><br><span class="line">					</span><br><span class="line"><span class="number">1</span>、内核对象中的每种对象都可以说是处于已通知或未通知的状态之中					</span><br><span class="line">					</span><br><span class="line"><span class="number">2</span>、这种状态的切换是由Microsoft为每个对象建立的一套规则来决定的					</span><br><span class="line">					</span><br><span class="line"><span class="number">3</span>、当线程正在运行的时候，线程内核对象处于未通知状态					</span><br><span class="line">					</span><br><span class="line"><span class="number">4</span>、当线程终止运行的时候，它就变为已通知状态					</span><br><span class="line">					</span><br><span class="line"><span class="number">5</span>、在内核中就是个BOOL值，运行时FALSE 结束TRUE					</span><br><span class="line">					</span><br><span class="line">代码演示：					</span><br><span class="line">					</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc1</span><span class="params">(LPVOID lpParameter)</span>					</span></span><br><span class="line"><span class="function"></span>&#123;					</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)				</span><br><span class="line">	&#123;				</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"+++++++++\n"</span>);			</span><br><span class="line">		Sleep(<span class="number">1000</span>);			</span><br><span class="line">	&#125;				</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;				</span><br><span class="line">&#125;					</span><br><span class="line">					</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>					</span></span><br><span class="line"><span class="function"></span>&#123;					</span><br><span class="line">					</span><br><span class="line">	<span class="comment">//创建一个新的线程				</span></span><br><span class="line">	HANDLE hThread1 = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc1, 				</span><br><span class="line">		<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);			</span><br><span class="line">					</span><br><span class="line">	DWORD dwCode = ::WaitForSingleObject(hThread1, INFINITE);				</span><br><span class="line">					</span><br><span class="line">	MessageBox(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);				</span><br><span class="line">					</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是两个信号等待函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">							</span><br><span class="line">DWORD WaitForMultipleObjects(							</span><br><span class="line">  DWORD nCount,             // number of handles in array							</span><br><span class="line">  CONST HANDLE *lpHandles,  // object-handle array							</span><br><span class="line">  BOOL bWaitAll,            // wait option							</span><br><span class="line">  DWORD dwMilliseconds      // time-out interval							</span><br><span class="line">);							</span><br><span class="line">							</span><br><span class="line">功能说明：							</span><br><span class="line">							</span><br><span class="line">同时查看若干个内核对象的已通知状态							</span><br><span class="line">							</span><br><span class="line">nCount：							</span><br><span class="line">							</span><br><span class="line">要查看内核对象的数量							</span><br><span class="line">							</span><br><span class="line">lpHandles：							</span><br><span class="line">							</span><br><span class="line">内核对象数组							</span><br><span class="line">							</span><br><span class="line">bWaitAll：							</span><br><span class="line">							</span><br><span class="line">等到类型  TRUE 等到所有变为已通知  FALSE 只要有一个变为已通知							</span><br><span class="line">							</span><br><span class="line">dwMilliseconds：							</span><br><span class="line">							</span><br><span class="line">超时时间							</span><br><span class="line">							</span><br><span class="line">INFINITE一直等待							</span><br><span class="line">							</span><br><span class="line">返回值：							</span><br><span class="line">							</span><br><span class="line">bWaitAll为TRUE时，返回WAIT_OBJECT_0(0) 代码所以内核对象都变成已通知							</span><br><span class="line">							</span><br><span class="line">bWaitAll为FALSE时，返回最先变成已通知的内核对象在数组中的索引							</span><br><span class="line">							</span><br><span class="line">WAIT_TIMEOUT(0x102)			超时				</span><br><span class="line">							</span><br><span class="line">							</span><br><span class="line">代码演示：							</span><br><span class="line">							</span><br><span class="line">DWORD WINAPI ThreadProc1(LPVOID lpParameter)							</span><br><span class="line">&#123;							</span><br><span class="line">	for(int i=0;i&lt;5;i++)						</span><br><span class="line">	&#123;						</span><br><span class="line">		printf(&quot;+++++++++\n&quot;);					</span><br><span class="line">		Sleep(1000);					</span><br><span class="line">	&#125;						</span><br><span class="line">	return 0;						</span><br><span class="line">&#125;							</span><br><span class="line">							</span><br><span class="line">DWORD WINAPI ThreadProc2(LPVOID lpParameter)							</span><br><span class="line">&#123;							</span><br><span class="line">	for(int i=0;i&lt;3;i++)						</span><br><span class="line">	&#123;						</span><br><span class="line">		printf(&quot;---------\n&quot;);					</span><br><span class="line">		Sleep(1000);					</span><br><span class="line">	&#125;						</span><br><span class="line">							</span><br><span class="line">	return 0;						</span><br><span class="line">&#125;							</span><br><span class="line">							</span><br><span class="line">							</span><br><span class="line">int main(int argc, char* argv[])							</span><br><span class="line">&#123;							</span><br><span class="line">							</span><br><span class="line">	HANDLE hArray[2];						</span><br><span class="line">							</span><br><span class="line">	//创建一个新的线程						</span><br><span class="line">	HANDLE hThread1 = ::CreateThread(NULL, 0, ThreadProc1, 						</span><br><span class="line">		NULL, 0, NULL);					</span><br><span class="line">							</span><br><span class="line">	//创建一个新的线程						</span><br><span class="line">	HANDLE hThread2 = ::CreateThread(NULL, 0, ThreadProc2, 						</span><br><span class="line">		NULL, 0, NULL);					</span><br><span class="line">							</span><br><span class="line">	hArray[0] = hThread1;						</span><br><span class="line">	hArray[1] = hThread2;						</span><br><span class="line">							</span><br><span class="line">	DWORD dwCode = ::WaitForMultipleObjects(2, hArray,FALSE,INFINITE);						</span><br><span class="line">							</span><br><span class="line">	MessageBox(0,0,0,0);						</span><br><span class="line">							</span><br><span class="line">	return 0;						</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件也是通知类型函数，下面是创建通知类型函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(				</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpEventAttributes, <span class="comment">// 安全属性 NULL时为系统默认				</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bManualReset,                      </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 指定将事件对象创建成手动复原还是自动复原。如</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//果是TRUE，那么必须用ResetEvent函数来手工将事</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//件的状态复原到无信号状态。如果设置为FALSE，当一个等待线程被释放以后，</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//系统将会自动将事件状态复原为无信号状态。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bInitialState,                      <span class="comment">// TRUE 已通知状态  FALSE未通知状态，有没有信号				</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpName                           <span class="comment">// 对象名称 以NULL结尾的字符串				</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通知类型就是比如CreateEvent第二个项设置为true时，同步类型，只要有信号，WaitForSingleObject等到之后不会修改当前等待对象的状态，所有等待线程同时执行，false的话是互斥类型，WaitForSingleObject会修改当前等待对象的状态，有信号时只有一个能执行，剩下的是等待状态。会修改信号的状态   </p>
<p>注意setEvent是把自己线程挂起的意思，唤醒另一个线程，把资源让出去。   </p>
<p>后面是使用的示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>、事件对象的控制				</span><br><span class="line">				</span><br><span class="line"><span class="function">BOOL <span class="title">SetEvent</span><span class="params">(HANDLE hEvent)</span></span>;				       <span class="comment">//将对象设置为已通知</span></span><br><span class="line">				</span><br><span class="line"><span class="number">3</span>、关闭时间对象句柄				</span><br><span class="line">				       <span class="comment">//关闭句柄</span></span><br><span class="line">CloseHandle();				</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line"><span class="number">4</span>、线程控制实验：只读形式的线程控制				</span><br><span class="line">				</span><br><span class="line">HANDLE g_hEvent;				</span><br><span class="line">				</span><br><span class="line">HWND hEdit1;				</span><br><span class="line">HWND hEdit2;				</span><br><span class="line">HWND hEdit3;				</span><br><span class="line">HWND hEdit4;				</span><br><span class="line">HANDLE hThread1;				</span><br><span class="line">HANDLE hThread2;				</span><br><span class="line">HANDLE hThread3;				</span><br><span class="line">HANDLE hThread4;				</span><br><span class="line">				</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc1</span><span class="params">(LPVOID lpParameter)</span>				</span></span><br><span class="line"><span class="function"></span>&#123;				</span><br><span class="line">	<span class="comment">//创建事件			</span></span><br><span class="line">	<span class="comment">//默认安全属性  手动设置未通知状态(TRUE)  初始状态未通知 没有名字 			</span></span><br><span class="line">	g_hEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);			</span><br><span class="line">	HANDLE　hThread[<span class="number">3</span>];			</span><br><span class="line">	<span class="comment">//创建3个线程			</span></span><br><span class="line">	hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);			</span><br><span class="line">	hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc3, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);			</span><br><span class="line">	hThread[<span class="number">2</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc4, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);			</span><br><span class="line">				</span><br><span class="line">	<span class="comment">//设置文本框的值			</span></span><br><span class="line">	SetWindowText(hEdit1,<span class="string">"1000"</span>);			</span><br><span class="line">				</span><br><span class="line">	<span class="comment">//设置事件为已通知			</span></span><br><span class="line">	SetEvent(g_hEvent);			</span><br><span class="line">				</span><br><span class="line">	<span class="comment">//等待线程结束 销毁内核对象			</span></span><br><span class="line">	WaitForMultipleObjects(<span class="number">3</span>, hThread, TRUE, INFINITE);  			</span><br><span class="line">	CloseHandle(hThread[<span class="number">0</span>]);  			</span><br><span class="line">	CloseHandle(hThread[<span class="number">1</span>]);			</span><br><span class="line">	CloseHandle(hThread[<span class="number">2</span>]);			</span><br><span class="line">	CloseHandle(g_hEvent);  			</span><br><span class="line">				</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;			</span><br><span class="line">&#125;				</span><br><span class="line">				</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc2</span><span class="params">(LPVOID lpParameter)</span>				</span></span><br><span class="line"><span class="function"></span>&#123;				</span><br><span class="line">	TCHAR szBuffer[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;			</span><br><span class="line">				</span><br><span class="line">	<span class="comment">//当事件变成已通知时 			</span></span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);			</span><br><span class="line">				</span><br><span class="line">	<span class="comment">//读取内容			</span></span><br><span class="line">	GetWindowText(hEdit1,szBuffer,<span class="number">10</span>);			</span><br><span class="line">				</span><br><span class="line">	SetWindowText(hEdit2,szBuffer);			</span><br><span class="line">				</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;			</span><br><span class="line">&#125;				</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc3</span><span class="params">(LPVOID lpParameter)</span>				</span></span><br><span class="line"><span class="function"></span>&#123;				</span><br><span class="line">	TCHAR szBuffer[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;			</span><br><span class="line">				</span><br><span class="line">	<span class="comment">//当事件变成已通知时 			</span></span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);			</span><br><span class="line">				</span><br><span class="line">	<span class="comment">//读取内容			</span></span><br><span class="line">	GetWindowText(hEdit1,szBuffer,<span class="number">10</span>);			</span><br><span class="line">				</span><br><span class="line">	SetWindowText(hEdit3,szBuffer);			</span><br><span class="line">				</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;			</span><br><span class="line">&#125;				</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc4</span><span class="params">(LPVOID lpParameter)</span>				</span></span><br><span class="line"><span class="function"></span>&#123;				</span><br><span class="line">	TCHAR szBuffer[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;			</span><br><span class="line">				</span><br><span class="line">	<span class="comment">//当事件变成已通知时 			</span></span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);			</span><br><span class="line">				</span><br><span class="line">	<span class="comment">//读取内容			</span></span><br><span class="line">	GetWindowText(hEdit1,szBuffer,<span class="number">10</span>);			</span><br><span class="line">				</span><br><span class="line">	SetWindowText(hEdit4,szBuffer);			</span><br><span class="line">				</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外通知类型还能实现线程同步。  </p>
<p>注意：互斥里面没有有序的概念，可能某个线程多次执行，而另一个一直不执行<br>而互斥加有序，就是同步   </p>
<p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/1.png?x-oss-process=style/yangruiqi.com" alt="1"></p>
<p>下面举个示例，生产者和消费者问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件和临界区		</span></span><br><span class="line">HANDLE g_hSet, g_hClear;		</span><br><span class="line"><span class="keyword">int</span> g_Max = <span class="number">10</span>;		</span><br><span class="line"><span class="keyword">int</span> g_Number = <span class="number">0</span>;		</span><br><span class="line">                   		</span><br><span class="line"><span class="comment">//生产者线程函数  		</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProduct</span><span class="params">(LPVOID pM)</span>  		</span></span><br><span class="line"><span class="function"></span>&#123;  		</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)		</span><br><span class="line">    &#123;  		</span><br><span class="line">        WaitForSingleObject(g_hSet, INFINITE);  		</span><br><span class="line">		g_Number = <span class="number">1</span>; </span><br><span class="line">		DWORD id = GetCurrentThreadId();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"生产者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">        SetEvent(g_hClear);   		</span><br><span class="line">    &#125;  		</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  		</span><br><span class="line">&#125;  		</span><br><span class="line"><span class="comment">//消费者线程函数		</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadConsumer</span><span class="params">(LPVOID pM)</span>  		</span></span><br><span class="line"><span class="function"></span>&#123;  		</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)		</span><br><span class="line">    &#123;  		</span><br><span class="line">        WaitForSingleObject(g_hClear, INFINITE);  		</span><br><span class="line">		g_Number = <span class="number">0</span>; </span><br><span class="line">		DWORD id = GetCurrentThreadId();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"----消费者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">        SetEvent(g_hSet);   		</span><br><span class="line">    &#125;  		</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  		</span><br><span class="line">&#125;  		</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>		</span></span><br><span class="line"><span class="function"></span>&#123;		</span><br><span class="line">		</span><br><span class="line">    HANDLE hThread[<span class="number">2</span>]; 		</span><br><span class="line">		</span><br><span class="line">	g_hSet = CreateEvent(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);  	</span><br><span class="line">    g_hClear = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>); 		</span><br><span class="line">		</span><br><span class="line">    hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProduct, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>); 		</span><br><span class="line">	hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadConsumer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);	</span><br><span class="line">		</span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);  		</span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);  		</span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);		</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//销毁 	</span></span><br><span class="line">	CloseHandle(g_hSet);  	</span><br><span class="line">    CloseHandle(g_hClear);  		</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>事件和互斥体区别： 事件有通知类型，可以同时给很多个线程发消息。互斥体没办法线程同步，事件可以。   </p>
<h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><p>本质是画出来的。通过API</p>
<h2 id="窗口的本质-GUI（User32，画图，windows现成的界面）GDI（gdi32-绘图，自己画的）"><a href="#窗口的本质-GUI（User32，画图，windows现成的界面）GDI（gdi32-绘图，自己画的）" class="headerlink" title="窗口的本质 GUI（User32，画图，windows现成的界面）GDI（gdi32 绘图，自己画的）"></a>窗口的本质 GUI（User32，画图，windows现成的界面）GDI（gdi32 绘图，自己画的）</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/2.png?x-oss-process=style/yangruiqi.com" alt="2"></p>
<p>Handle是私有句柄表的索引，HWND是全局句柄表的索引。  </p>
<h2 id="GDI-图形设备接口（Graphics-Device-Interface）"><a href="#GDI-图形设备接口（Graphics-Device-Interface）" class="headerlink" title="GDI 图形设备接口（Graphics Device Interface）"></a>GDI 图形设备接口（Graphics Device Interface）</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/3.png?x-oss-process=style/yangruiqi.com" alt="3"></p>
<p>先得到窗口句柄(设备对象)，<br>HWND </p>
<p>再得到设备上下文，<br>HDC hdc=GetDC(hwnd)</p>
<p>创建画笔<br>hpen=Create(当前笔的分割，宽度，颜色)</p>
<p>关联笔和对象<br>selectObject(hdc,hpen)</p>
<p>移动初始笔的位置<br>MoveToEx(hdc,0,400,原来坐标)</p>
<p>然后开始画比如<br>LineTO（hdc，x坐标，y坐标）</p>
<p>释放资源<br>DeleteObjct(hpen),ReleaseDc(hwnd,hdc)</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>什么是消息：<br>操作系统吧动作记录下来，存储到一个结构体中，这个结构体就是一个消息。   </p>
<h2 id="消息队列：每个线程只有一个消息队列"><a href="#消息队列：每个线程只有一个消息队列" class="headerlink" title="消息队列：每个线程只有一个消息队列"></a>消息队列：每个线程只有一个消息队列</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/4.png?x-oss-process=style/yangruiqi.com" alt="4"></p>
<p>消息产生时，操作系统先接受，遍历所有窗口对象，找到之后，发送到该窗口对象进程的线程，然后线程把他放到消息队列里。<br>一个线程可以多个窗口，一个窗口只属于一个线程   </p>
<h1 id="第一个Windows程序"><a href="#第一个Windows程序" class="headerlink" title="第一个Windows程序"></a>第一个Windows程序</h1><table>
<thead>
<tr>
<th>句柄</th>
<th>所属</th>
</tr>
</thead>
<tbody>
<tr>
<td>HWND</td>
<td>窗口句柄</td>
</tr>
<tr>
<td>HANDLE</td>
<td>内核对象句柄</td>
</tr>
<tr>
<td>HDC</td>
<td>设备句柄</td>
</tr>
<tr>
<td>HINSTANCE</td>
<td>模块句柄</td>
</tr>
</tbody>
</table>
<p>真正对象在0环，这个只是个索引，一个DWORD</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(<span class="comment">//窗口回调</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HWND hwnd, </span></span></span><br><span class="line"><span class="function"><span class="params">  UINT uMsg, </span></span></span><br><span class="line"><span class="function"><span class="params">  WPARAM wParam, </span></span></span><br><span class="line"><span class="function"><span class="params">  LPARAM lParam </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hStatusWnd, uMsg, wParam, lParam)<span class="comment">//调用下默认处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CALLBACK WinMain(</span><br><span class="line">  _In_  HINSTANCE hInstance,<span class="comment">//指向一个模块的句柄，当前模块在内存中的位置</span></span><br><span class="line">  _In_  HINSTANCE hPrevInstance,<span class="comment">//永远空</span></span><br><span class="line">  _In_  LPSTR lpCmdLine,<span class="comment">//对应CreateProcess的命令行参数</span></span><br><span class="line">  _In_  <span class="keyword">int</span> nCmdShow<span class="comment">//对应CreateProcess的创建属性</span></span><br><span class="line">)&#123;</span><br><span class="line">    TCHAR className[]=TEXT(<span class="string">"chuangkouming"</span>);</span><br><span class="line">    <span class="comment">//1.第一步，定义你的窗口怎么样的</span></span><br><span class="line">    WINCLASS wndClass=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始化窗口类</span></span><br><span class="line">    wndClass.hrBackgound=(HBRUSH)COLOR_BACKGROUND;<span class="comment">//设置背景颜色，画刷类型</span></span><br><span class="line">    wndClass.lpszClassName=className;<span class="comment">//设置窗口名</span></span><br><span class="line">    wndClass.hInstance=hInstance;<span class="comment">//当前窗口属于哪个程序</span></span><br><span class="line">    wndClass.lpfnWndProc=WindowProc;<span class="comment">//设置窗口回调函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.注册窗口类</span></span><br><span class="line">    RegisterClass(&amp;wndClass)</span><br><span class="line">    <span class="comment">//3.创建窗口类</span></span><br><span class="line">  <span class="function">HWND <span class="title">CreateWindow</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpClassName, <span class="comment">//窗口类名</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpWindowName, <span class="comment">//窗口名</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwStyle, <span class="comment">//窗口样式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> x, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> y, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nWidth, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nHeight, </span></span></span><br><span class="line"><span class="function"><span class="params">  HWND hWndParent, <span class="comment">//父窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HMENU hMenu, <span class="comment">//菜单句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hInstance, <span class="comment">//属于哪个模块</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PVOID lpParam <span class="comment">//参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">ShowWindow(hwnd,SW_SHOW)</span><br><span class="line"><span class="comment">//3.接受消息并处理</span></span><br><span class="line">MSG msg;</span><br><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPMSG lpMsg, <span class="comment">//消息放在这</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HWND hWnd, <span class="comment">//null所有消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT wMsgFilterMin, <span class="comment">//过滤条件。0是全要</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT wMsgFilterMax </span></span></span><br><span class="line"><span class="function"><span class="params">      )</span></span>;</span><br><span class="line">BOOL bRet;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">while</span>( (bRet = GetMessage( &amp;msg, hWnd, <span class="number">0</span>, <span class="number">0</span> )) != <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (bRet == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// handle the error and possibly exit</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//转换消息，把键盘虚拟码转成字符</span></span><br><span class="line">        TranslateMessage(&amp;msg); </span><br><span class="line">    <span class="comment">//分发消息，</span></span><br><span class="line">        DispatchMessage(&amp;msg); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>char szOutBuff[0x80]</p>
<p>窗口不能用printf,必须用OutputDebugString(szOutBuff),但是这不能打印变量，所以先得用sprint(szOutbuff,”%d”,GetLastError())格式化字符串</p>
<p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/7.png" alt="5"></p>
<h1 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h1><p>typedef struct tagMSG {<br>  HWND hwnd; //属于哪个窗口句柄<br>  UINT message;//消息的类型<br>  WPARAM wParam; //<br>  LPARAM lParam; //<br>  DWORD time; //消息什么时候产生的<br>  POINT pt; //消息在什么类型产生的<br>} MSG;</p>
<h1 id="子窗口"><a href="#子窗口" class="headerlink" title="子窗口"></a>子窗口</h1><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/8.png" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HWND CreateWindow( </span><br><span class="line">  &quot;Edit&quot;, //窗口类名</span><br><span class="line">  &quot;&quot;, //窗口名</span><br><span class="line">  WS_CHILD|//窗口样式,子窗口必带</span><br><span class="line">  WS_VISIBLE|WS_VSCROLL</span><br><span class="line">, </span><br><span class="line">  int x, </span><br><span class="line">  int y, </span><br><span class="line">  int nWidth, </span><br><span class="line">  int nHeight, </span><br><span class="line">  HWND hWndParent, //父窗口句柄</span><br><span class="line">  HMENU hMenu, //父窗口的话菜单句柄，子窗口的话是标识</span><br><span class="line">  HANDLE hInstance, //属于哪个模块，一般用个全局变量，在父窗口那赋值</span><br><span class="line">  PVOID lpParam //参数</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>子窗口通过WM_COMMAND向父窗口发消息，在父窗口回调里可以处理WM_COMMAND，如果要区分是哪个子窗口，可以通过回调函数的参数确定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WPARAM wParam; //</span><br><span class="line">  LPARAM lParam; //</span><br></pre></td></tr></table></figure></p>
<p>一个是编号（HMENU hMenu，也就是wParam的低16位LOWORD），一个是句柄，<br>如果想设置文本框内容可以<br>SetDlgText（hwnd，编号，字符串）<br>得到就是GetDlgText</p>
<p>按钮就是一个子窗口，<br>按钮的WNDCLASS不是我们定义的，是系统预定义好的。如果我们想知道，系统预定义的WNDCLASS都包含什么样的信息                                </p>
<p>怎么做？                                </p>
<p>TCHAR szBuffer[0x20];<br>GetClassName(hwndPushButton,szBuffer,0x20);                                </p>
<p>WNDCLASS wc;<br>GetClassInfo(hAppInstance,szBuffer,&amp;wc);<br>OutputDebugStringF(“–&gt;%s\n”,wc.lpszClassName);<br>OutputDebugStringF(“–&gt;%x\n”,wc.lpfnWndProc);                                </p>
<p>总结：                                </p>
<p>1、按钮是一种特殊的窗体，并不需要提供单独的窗口回调函数.                                </p>
<p>2、当按钮有事件产生时，会给父窗口消息处理程序发送一个WM_COMMAND消息                                </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">按钮--&gt;系统提供WinProc</span><br><span class="line">系统提供WinProc--&gt;父窗口的WinProc</span><br></pre></td></tr></table></figure>
<p>系统提供WinProc将消息转换成WM_COMMAND，发给父窗口</p>
<p>下面是视频PPT的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：创建Windows应用程序  选择空项目									</span><br><span class="line">									</span><br><span class="line">									</span><br><span class="line">步骤<span class="number">2</span>：在新建项窗口中选C++代码文件 创建一个新的cpp文件									</span><br><span class="line">									</span><br><span class="line">									</span><br><span class="line">步骤<span class="number">3</span>：在新的cpp文件中添加:<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;									</span></span></span><br><span class="line">									</span><br><span class="line">并添加入口函数：									</span><br><span class="line">									</span><br><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(  						CALLBACK 是一个宏 			</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_  HINSTANCE hInstance,  					#define CALLBACK    __stdcall			</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_  HINSTANCE hPrevInstance,  								</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_  LPSTR lpCmdLine,  								</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_  <span class="keyword">int</span> nCmdShow  								</span></span></span><br><span class="line">	)  					所有的Win32     API函数都遵循该约定			</span><br><span class="line">&#123;  									</span><br><span class="line">									</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  								</span><br><span class="line">&#125;  									</span><br><span class="line">									</span><br><span class="line">步骤<span class="number">4</span>：设计窗口类									</span><br><span class="line">									</span><br><span class="line">代码：									</span><br><span class="line">									</span><br><span class="line"><span class="comment">//窗口的类名									</span></span><br><span class="line">TCHAR className[] = <span class="string">"My First Window"</span>; 									</span><br><span class="line">									</span><br><span class="line"><span class="comment">// 创建窗口类的对象 									</span></span><br><span class="line">WNDCLASS wndclass = &#123;<span class="number">0</span>&#125;;						<span class="comment">//一定要先将所有值赋值			</span></span><br><span class="line">wndclass.hbrBackground = (HBRUSH)COLOR_MENU;						<span class="comment">//窗口的背景色			</span></span><br><span class="line">wndclass.lpfnWndProc = WindowProc;						<span class="comment">//窗口过程函数			</span></span><br><span class="line">wndclass.lpszClassName = className;						<span class="comment">//窗口类的名字			</span></span><br><span class="line">wndclass.hInstance = hInstance;						<span class="comment">//定义窗口类的应用程序的实例句柄			</span></span><br><span class="line">									</span><br><span class="line">									</span><br><span class="line">步骤<span class="number">5</span>：注册窗口类									</span><br><span class="line">									</span><br><span class="line">RegisterClass(&amp;wndclass);  									</span><br><span class="line">									</span><br><span class="line">									</span><br><span class="line">步骤<span class="number">6</span>：创建窗口									</span><br><span class="line">									</span><br><span class="line"><span class="comment">// 创建窗口  									</span></span><br><span class="line">HWND hwnd = CreateWindow(  									</span><br><span class="line">	className,				<span class="comment">//类名				</span></span><br><span class="line">	TEXT(<span class="string">"我的第一个窗口"</span>),				<span class="comment">//窗口标题				</span></span><br><span class="line">	WS_OVERLAPPEDWINDOW,				<span class="comment">//窗口外观样式 				</span></span><br><span class="line">	<span class="number">10</span>,				<span class="comment">//相对于父窗口的X坐标				</span></span><br><span class="line">	<span class="number">10</span>,				<span class="comment">//相对于父窗口的Y坐标				</span></span><br><span class="line">	<span class="number">600</span>,				<span class="comment">//窗口的宽度  				</span></span><br><span class="line">	<span class="number">300</span>,				<span class="comment">//窗口的高度  				</span></span><br><span class="line">	<span class="literal">NULL</span>,				<span class="comment">//父窗口句柄，为NULL  				</span></span><br><span class="line">	<span class="literal">NULL</span>,				<span class="comment">//菜单句柄，为NULL  				</span></span><br><span class="line">	hInstance,				<span class="comment">//当前应用程序的句柄  				</span></span><br><span class="line">	<span class="literal">NULL</span>);				<span class="comment">//附加数据一般为NULL				</span></span><br><span class="line">									</span><br><span class="line"><span class="keyword">if</span>(hwnd == <span class="literal">NULL</span>)					<span class="comment">//是否创建成功  				</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  								</span><br><span class="line">									</span><br><span class="line">									</span><br><span class="line">步骤<span class="number">7</span>：显示窗口									</span><br><span class="line">									</span><br><span class="line"><span class="comment">// 显示窗口  									</span></span><br><span class="line">ShowWindow(hwnd, SW_SHOW);  									</span><br><span class="line">									</span><br><span class="line">步骤<span class="number">8</span>：消息循环									</span><br><span class="line">									</span><br><span class="line">MSG msg;  									</span><br><span class="line"><span class="keyword">while</span>(GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))  									</span><br><span class="line">&#123;  									</span><br><span class="line">	TranslateMessage(&amp;msg);  								</span><br><span class="line">	DispatchMessage(&amp;msg);  								</span><br><span class="line">&#125;  									</span><br><span class="line">									</span><br><span class="line">									</span><br><span class="line">步骤<span class="number">9</span>：回调函数									</span><br><span class="line">									</span><br><span class="line"><span class="comment">/*									</span></span><br><span class="line"><span class="comment">窗口消息处理程序 窗口回调函数：									</span></span><br><span class="line"><span class="comment">									</span></span><br><span class="line"><span class="comment">1、窗口回调函数处理过的消息，必须传回0.									</span></span><br><span class="line"><span class="comment">									</span></span><br><span class="line"><span class="comment">2、窗口回调不处理的消息，由DefWindowProc来处理.									</span></span><br><span class="line"><span class="comment">*/</span>									</span><br><span class="line">									</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(  									</span></span></span><br><span class="line"><span class="function"><span class="params">							IN  HWND hwnd,  		</span></span></span><br><span class="line"><span class="function"><span class="params">							IN  UINT uMsg,  		</span></span></span><br><span class="line"><span class="function"><span class="params">							IN  WPARAM wParam,  		</span></span></span><br><span class="line"><span class="function"><span class="params">							IN  LPARAM lParam  		</span></span></span><br><span class="line"><span class="function"><span class="params">							)</span>  		</span></span><br><span class="line"><span class="function"></span>&#123;  									</span><br><span class="line">	<span class="keyword">switch</span>(uMsg)								</span><br><span class="line">	&#123;								</span><br><span class="line">		<span class="comment">//窗口消息							</span></span><br><span class="line">	<span class="keyword">case</span> WM_CREATE: 								</span><br><span class="line">		&#123;							</span><br><span class="line">			DbgPrintf(<span class="string">"WM_CREATE %d %d\n"</span>,wParam,lParam);						</span><br><span class="line">			CREATESTRUCT* createst = (CREATESTRUCT*)lParam;						</span><br><span class="line">			DbgPrintf(<span class="string">"CREATESTRUCT %s\n"</span>,createst-&gt;lpszClass);						</span><br><span class="line">									</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;						</span><br><span class="line">		&#125;							</span><br><span class="line">	<span class="keyword">case</span> WM_MOVE:								</span><br><span class="line">		&#123;							</span><br><span class="line">			DbgPrintf(<span class="string">"WM_MOVE %d %d\n"</span>,wParam,lParam);						</span><br><span class="line">			POINTS points = MAKEPOINTS(lParam);						</span><br><span class="line">			DbgPrintf(<span class="string">"X Y %d %d\n"</span>,points.x,points.y);						</span><br><span class="line">									</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;						</span><br><span class="line">		&#125;							</span><br><span class="line">	<span class="keyword">case</span> WM_SIZE:								</span><br><span class="line">		&#123;							</span><br><span class="line">			DbgPrintf(<span class="string">"WM_SIZE %d %d\n"</span>,wParam,lParam);						</span><br><span class="line">			<span class="keyword">int</span> newWidth  = (<span class="keyword">int</span>)(<span class="keyword">short</span>) LOWORD(lParam);    						</span><br><span class="line">			<span class="keyword">int</span> newHeight  = (<span class="keyword">int</span>)(<span class="keyword">short</span>) HIWORD(lParam);   						</span><br><span class="line">			DbgPrintf(<span class="string">"WM_SIZE %d %d\n"</span>,newWidth,newHeight);						</span><br><span class="line">									</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;						</span><br><span class="line">		&#125;							</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:								</span><br><span class="line">		&#123;							</span><br><span class="line">			DbgPrintf(<span class="string">"WM_DESTROY %d %d\n"</span>,wParam,lParam);						</span><br><span class="line">			PostQuitMessage(<span class="number">0</span>);						</span><br><span class="line">									</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;						</span><br><span class="line">		&#125;							</span><br><span class="line">		<span class="comment">//键盘消息							</span></span><br><span class="line">	<span class="keyword">case</span> WM_KEYUP:								</span><br><span class="line">		&#123;							</span><br><span class="line">			DbgPrintf(<span class="string">"WM_KEYUP %d %d\n"</span>,wParam,lParam);						</span><br><span class="line">									</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;						</span><br><span class="line">		&#125;							</span><br><span class="line">	<span class="keyword">case</span> WM_KEYDOWN:								</span><br><span class="line">		&#123;							</span><br><span class="line">			DbgPrintf(<span class="string">"WM_KEYDOWN %d %d\n"</span>,wParam,lParam);						</span><br><span class="line">									</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;						</span><br><span class="line">		&#125;							</span><br><span class="line">		<span class="comment">//鼠标消息							</span></span><br><span class="line">	<span class="keyword">case</span> WM_LBUTTONDOWN:								</span><br><span class="line">		&#123;							</span><br><span class="line">			DbgPrintf(<span class="string">"WM_LBUTTONDOWN %d %d\n"</span>,wParam,lParam);						</span><br><span class="line">			POINTS points = MAKEPOINTS(lParam);						</span><br><span class="line">			DbgPrintf(<span class="string">"WM_LBUTTONDOWN %d %d\n"</span>,points.x,points.y);						</span><br><span class="line">									</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;						</span><br><span class="line">		&#125;							</span><br><span class="line">	&#125;								</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd,uMsg,wParam,lParam);								</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是视频的关于消息的PPT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">				</span><br><span class="line">Windows中的事件是一个“动作”，这个动作可能是用户操作应用程序产生的，也可能是Windows自己产生的.				</span><br><span class="line">				</span><br><span class="line">而消息，就是用来描述这些“动作”的，比如：				</span><br><span class="line">				</span><br><span class="line">这个动作是什么时候产生的？				</span><br><span class="line">				</span><br><span class="line">哪个应用程序产生的？				</span><br><span class="line">				</span><br><span class="line">在什么位置产生的？				</span><br><span class="line">				</span><br><span class="line">等等。。。				</span><br><span class="line">				</span><br><span class="line">Windows为了能够准确的描述这些信息，提供了一个结构体：MSG，该结构体里面记录的事件的详细信息.				</span><br><span class="line">				</span><br><span class="line">typedef struct tagMSG &#123;				</span><br><span class="line">  HWND   hwnd; 				</span><br><span class="line">  UINT   message; 				</span><br><span class="line">  WPARAM wParam; 				</span><br><span class="line">  LPARAM lParam; 				</span><br><span class="line">  DWORD  time; 				</span><br><span class="line">  POINT  pt; 				</span><br><span class="line">&#125; MSG, *PMSG; 				</span><br><span class="line">				</span><br><span class="line">说明：				</span><br><span class="line">				</span><br><span class="line">1、hwnd：				</span><br><span class="line">				</span><br><span class="line">表示消息所属的窗口				</span><br><span class="line">				</span><br><span class="line">一个消息一般都是与某个窗口相关联的				</span><br><span class="line">				</span><br><span class="line">在Windows中 HWND类型的变量通常用来标识窗口。				</span><br><span class="line">				</span><br><span class="line">2、message				</span><br><span class="line">				</span><br><span class="line">在Windows中，消息是由一个数值来表示的				</span><br><span class="line">				</span><br><span class="line">但是由于数值不便于记忆，所以Windows将消息对应的数值定义为WM_XXX宏（WM == Window Message）				</span><br><span class="line">				</span><br><span class="line">鼠标左键按下 WM_LBUTTONDOWN				键盘按下 WM_KEYDOWN</span><br><span class="line">				</span><br><span class="line">3、wParam 和 lParam				</span><br><span class="line">				</span><br><span class="line">32位消息的特定附加信息,具体表示什么处决于message 				</span><br><span class="line">				</span><br><span class="line">4、time				</span><br><span class="line">				</span><br><span class="line">消息创建时的时间 				</span><br><span class="line">				</span><br><span class="line">5、消息创建时的鼠标位置</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]. 滴水视频</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yangruiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/07/05/WIN32编程视频的相关笔记一/">http://yoursite.com/2018/07/05/WIN32编程视频的相关笔记一/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">manyouyou</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/WIN32/">WIN32</a><a class="post-meta__tags" href="/tags/WIN32编程/">WIN32编程</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/zhifubao.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/weixin.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/05/WIN32编程视频的相关笔记二/"><i class="fa fa-chevron-left">  </i><span>WIN32编程视频的相关笔记二</span></a></div><div class="next-post pull-right"><a href="/2018/07/05/远程线程注入/"><span>远程线程注入</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'yangruiqiyr',
  repo: 'BlogGitment',
  oauth: {
    client_id: 'dfbfacd2fb59427cee9e',
    client_secret: 'a39b872c7d6ddf551a16ebf9a3d59ce9b57508bb'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2018 By yangruiqi</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="www.yangruiqiyr.com">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.5"></script><script src="/js/fancybox.js?version=1.5.5"></script><script src="/js/sidebar.js?version=1.5.5"></script><script src="/js/copy.js?version=1.5.5"></script><script src="/js/fireworks.js?version=1.5.5"></script><script src="/js/transition.js?version=1.5.5"></script><script src="/js/scroll.js?version=1.5.5"></script><script src="/js/head.js?version=1.5.5"></script></body></html>