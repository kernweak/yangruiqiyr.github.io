<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Windows等待唤醒机制"><meta name="keywords" content="事件和互斥体,事件等待机制"><meta name="author" content="yangruiqi,undefined"><meta name="copyright" content="yangruiqi"><title>Windows等待唤醒机制 | manyouyou</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.5"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#临界区"><span class="toc-number">1.</span> <span class="toc-text">临界区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#临界区：一次只允许一个线程进入直到离开"><span class="toc-number">1.1.</span> <span class="toc-text">临界区：一次只允许一个线程进入直到离开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自己实现临界区"><span class="toc-number">1.2.</span> <span class="toc-text">自己实现临界区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自旋锁"><span class="toc-number">2.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows自旋锁"><span class="toc-number">2.1.</span> <span class="toc-text">Windows自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结："><span class="toc-number">2.2.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程等待与唤醒"><span class="toc-number">3.</span> <span class="toc-text">线程等待与唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows等待与唤醒机制"><span class="toc-number">3.1.</span> <span class="toc-text">Windows等待与唤醒机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可等待对象"><span class="toc-number">3.2.</span> <span class="toc-text">可等待对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可等待对象的差异"><span class="toc-number">3.3.</span> <span class="toc-text">可等待对象的差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个线程等待一个对象"><span class="toc-number">3.4.</span> <span class="toc-text">一个线程等待一个对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个线程等待多个对象"><span class="toc-number">3.5.</span> <span class="toc-text">一个线程等待多个对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#等待网"><span class="toc-number">3.6.</span> <span class="toc-text">等待网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WaitForSingleObject函数分析"><span class="toc-number">4.</span> <span class="toc-text">WaitForSingleObject函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WaitForSingleObject参数说明"><span class="toc-number">4.1.</span> <span class="toc-text">WaitForSingleObject参数说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NtWaitForSingleObject"><span class="toc-number">4.2.</span> <span class="toc-text">NtWaitForSingleObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KeWaitForSingleObject：上半部分"><span class="toc-number">4.3.</span> <span class="toc-text">KeWaitForSingleObject：上半部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关键循环："><span class="toc-number">4.3.1.</span> <span class="toc-text">关键循环：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-1"><span class="toc-number">4.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于强制唤醒"><span class="toc-number">4.5.</span> <span class="toc-text">关于强制唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#个人总结"><span class="toc-number">4.6.</span> <span class="toc-text">个人总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EVENT"><span class="toc-number">5.</span> <span class="toc-text">EVENT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#被等待对象不同，主要在2个点上会有差异："><span class="toc-number">5.1.</span> <span class="toc-text">被等待对象不同，主要在2个点上会有差异：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SetEvent函数分析"><span class="toc-number">5.2.</span> <span class="toc-text">SetEvent函数分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SEMAPHORE"><span class="toc-number">6.</span> <span class="toc-text">SEMAPHORE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建信号量对象"><span class="toc-number">6.1.</span> <span class="toc-text">创建信号量对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReleaseSemaphore函数分析"><span class="toc-number">6.2.</span> <span class="toc-text">ReleaseSemaphore函数分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MUTANT"><span class="toc-number">6.3.</span> <span class="toc-text">MUTANT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要有互斥体：等待对象被遗弃"><span class="toc-number">6.4.</span> <span class="toc-text">为什么要有互斥体：等待对象被遗弃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要有互斥体：重入"><span class="toc-number">6.5.</span> <span class="toc-text">为什么要有互斥体：重入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MUTANT结构体介绍"><span class="toc-number">6.6.</span> <span class="toc-text">MUTANT结构体介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么互斥体能重复进入临界区"><span class="toc-number">6.6.1.</span> <span class="toc-text">为什么互斥体能重复进入临界区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CreateMutex函数Ring3"><span class="toc-number">6.7.</span> <span class="toc-text">CreateMutex函数Ring3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果信号量不为零或者互斥体属于当前线程都能进入临界区"><span class="toc-number">6.8.</span> <span class="toc-text">如果信号量不为零或者互斥体属于当前线程都能进入临界区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何解决重入问题"><span class="toc-number">6.9.</span> <span class="toc-text">如何解决重入问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何解决等待对象被遗弃问题"><span class="toc-number">6.10.</span> <span class="toc-text">如何解决等待对象被遗弃问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#禁用内核APC"><span class="toc-number">6.11.</span> <span class="toc-text">禁用内核APC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/%E5%A4%B4%E5%83%8F/touxiang.jpg"></div><div class="author-info__name text-center">yangruiqi</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/yangruiqiyr" target="_blank">跟随我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">27</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">相关网址</div><a class="author-info-links__name text-center" href="http://blog.topsec.com.cn/" target="_blank">天融信阿尔法实验室</a><a class="author-info-links__name text-center" href="https://www.baidu.com/" target="_blank">百度</a><a class="author-info-links__name text-center" href="https://bbs.pediy.com/" target="_blank">看雪</a><a class="author-info-links__name text-center" href="http://www.freebuf.com/" target="_blank">FreeBuf</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/主题/主题1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">manyouyou</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">档案</a><a class="site-page" href="/tags">标题</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">Windows等待唤醒机制</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/笔记-Windows事件等待机制笔记/">笔记 - Windows事件等待机制笔记</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>并发是指多个线程在同时执行：<br>单核（是分时执行，不是真正的同时）<br>多核（在某一个时刻，会同时有多个线程再执行）<br>同步则是保证在并发执行的环境中各个线程可以有序的执行    </p>
<h2 id="临界区：一次只允许一个线程进入直到离开"><a href="#临界区：一次只允许一个线程进入直到离开" class="headerlink" title="临界区：一次只允许一个线程进入直到离开"></a>临界区：一次只允许一个线程进入直到离开</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwFlag = 0;	//实现临界区的方式就是加锁</span><br><span class="line">			//锁：全局变量  进去加一 出去减一</span><br><span class="line"></span><br><span class="line">if(dwFlag  == 0)		//进入临界区	</span><br><span class="line">&#123;	</span><br><span class="line">	dwFlag   = 1	</span><br><span class="line">	.......</span><br><span class="line">	.......</span><br><span class="line">	.......</span><br><span class="line">		</span><br><span class="line">	dwFlag   = 0	//离开临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自己实现临界区"><a href="#自己实现临界区" class="headerlink" title="自己实现临界区"></a>自己实现临界区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">全局变量：Flag = 0</span><br><span class="line"></span><br><span class="line">进入临界区：		</span><br><span class="line">Lab：</span><br><span class="line">	mov eax,1</span><br><span class="line">	lock xadd [Flag],eax</span><br><span class="line">	cmp eax,0</span><br><span class="line">	jz endLab</span><br><span class="line">	dec [Flag]</span><br><span class="line">	//线程等待Sleep..</span><br><span class="line">endLab:</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">离开临界区：		</span><br><span class="line"></span><br><span class="line">lock dec [Flag]</span><br></pre></td></tr></table></figure>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><h2 id="Windows自旋锁"><a href="#Windows自旋锁" class="headerlink" title="Windows自旋锁"></a>Windows自旋锁</h2><p>关键代码：<br>lock bts dword ptr [ecx], 0</p>
<p>LOCK是锁前缀，保证这条指令在同一时刻只能有一个CPU访问<br>BTS指令：设置并检测  将ECX指向数据的第0位置1<br>如果[ECX]原来的值==0  那么CF=1 否则CF=0   </p>
<p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/23.png" alt="23"></p>
<p>写pause，因为是多核，不用切换线程，等一等就好，Sleep会造成线程切换，没必要。  </p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1、自旋锁只对多核有意义。<br>(查看不同版本的KeAcquireSpinLockAtDpcLevel函数)<br>2、自旋锁与临界区、事件、互斥体一样，都是一种同步机制，都可以让当前线程<br>处于等待状态，区别在于自旋锁不用切换线程。</p>
<h1 id="线程等待与唤醒"><a href="#线程等待与唤醒" class="headerlink" title="线程等待与唤醒"></a>线程等待与唤醒</h1><p>我们在之前的课程里面讲解了如何自己实现临界区以及什么是Windows自旋锁，这两种同步方案在线程无法进入临界区时都会让当前线程进入等待状态，<br>一种是通过Sleep函数实现的，一种是通过让当前的CPU”空转”实现的，但这两种等待方式都有局限性：<br>1) 通过Sleep函数进行等待，等待时间该无法确定<br>2) 通过“空转”的方式进行等待，只有等待时间很短的情况下才有意义，否则对CPU资源是种浪费。而且自旋锁只能在多核的环境下才有意义。<br>有没有更加合理的等待方式呢？只有在条件成熟的时候才将当前线程唤醒？</p>
<h2 id="Windows等待与唤醒机制"><a href="#Windows等待与唤醒机制" class="headerlink" title="Windows等待与唤醒机制"></a>Windows等待与唤醒机制</h2><p>在Windows中，一个线程可以通过等待一个或者多个可等待对象，从而进入等待状态，另一个线程可以在某些时刻唤醒等待这些对象的其他线程。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">线程AWaitForSingleObject/WaitForMultipleObjects</span><br><span class="line">--&gt;可等待对象</span><br><span class="line">线程BSetEvent/ReleaseSemaphore/ReleaseMutant</span><br><span class="line">--&gt;可等待对象</span><br></pre></td></tr></table></figure>
<h2 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在Windbg中查看如下结构体：			</span><br><span class="line">			</span><br><span class="line">dt _KPROCESS			进程</span><br><span class="line">			</span><br><span class="line">dt _KTHREAD			线程</span><br><span class="line"></span><br><span class="line">dt _KTIMER			定时器</span><br><span class="line">			</span><br><span class="line">dt _KSEMAPHORE		信号量</span><br><span class="line">			</span><br><span class="line">dt _KEVENT			事件</span><br><span class="line">			</span><br><span class="line">dt _KMUTANT			互斥体</span><br><span class="line">			</span><br><span class="line">dt _FILE_OBJECT		文件</span><br></pre></td></tr></table></figure>
<p>这些可等待对象的特点是都是一个结构体，都有一个成员，即第一个成员_DISPATCHER_HEADER（有些·1比较特殊，文件比较特殊不在第一个成员）   </p>
<p>那么第一个是与不是_DISPATCHER_HEADER的对象有什么区别呢   </p>
<h2 id="可等待对象的差异"><a href="#可等待对象的差异" class="headerlink" title="可等待对象的差异"></a>可等待对象的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject(3环)</span><br><span class="line">			</span><br><span class="line">NtWaitForSingleObject(内核)		</span><br><span class="line">		1) 通过3环用户提供的句柄，找到等待对象的内核地址。            </span><br><span class="line"></span><br><span class="line">	 	2) 如果是以_DISPATCHER_HEADER开头，直接使用。</span><br><span class="line">			</span><br><span class="line">		3) 如果不是以_DISPATCHER_HEADER开头的对象,则			找到在其中嵌入的_DISPATCHER_HEADER对象。</span><br><span class="line"></span><br><span class="line">KeWaitForSingleObject(内核)</span><br><span class="line">			核心功能，后面会讲</span><br></pre></td></tr></table></figure>
<h2 id="一个线程等待一个对象"><a href="#一个线程等待一个对象" class="headerlink" title="一个线程等待一个对象"></a>一个线程等待一个对象</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/24.png" alt="24"></p>
<p>被等待对象有个变量是WaitListHead圈着所有等待块，把等待他的所有线程的等待块，就是第一个参数WaitListEntry</p>
<h2 id="一个线程等待多个对象"><a href="#一个线程等待多个对象" class="headerlink" title="一个线程等待多个对象"></a>一个线程等待多个对象</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/25.png" alt="25"></p>
<h2 id="等待网"><a href="#等待网" class="headerlink" title="等待网"></a>等待网</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/26.png" alt="26"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、等待中的线程，一定在等待链表中(KiWaitListHead)，同时也一定在这张网上(KTHREAD +5C的位置不为空)。</p>
<p>2、线程通过调用WaitForSingleObject/WaitForMultipleObjects函数将自己挂到这张网上。</p>
<p>3、线程什么时候会再次执行取决于其他线程何时调用相关函数，等待对象不同调用的函数也不同。</p>
<h1 id="WaitForSingleObject函数分析"><a href="#WaitForSingleObject函数分析" class="headerlink" title="WaitForSingleObject函数分析"></a>WaitForSingleObject函数分析</h1><p>无论可等待对象是何种类型，线程都是通过：<br>WaitForSingleObject<br>WaitForMultipleObjects<br>进入等待状态的，这两个函数是理解线程等待与唤醒进制的核心   </p>
<h2 id="WaitForSingleObject参数说明"><a href="#WaitForSingleObject参数说明" class="headerlink" title="WaitForSingleObject参数说明"></a>WaitForSingleObject参数说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject对应的内核函数：</span><br><span class="line"></span><br><span class="line">NTSTATUS __stdcall NtWaitForSingleObject(</span><br><span class="line">HANDLE Handle, </span><br><span class="line">BOOLEAN Alertable, </span><br><span class="line">PLARGE_INTEGER Timeout)</span><br><span class="line"></span><br><span class="line">Handle 	用户层传递的等待对象的句柄(具体细节参加句柄表专题)</span><br><span class="line"></span><br><span class="line">Alertable 对应KTHREAD结构体的Alertable属性  如果为1 在插入用户APC时，该线程将被吵醒  </span><br><span class="line"></span><br><span class="line">Timeout 超时时间</span><br></pre></td></tr></table></figure>
<h2 id="NtWaitForSingleObject"><a href="#NtWaitForSingleObject" class="headerlink" title="NtWaitForSingleObject"></a>NtWaitForSingleObject</h2><p>1)  调用ObReferenceObjectByHandle函数，通过对象句柄找到等待对象结构体地址。<br>2)  调用KeWaitForSingleObject函数，进入关键循环。    </p>
<h2 id="KeWaitForSingleObject：上半部分"><a href="#KeWaitForSingleObject：上半部分" class="headerlink" title="KeWaitForSingleObject：上半部分"></a>KeWaitForSingleObject：上半部分</h2><p>这个函数开始执行需要准备等待块，当前线程通过等待块与被等待线程关联。当等待时间不为零，有2个要等待的事件，还有一个是定时器。<br>1) 向_KTHREAD(+70)位置的等待块赋值。</p>
<p>2) 如果超时时间不为0，KTHREAD(+70)第四个等待块与第一个等待块关联起来：<br>第一个等待块指向第四个等待块，第四个等待块指向第一个等待块。</p>
<p>3) KTHREAD(+5C)指向第一个_KWAIT_BLOCK。</p>
<p>4) 进入关键循环</p>
<h3 id="关键循环："><a href="#关键循环：" class="headerlink" title="关键循环："></a>关键循环：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +0x000 Type		//对象类型  </span><br><span class="line">   +0x001 Absolute         </span><br><span class="line">   +0x002 Size             </span><br><span class="line">   +0x003 Inserted         </span><br><span class="line">   +0x004 SignalState	//是否有信号(&gt;0)        </span><br><span class="line">   +0x008 WaitListHead     	//双向链表头  圈着所有等待块</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)<span class="comment">//每次线程被其他线程唤醒，都要进入这个循环</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(符合激活条件)<span class="comment">//1、超时   2、等待对象SignalState&gt;0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1) 修改SignalState</span></span><br><span class="line">		<span class="comment">//2) 退出循环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(第一次执行)</span><br><span class="line">		      将当前线程的等待块挂到等待对象的链表(WaitListHead)中;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将自己挂入等待队列(KiWaitListHead)</span></span><br><span class="line">		<span class="comment">//切换线程...再次获得CPU时，从这里开始执行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1) 线程将自己+5C位置清0</span></span><br><span class="line"><span class="comment">//2) 释放_KWAIT_BLOCK所占内存</span></span><br></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>不同的等待对象，用不同的方法来修改_DISPATCHER_HEADER(SignalState)<br>比如：如果可等待对象是EVENT,其他线程通常使用SetEvent来设置SignalState = 1<br>并且，将正在等待该对象的其他线程唤醒，也就是从等待链表(KiWaitListHead)中摘出来。但是，SetEvent函数并不会将线程从等待网上摘下来，是否要下来，由当前线程自己来决定。   </p>
<h2 id="关于强制唤醒"><a href="#关于强制唤醒" class="headerlink" title="关于强制唤醒"></a>关于强制唤醒</h2><p>在APC专题中讲过，当我们插入一个用户APC时(Alertable=1)，当前线程是可以被唤醒的，但并不是真正的唤醒。因为，如果当前的线程在等待网上，执行完用户APC后，仍然要进入等待状态。</p>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>关于线程什么时候把自己变成等待的，就是通过线程自己操作的，线程在进入临界区之前会调用WaitForSingleObject或者WaitForMultipleObjects,去判断等待对象，信号量是否有信号，如果有修改信号量，退出函数退出循环，将自己+5C位置清零，释放内存，如果发现信号量为0，并且是第一次执行，将线程自己的等待块挂到此对象的等待列表里，创建线程关于这个等待对象的等待块将其挂到等待对象的链表中，如果线程切换再次获得CPU，当前线程便会在WaitForSingleObject或者WaitForMultipleObjects恢复执行(在哪切换在哪开始执行)从这里开始执行。<br>关于唤醒，总得来说就是其他唤醒线程把信号量激活（不同等待对象（比如Event）不同，唤醒函数不同，比如SetEvent），修改信号量，改为有信号，比如1，然后内核等待对象把所有等待他的线程（通过WaitListHead链找）从等待链表里摘掉，然后等待线程从当初挂起的地方开始执行，自己再次进入循环，判断能否被激活，比如还有没有等待其他对象，如果没有，当前线程便会在WaitForSingleObject或者WaitForMultipleObjects恢复执行(在哪切换在哪开始执行)，如果符合唤醒条件，自己把自己线程的5C清0，然后自己把自己从等待网里弄出去。这样就把自己激活了(此时会修改SignalState的值，并将自己从等待网上摘下来，此时的线程才是真正的唤醒，),如果有继续变非唤醒，重新把自己挂到等待列表上。      </p>
<h1 id="EVENT"><a href="#EVENT" class="headerlink" title="EVENT"></a>EVENT</h1><p>在之前的课程里面讲过，线程在进入临界区之前会调用WaitForSingleObject或者WaitForMultipleObjects,此时如果有信号，线程会从函数中退出并进入临界区，如果没有信号那么线程将自己挂入等待链表，然后将自己挂入等待网，最后切换线程。<br>其他线程在适当的时候，调用方法修改被等待对象的SignalState为有信号(不同的等待对象，会调用不同的函数)，并将等待该对象的其他线程从等待链表中摘掉，这样，当前线程便会在WaitForSingleObject（一次挂一到两个等待块）或者WaitForMultipleObjects（一次挂多个等待块）恢复执行(在哪切换在哪开始执行)，如果符合唤醒条件，此时会修改SignalState的值，并将自己从等待网上摘下来，此时的线程才是真正的唤醒。   </p>
<h2 id="被等待对象不同，主要在2个点上会有差异："><a href="#被等待对象不同，主要在2个点上会有差异：" class="headerlink" title="被等待对象不同，主要在2个点上会有差异："></a>被等待对象不同，主要在2个点上会有差异：</h2><ol>
<li>唤醒改信号的函数不同。  </li>
<li>当前线程被唤醒时候，判断激活条件不同。<br>通知类型对象不改SignalState值，所以通知类型都可以执行。  </li>
</ol>
<p>##<br>创建事件对象：信号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CreateEvent(NULL, </span><br><span class="line">TRUE, //当前对象类型，TRUE  通知类型对象</span><br><span class="line">                    //FALSE 事件同步对象</span><br><span class="line"></span><br><span class="line">FALSE//创建是是否有信号，就是SignalState初始值</span><br><span class="line">, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +0x000 Type</span><br><span class="line">   +0x001 Absolute</span><br><span class="line">   +0x002 Size</span><br><span class="line">   +0x003 Inserted</span><br><span class="line">   +0x004 SignalState</span><br><span class="line">   +0x008 WaitListHead</span><br><span class="line"></span><br><span class="line">(代码演示)</span><br></pre></td></tr></table></figure></p>
<h2 id="SetEvent函数分析"><a href="#SetEvent函数分析" class="headerlink" title="SetEvent函数分析"></a>SetEvent函数分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SetEvent对应的内核函数：KeSetEvent</span><br><span class="line"></span><br><span class="line">1) 修改信号值SignalState为1</span><br><span class="line"></span><br><span class="line">2) 判断对象类型</span><br><span class="line"></span><br><span class="line">3) 如果类型为通知类型对象(0)   唤醒所有等待该状态的线程</span><br><span class="line"></span><br><span class="line">4) 如果类型为事件同步对象(1)   从链表头找到第一个，找等待类型是WaitAny的。</span><br></pre></td></tr></table></figure>
<h1 id="SEMAPHORE"><a href="#SEMAPHORE" class="headerlink" title="SEMAPHORE"></a>SEMAPHORE</h1><p>上一节课我们讲到了事件(EVENT)对象，线程在进入临界区之前会通过调用WaitForSingleObject或者WaitForMultipleObjects来判断当前的事件对象是否有信号(SignalState&gt;0),只有当事件对象有信号时，才可以进入临界区(只允许一个线程进入直到退出的一段代码，不单指用EnterCriticalSection() 和 LeaveCriticalSection() 而形成的临界区)。<br>通过我们对EVENT对象相关函数的分析，我们发现，EVENT对象的SignalState值只有2种可能：<br>1  初始化时  或者调用  SetEvent<br>0  WaitForSingleObject、WaitForMultipleObjects、ResetEvent    </p>
<p>信号量跟事件最大差异，运行多个线程同时进入临界区   </p>
<h2 id="创建信号量对象"><a href="#创建信号量对象" class="headerlink" title="创建信号量对象"></a>创建信号量对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">(		</span></span></span><br><span class="line"><span class="function"><span class="params">		LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,	</span></span></span><br><span class="line"><span class="function"><span class="params">		LONG lInitialCount,		</span></span></span><br><span class="line"><span class="function"><span class="params">		LONG lMaximumCount,	<span class="comment">//赋值给Limit	</span></span></span></span><br><span class="line"><span class="function"><span class="params">		LPCTSTR lpName				</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">_KSEMAPHORE</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   +<span class="number">0x010</span> Limit            : Int4B	<span class="comment">//lMaximumCount</span></span><br><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +<span class="number">0x000</span> Type 			<span class="comment">//信号量类型为5</span></span><br><span class="line">   +<span class="number">0x001</span> Absolute </span><br><span class="line">   +<span class="number">0x002</span> Size</span><br><span class="line">   +<span class="number">0x003</span> Inserted</span><br><span class="line">   +<span class="number">0x004</span> SignalState		<span class="comment">//lInitialCount</span></span><br><span class="line">   +<span class="number">0x008</span> WaitListHead</span><br></pre></td></tr></table></figure>
<h2 id="ReleaseSemaphore函数分析"><a href="#ReleaseSemaphore函数分析" class="headerlink" title="ReleaseSemaphore函数分析"></a>ReleaseSemaphore函数分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">ReleaseSemaphore_3Ring--&gt;NtReleaseSemaphore</span><br><span class="line">NtReleaseSemaphore--&gt;KeReleaseSemaphore</span><br></pre></td></tr></table></figure>
<p>1) 设置SignalState = SignalState  + N(参数,释放几个)</p>
<p>2) 通过WaitListHead找到所有线程，并从等待链表中摘掉。</p>
<h2 id="MUTANT"><a href="#MUTANT" class="headerlink" title="MUTANT"></a>MUTANT</h2><h2 id="为什么要有互斥体：等待对象被遗弃"><a href="#为什么要有互斥体：等待对象被遗弃" class="headerlink" title="为什么要有互斥体：等待对象被遗弃"></a>为什么要有互斥体：等待对象被遗弃</h2><p>可以通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+0x010 MutantListEntry  : _LIST_ENTRY</span><br></pre></td></tr></table></figure></p>
<p>解决被遗弃。<br>互斥体(MUTANT)与事件(EVENT)和信号量(SEMAPHORE)一样，都可以用来进行线程的同步控制。<br>但需要指出的是，这几个对象都是内核对象，这就意味着，通过这些对象可以进行跨进程的线程同步控制,比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A进程中的X线程--&gt;等待对象Z</span><br><span class="line">B进程中的Y线程--&gt;等待对象Z</span><br></pre></td></tr></table></figure>
<p>极端情况：   </p>
<p>如果B进程的Y线程还没有来得及调用修改SignalState的函数(如SetEvent)<br>那么等待对象Z将被遗弃，这也就以为者X线程将永远等下去！</p>
<h2 id="为什么要有互斥体：重入"><a href="#为什么要有互斥体：重入" class="headerlink" title="为什么要有互斥体：重入"></a>为什么要有互斥体：重入</h2><p>如果使用互斥体，A对象多次进入临界区，下面代码就不会死锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject(A)</span><br><span class="line">	.....</span><br><span class="line">	WaitForMultipleObjects(A,B,C)</span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">SetEvent/ReleaseSemaphore</span><br><span class="line"></span><br><span class="line">死锁</span><br></pre></td></tr></table></figure>
<h2 id="MUTANT结构体介绍"><a href="#MUTANT结构体介绍" class="headerlink" title="MUTANT结构体介绍"></a>MUTANT结构体介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KMUTANT						</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER	</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY	</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar		</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br><span class="line"></span><br><span class="line">MutantListEntry：</span><br><span class="line">拥有互斥体线程(KTHREAD+0x010 MutantListHead)是个链表头 圈着所有互斥体</span><br><span class="line">OwnerThread：</span><br><span class="line">正在拥有互斥体的线程</span><br><span class="line">Abandoned：</span><br><span class="line">是否已经被放弃不用</span><br><span class="line">ApcDisable：</span><br><span class="line">是否禁用内核APC</span><br></pre></td></tr></table></figure>
<h3 id="为什么互斥体能重复进入临界区"><a href="#为什么互斥体能重复进入临界区" class="headerlink" title="为什么互斥体能重复进入临界区"></a>为什么互斥体能重复进入临界区</h3><p>因为互斥体有个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+0x018 OwnerThread      : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure></p>
<h2 id="CreateMutex函数Ring3"><a href="#CreateMutex函数Ring3" class="headerlink" title="CreateMutex函数Ring3"></a>CreateMutex函数Ring3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateMutex(</span><br><span class="line">LPSECURITY_ATTRIBUTE SlpMutexAttributes, // 指向安全属性的指针</span><br><span class="line">BOOL bInitialOwner, 	//初始化互斥对象的所有者，互斥体对象属于哪个线程。TRUE说明属于当前线程 </span><br><span class="line">LPCTSTR lpName 	// 指向互斥对象名的指针</span><br><span class="line">);</span><br><span class="line">CreateMutex-&gt;NtCreateMutant(内核函数) -&gt;    KeInitializeMutant(内核函数)</span><br><span class="line">初始化MUTANT结构体：</span><br><span class="line">	MUTANT.Header.Type=2;</span><br><span class="line">	MUTANT.Header.SignalState=bInitialOwner?0:1;</span><br><span class="line">	MUTANT.OwnerThread=当前线程 or NULL;</span><br><span class="line">	MUTANT.Abandoned=0;</span><br><span class="line">	MUTANT.ApcDisable=0;</span><br><span class="line">	</span><br><span class="line">	bInitialOwner==TRUE  将当前互斥体挂入到当前线程的互斥体链表</span><br><span class="line">	(KTHREAD+0x010 MutantListHead)</span><br></pre></td></tr></table></figure>
<p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/27.png" alt="27"></p>
<h2 id="如果信号量不为零或者互斥体属于当前线程都能进入临界区"><a href="#如果信号量不为零或者互斥体属于当前线程都能进入临界区" class="headerlink" title="如果信号量不为零或者互斥体属于当前线程都能进入临界区"></a>如果信号量不为零或者互斥体属于当前线程都能进入临界区</h2><p>ReleaseMutex函数<br>BOOL WINAPI ReleaseMutex(HANDLE hMutex);<br>调用时，会这么调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">ReleaseMutex--&gt;NtReleaseMutant</span><br><span class="line">NtReleaseMutant--&gt;KeReleaseMutant</span><br></pre></td></tr></table></figure></p>
<p>正常调用时：<br>MUTANT.Header.SignalState++;<br>如果SignalState=1 （因为每次进入临界区可以一直减）说明其他进程可用了  将该互斥体从线程链表中移除。    </p>
<h2 id="如何解决重入问题"><a href="#如何解决重入问题" class="headerlink" title="如何解决重入问题"></a>如何解决重入问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_KMUTANT						</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER	</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY	</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar		</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br><span class="line"></span><br><span class="line">OwnerThread：</span><br><span class="line">正在拥有互斥体的线程</span><br></pre></td></tr></table></figure>
<h2 id="如何解决等待对象被遗弃问题"><a href="#如何解决等待对象被遗弃问题" class="headerlink" title="如何解决等待对象被遗弃问题"></a>如何解决等待对象被遗弃问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_KMUTANT						</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER	</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY	</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar		</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br><span class="line"></span><br><span class="line">MutantListEntry：</span><br><span class="line">拥有互斥体线程(KTHREAD+0x010 MutantListHead)是个链表头 圈着所有互斥体</span><br><span class="line">Abandoned：</span><br><span class="line">是否已经被放弃不用</span><br></pre></td></tr></table></figure>
<p>当等待对象被遗弃，系统会调用函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">MmUnloadSystemImage--&gt;KeReleaseMutant_X,Y,Abandon,Z_</span><br></pre></td></tr></table></figure>
<p>MmUnloadSystemImage会将Abandon设置成1（初始是0）</p>
<p>那么被遗弃和正常释放最后都会调用KeReleaseMutant，区分方法就是参数Abandon。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(Abandon == false) //正常调用</span><br><span class="line">&#123;</span><br><span class="line">	MUTANT.Header.SignalState++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	MUTANT.Header.SignalState == 1;</span><br><span class="line">	MUTANT.OwnerThread == NULL;   	</span><br><span class="line">&#125;</span><br><span class="line">if(MUTANT.Header.SignalState==1)</span><br><span class="line">	MUTANT.OwnerThread == NULL;  </span><br><span class="line">	从当前线程互斥体链表中将当前互斥体移除</span><br><span class="line"></span><br><span class="line">(参见KeReleaseMutant函数)</span><br></pre></td></tr></table></figure>
<h2 id="禁用内核APC"><a href="#禁用内核APC" class="headerlink" title="禁用内核APC"></a>禁用内核APC</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KMUTANT						</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER	</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY	</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar		</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br><span class="line"></span><br><span class="line">ApcDisable：</span><br><span class="line">是否禁用内核APC</span><br><span class="line"></span><br><span class="line">Mutant     对应内核函数	NtCreateMutant   ApcDisable=0</span><br><span class="line">Mutex      对应内核函数	NtCreateMutex    ApcDisable=1，意思是被禁止</span><br><span class="line"></span><br><span class="line">(参见KeWaitForSingleObject函数)</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 滴水视频</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yangruiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/07/07/Windows等待唤醒机制/">http://yoursite.com/2018/07/07/Windows等待唤醒机制/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">manyouyou</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/事件和互斥体/">事件和互斥体</a><a class="post-meta__tags" href="/tags/事件等待机制/">事件等待机制</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/zhifubao.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/weixin.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/09/APC异步过程调用/"><i class="fa fa-chevron-left">  </i><span>APC异步过程调用</span></a></div><div class="next-post pull-right"><a href="/2018/07/06/Windows消息机制/"><span>Windows消息机制</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'yangruiqiyr',
  repo: 'BlogGitment',
  oauth: {
    client_id: 'dfbfacd2fb59427cee9e',
    client_secret: 'a39b872c7d6ddf551a16ebf9a3d59ce9b57508bb'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2018 By yangruiqi</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="www.yangruiqiyr.com">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.5"></script><script src="/js/fancybox.js?version=1.5.5"></script><script src="/js/sidebar.js?version=1.5.5"></script><script src="/js/copy.js?version=1.5.5"></script><script src="/js/fireworks.js?version=1.5.5"></script><script src="/js/transition.js?version=1.5.5"></script><script src="/js/scroll.js?version=1.5.5"></script><script src="/js/head.js?version=1.5.5"></script></body></html>