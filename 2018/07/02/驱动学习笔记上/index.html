<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="驱动学习笔记上"><meta name="keywords" content="驱动,MDL"><meta name="author" content="yangruiqi,undefined"><meta name="copyright" content="yangruiqi"><title>驱动学习笔记上 | manyouyou</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.5"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#如何调试驱动程序"><span class="toc-number">1.</span> <span class="toc-text">如何调试驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是PDB文件？"><span class="toc-number">1.1.</span> <span class="toc-text">什么是PDB文件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windbg如何找到pdb文件"><span class="toc-number">1.2.</span> <span class="toc-text">windbg如何找到pdb文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内核编程基础"><span class="toc-number">2.</span> <span class="toc-text">内核编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内核API的使用"><span class="toc-number">2.1.</span> <span class="toc-text">内核API的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未导出函数的使用"><span class="toc-number">2.2.</span> <span class="toc-text">未导出函数的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本数据类型"><span class="toc-number">2.3.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#返回值"><span class="toc-number">2.4.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核中的异常处理"><span class="toc-number">2.5.</span> <span class="toc-text">内核中的异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用的内核内存函数"><span class="toc-number">2.6.</span> <span class="toc-text">常用的内核内存函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核字符串种类"><span class="toc-number">2.7.</span> <span class="toc-text">内核字符串种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核字符串常用函数"><span class="toc-number">2.8.</span> <span class="toc-text">内核字符串常用函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内核空间与内核模块"><span class="toc-number">3.</span> <span class="toc-text">内核空间与内核模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DRIVER-OBJECT"><span class="toc-number">3.1.</span> <span class="toc-text">DRIVER_OBJECT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遍历内核模块"><span class="toc-number">3.2.</span> <span class="toc-text">遍历内核模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0环与3环通信-常规方式"><span class="toc-number">3.3.</span> <span class="toc-text">0环与3环通信(常规方式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设备对象"><span class="toc-number">3.4.</span> <span class="toc-text">设备对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建设备对象"><span class="toc-number">3.5.</span> <span class="toc-text">创建设备对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置交互数据的方式"><span class="toc-number">3.6.</span> <span class="toc-text">设置交互数据的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲区方式读写-DO-BUFFERED-IO"><span class="toc-number">3.6.1.</span> <span class="toc-text">缓冲区方式读写(DO_BUFFERED_IO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接方式读写-DO-DIRECT-IO"><span class="toc-number">3.6.2.</span> <span class="toc-text">直接方式读写(DO_DIRECT_IO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他方式读写-在调用IoCreateDevice创建设备后对pDevObj-gt-Flags即不设置DO-BUFFERED-IO也不设置DO-DIRECT-IO此时就是其他方式"><span class="toc-number">3.6.3.</span> <span class="toc-text">其他方式读写(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO也不设置DO_DIRECT_IO此时就是其他方式)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建符号链接"><span class="toc-number">3.7.</span> <span class="toc-text">创建符号链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IRP与派遣函数"><span class="toc-number">3.7.1.</span> <span class="toc-text">IRP与派遣函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IRP的类型"><span class="toc-number">3.8.</span> <span class="toc-text">IRP的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遣函数在哪里注册呢？"><span class="toc-number">3.9.</span> <span class="toc-text">遣函数在哪里注册呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注册派遣函数"><span class="toc-number">3.10.</span> <span class="toc-text">注册派遣函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#派遣函数的格式"><span class="toc-number">3.11.</span> <span class="toc-text">派遣函数的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通讯流程"><span class="toc-number">3.12.</span> <span class="toc-text">通讯流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数所占属性"><span class="toc-number">3.12.0.1.</span> <span class="toc-text">函数所占属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数返回值"><span class="toc-number">3.12.0.2.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IRQL"><span class="toc-number">3.12.0.3.</span> <span class="toc-text">IRQL</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SSDT-HOOK"><span class="toc-number">4.</span> <span class="toc-text">SSDT HOOK</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何访问系统服务表呢？"><span class="toc-number">4.1.</span> <span class="toc-text">如何访问系统服务表呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下面就是函数地址表"><span class="toc-number">4.2.</span> <span class="toc-text">下面就是函数地址表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下面就是函数参数个数表除四就是真正个数"><span class="toc-number">4.3.</span> <span class="toc-text">下面就是函数参数个数表除四就是真正个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何得到函数表地址"><span class="toc-number">4.4.</span> <span class="toc-text">如何得到函数表地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过页表基址修改页属性"><span class="toc-number">4.5.</span> <span class="toc-text">通过页表基址修改页属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过修改CR0寄存器（WP位置改成0）"><span class="toc-number">4.6.</span> <span class="toc-text">通过修改CR0寄存器（WP位置改成0）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Inline-Hook"><span class="toc-number">5.</span> <span class="toc-text">Inline Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#注意点"><span class="toc-number">5.1.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料："><span class="toc-number">6.</span> <span class="toc-text">参考资料：</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/%E5%A4%B4%E5%83%8F/touxiang.jpg"></div><div class="author-info__name text-center">yangruiqi</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/yangruiqiyr" target="_blank">跟随我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">相关网址</div><a class="author-info-links__name text-center" href="http://blog.topsec.com.cn/" target="_blank">天融信阿尔法实验室</a><a class="author-info-links__name text-center" href="https://www.baidu.com/" target="_blank">百度</a><a class="author-info-links__name text-center" href="https://bbs.pediy.com/" target="_blank">看雪</a><a class="author-info-links__name text-center" href="http://www.freebuf.com/" target="_blank">FreeBuf</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/主题/主题1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">manyouyou</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">档案</a><a class="site-page" href="/tags">标题</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">驱动学习笔记上</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/笔记-驱动笔记/">笔记 - 驱动笔记</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>驱动的开发流程：</p>
<p>编写代码，生成.sys文件，部署，启动，停止，卸载</p>
<h1 id="如何调试驱动程序"><a href="#如何调试驱动程序" class="headerlink" title="如何调试驱动程序"></a>如何调试驱动程序</h1><h2 id="什么是PDB文件？"><a href="#什么是PDB文件？" class="headerlink" title="什么是PDB文件？"></a>什么是PDB文件？</h2><ul>
<li>PDB文件是在我们编译工程的时候产生的，它是和对应的模块(exe或dll)一起生成出来的。   </li>
<li>每个模块编译的时候都可以生成自己的PDB文件。比如.exe/.dll/.sys等等。</li>
</ul>
<h2 id="windbg如何找到pdb文件"><a href="#windbg如何找到pdb文件" class="headerlink" title="windbg如何找到pdb文件"></a>windbg如何找到pdb文件</h2><ol>
<li><1> SRV<em>D:\Symbols\XP</em><a href="http://msdl.microsoft.com/download/symbols" target="_blank" rel="noopener">http://msdl.microsoft.com/download/symbols</a></1></li>
<li>kd&gt;.reload   </li>
</ol>
<h1 id="内核编程基础"><a href="#内核编程基础" class="headerlink" title="内核编程基础"></a>内核编程基础</h1><h2 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h2><ol>
<li>应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件&lt;windows.h&gt;就可以了，但是在内核编程的时候，我们不能像在Ring3那样直接使用。微软为内核程序提供了专用的API，只要在程序中包含相应的头文件就可以使用了，如：#include &lt;ntddk.h&gt; (假设你已经正确安装了WDK)   </li>
<li>在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档。   <h2 id="未导出函数的使用"><a href="#未导出函数的使用" class="headerlink" title="未导出函数的使用"></a>未导出函数的使用</h2>WDK说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。<br>如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：<br><1> 特征码搜索<br><2> 解析内核PDB文件   </2></1></li>
</ol>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol>
<li>在内核编程的时候，强烈建议大家遵守WDK的编码习惯,不要这样写：<br>  unsigned long length;    </li>
</ol>
<p>2.习惯使用WDK自己的类型<br>ULONG(unsigned long)<br>PULONG(unsigned long *)</p>
<p>UCHAR(unsigned char)<br>PUCHAR(unsigned char *)</p>
<p>UINT(unsigned int)<br>PUNIT(unsigned int *)    </p>
<p>VOID(void)<br>PVOID(void *)</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>大部分内核函数的返回值都是NTSTATUS类型（当成宏），如：<br>    NTSTATUS PsCreateSystemThread();<br>    NTSTATUS ZwOpenProcess();<br>    NTSTATUS ZwOpenEvent();<br> 这个值能说明函数执行的结果，比如：   </p>
<pre><code>STATUS_SUCCESS        0x00000000    成功        
STATUS_INVALID_PARAMETER    0xC000000D    参数无效    
STATUS_BUFFER_OVERFLOW    0x80000005    缓冲区长度不够    
</code></pre><p> 当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。   </p>
<h2 id="内核中的异常处理"><a href="#内核中的异常处理" class="headerlink" title="内核中的异常处理"></a>内核中的异常处理</h2><p>在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处。<br>Windows提供了结构化异常处理机制，一般的编译器都是支持的，如下：    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__try&#123;</span><br><span class="line">	<span class="comment">//可能出错的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except(filter_value) &#123;</span><br><span class="line">	<span class="comment">//出错时要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出现异常时，可根据filter_value的值来决定程序该如果执行，当filter_value的值为：   </p>
<ul>
<li>EXCEPTION_EXECUTE_HANDLER(1)，代码进入except块   </li>
<li>EXCEPTION_CONTINUE_SEARCH(0)，不处理异常，由上一层调用函数处理   </li>
<li>EXCEPTION_CONTINUE_EXECUTION(-1)，回去继续执行错误处的代码   </li>
</ul>
<h2 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h2><table>
<thead>
<tr>
<th>C语言</th>
<th>内核中</th>
</tr>
</thead>
<tbody>
<tr>
<td>malloc</td>
<td>ExAllocatePool（里面的第一个参数IN POOL_TYPE：非分页内存不会放到文件中，分页的就不一定了）</td>
</tr>
<tr>
<td>memset</td>
<td>RtlFillMemory</td>
</tr>
<tr>
<td>memcpy</td>
<td>RtlMoveMemory</td>
</tr>
<tr>
<td>free</td>
<td>ExFreePool</td>
</tr>
</tbody>
</table>
<h2 id="内核字符串种类"><a href="#内核字符串种类" class="headerlink" title="内核字符串种类"></a>内核字符串种类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CHAR(<span class="keyword">char</span>)/WCHAR(<span class="keyword">wchar_t</span>)/ANSI_STRING/UNICODE_STRING</span><br><span class="line"></span><br><span class="line">ANSI_STRING字符串：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line">UNICODE_STRING字符串：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaxmumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br></pre></td></tr></table></figure>
<h2 id="内核字符串常用函数"><a href="#内核字符串常用函数" class="headerlink" title="内核字符串常用函数"></a>内核字符串常用函数</h2><p>字符串常用的功能无非就是：<br>创建、复制、比较以及转换等等</p>
<table>
<thead>
<tr>
<th>ANSI_STRING字符串</th>
<th>UNICODE_STRING字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>RtlInitAnsiString</td>
<td>RtlInitUnicodeString</td>
</tr>
<tr>
<td>RtlCopyString</td>
<td>RtlCopyUnicodeString</td>
</tr>
<tr>
<td>RtlCompareString</td>
<td>RtlCompareUnicoodeString</td>
</tr>
<tr>
<td>RtlCompareUnicoodeString</td>
<td>RtlUnicodeStringToAnsiString</td>
</tr>
</tbody>
</table>
<h1 id="内核空间与内核模块"><a href="#内核空间与内核模块" class="headerlink" title="内核空间与内核模块"></a>内核空间与内核模块</h1><p>内核模块   </p>
<p><1> 硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员安装规定的格式编写“驱动程序” 。</1></p>
<p><2> 这些驱动程序每一个都是一个模块，称为“内核模块”，都可以加载到内核中，都遵守PE结构。但本质上讲，任意一个.sys文件与内核文件没有区别。</2></p>
<h2 id="DRIVER-OBJECT"><a href="#DRIVER-OBJECT" class="headerlink" title="DRIVER_OBJECT"></a>DRIVER_OBJECT</h2><p>每个内核模块都有一个对应的结构体，来描述这个模块在内核中的：位置、大小、名称等等。   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT<span class="comment">//驱动对象</span></span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void<span class="comment">//重要</span></span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B<span class="comment">//重要</span></span><br><span class="line">   +<span class="number">0x014</span> DriverSection    : Ptr32 Void<span class="comment">//是个指针</span></span><br><span class="line">   +<span class="number">0x018</span> DriverExtension  : Ptr32 _DRIVER_EXTENSION</span><br><span class="line">   +<span class="number">0x01c</span> DriverName       : _UNICODE_STRING<span class="comment">//重要</span></span><br><span class="line">   .....</span><br></pre></td></tr></table></figure>
<p>DeviceObject：这个参数是设备链，因为一个驱动对象可能有多个设备。   </p>
<p>可以用上面的DriverSection，这是个链表，找到其他所有的内核模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +0x000 InLoadOrderLinks : _LIST_ENTRY//后面的模块</span><br><span class="line">   +0x008 InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x010 InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x018 DllBase          : Ptr32 Void//这个模块从哪开始</span><br><span class="line">   +0x01c EntryPoint       : Ptr32 Void</span><br><span class="line">   +0x020 SizeOfImage      : Uint4B//模块多大</span><br><span class="line">   +0x024 FullDllName      : _UNICODE_STRING//完整的模块名</span><br><span class="line">   +0x02c BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +0x034 Flags            : Uint4B</span><br><span class="line">   +0x038 LoadCount        : Uint2B</span><br><span class="line">   +0x03a TlsIndex         : Uint2B</span><br><span class="line">   +0x03c HashLinks        : _LIST_ENTRY</span><br><span class="line">   +0x03c SectionPointer   : Ptr32 Void</span><br><span class="line">   +0x040 CheckSum         : Uint4B</span><br><span class="line">   +0x044 TimeDateStamp    : Uint4B</span><br><span class="line">   +0x044 LoadedImports    : Ptr32 Void</span><br><span class="line">   +0x048 EntryPointActivationContext : Ptr32 _ACTIVATION_CONTEXT</span><br><span class="line">   +0x04c PatchInformation : Ptr32 Void</span><br><span class="line">   +0x050 ForwarderLinks   : _LIST_ENTRY</span><br><span class="line">   +0x058 ServiceTagLinks  : _LIST_ENTRY</span><br><span class="line">   +0x060 StaticLinks      : _LIST_ENTRY</span><br><span class="line">   +0x068 ContextInformation : Ptr32 Void</span><br><span class="line">   +0x06c OriginalBase     : Uint4B</span><br><span class="line">   +0x070 LoadTime         : _LARGE_INTEGER</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历内核模块"><a href="#遍历内核模块" class="headerlink" title="遍历内核模块"></a>遍历内核模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt; dt _DRIVER_OBJECT  (地址)</span><br><span class="line">&lt;2&gt; dt _LDR_DATA_TABLE_ENTRY  (DriverSection)</span><br><span class="line">&lt;3&gt; dt _LDR_DATA_TABLE_ENTRY  (InLoadOrderLinks.Flink)</span><br><span class="line"></span><br><span class="line">kd&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +0x000 InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x008 InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x010 InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x018 DllBase          : Ptr32 Void</span><br><span class="line">   +0x01c EntryPoint       : Ptr32 Void</span><br><span class="line">   +0x020 SizeOfImage      : Uint4B</span><br><span class="line">   +0x024 FullDllName      : _UNICODE_STRING</span><br><span class="line">   +0x02c BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +0x034 Flags            : Uint4B</span><br><span class="line">   +0x038 LoadCount        : Uint2B</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure>
<h2 id="0环与3环通信-常规方式"><a href="#0环与3环通信-常规方式" class="headerlink" title="0环与3环通信(常规方式)"></a>0环与3环通信(常规方式)</h2><h2 id="设备对象"><a href="#设备对象" class="headerlink" title="设备对象"></a>设备对象</h2><p>我们在开发窗口程序的时候，消息被封装成一个结构体：MSG，在内核开发时，消息被封装成另外一个结构体：IRP(I/O Request Package)。<br>在窗口程序中，能够接收消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象。<br>3环是MSG，0环IRP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">MSG--&gt;窗口对象</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">IRP--&gt;设备对象</span><br></pre></td></tr></table></figure>
<h2 id="创建设备对象"><a href="#创建设备对象" class="headerlink" title="创建设备对象"></a>创建设备对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建设备名称</span></span><br><span class="line">UNICODE_STRING Devicename;</span><br><span class="line">RtlInitUnicodeString(&amp;Devicename,<span class="string">L"\\Device\\MyDevice"</span>);</span><br><span class="line">或者</span><br><span class="line">UNICODE_STRING Devicename=RTL_CONSTANT_STRING(<span class="string">L"\\Device\\MyDevice"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建设备</span></span><br><span class="line">IoCreateDevice(</span><br><span class="line">pDriver,				<span class="comment">//当前设备所属的驱动对象</span></span><br><span class="line"><span class="number">0</span>,                      <span class="comment">//设备扩展对象大小</span></span><br><span class="line">&amp;Devicename,			<span class="comment">//设备对象的名称</span></span><br><span class="line">FILE_DEVICE_UNKNOWN,    <span class="comment">//设备类型</span></span><br><span class="line">FILE_DEVICE_SECURE_OPEN,<span class="comment">//设备特征类型</span></span><br><span class="line">FALSE,                  <span class="comment">//设备是否是独占的</span></span><br><span class="line">&amp;pDeviceObj			<span class="comment">//设备对象指针</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="设置交互数据的方式"><a href="#设置交互数据的方式" class="headerlink" title="设置交互数据的方式"></a>设置交互数据的方式</h2><p>pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;   </p>
<h3 id="缓冲区方式读写-DO-BUFFERED-IO"><a href="#缓冲区方式读写-DO-BUFFERED-IO" class="headerlink" title="缓冲区方式读写(DO_BUFFERED_IO)"></a>缓冲区方式读写(DO_BUFFERED_IO)</h3><p>操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。相当于把3环数据复制到0环。   </p>
<h3 id="直接方式读写-DO-DIRECT-IO"><a href="#直接方式读写-DO-DIRECT-IO" class="headerlink" title="直接方式读写(DO_DIRECT_IO)"></a>直接方式读写(DO_DIRECT_IO)</h3><p>操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。   </p>
<h3 id="其他方式读写-在调用IoCreateDevice创建设备后对pDevObj-gt-Flags即不设置DO-BUFFERED-IO也不设置DO-DIRECT-IO此时就是其他方式"><a href="#其他方式读写-在调用IoCreateDevice创建设备后对pDevObj-gt-Flags即不设置DO-BUFFERED-IO也不设置DO-DIRECT-IO此时就是其他方式" class="headerlink" title="其他方式读写(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO也不设置DO_DIRECT_IO此时就是其他方式)"></a>其他方式读写(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO也不设置DO_DIRECT_IO此时就是其他方式)</h3><p>在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的。只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式。  </p>
<h2 id="创建符号链接"><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h2><p>上面的Devicename设备对象名是0环的，不是暴露给用户层的，三环是看不到的，所以想要使用就得“创建一个别名”，即使用符号链接。   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建符号链接名称</span></span><br><span class="line">RtlInitUnicodeString(&amp;SymbolicLinkName,<span class="string">L"\\??\\MyTestDriver"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">IoCreateSymbolicLink(&amp;SymbolicLinkName,&amp;Devicename);</span><br></pre></td></tr></table></figure>
<p>特别说明：</p>
<ol>
<li>设备名称的作用是给内核对象用的，如果要在Ring3访问，必须要有符号链接，其实就是一个别名，没有这个别名，在Ring3不可见。<br><del>2. 内核模式下，符号链接是以“\??\”开头的，如C 盘就是“\??\C:”</del>  </li>
<li><del>而在用户模式下，则是以“\.\”开头的，如C 盘就是“\.\C:（代码要转义所以一个\变2个\）</del>   </li>
<li>内核模式路径正常，用户模式使用内核，要\??\</li>
</ol>
<h3 id="IRP与派遣函数"><a href="#IRP与派遣函数" class="headerlink" title="IRP与派遣函数"></a>IRP与派遣函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">单击鼠标--&gt;MSG</span><br><span class="line">MSG--&gt;窗口对象</span><br><span class="line">窗口对象--&gt;单击回调</span><br><span class="line">窗口对象--&gt;双击回调</span><br><span class="line">窗口对象--&gt;其他</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">CreateFIle--&gt;IRP</span><br><span class="line">IRP--&gt;设备对象</span><br><span class="line">设备对象--&gt;派遣函数1</span><br><span class="line">设备对象--&gt;派遣函数2</span><br><span class="line">设备对象--&gt;其他</span><br></pre></td></tr></table></figure>
<h2 id="IRP的类型"><a href="#IRP的类型" class="headerlink" title="IRP的类型"></a>IRP的类型</h2><ol>
<li>当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数打开、从设备读取数据、向设备写入数据、关闭设备的时候，会使操作系统在0环产生出IRP_MJ_CREATE，IRP_MJ_READ，IRP_MJ_WRITE，IRP_MJ_CLOSE等不同的IRP。   </li>
<li>其他类型的IRP</li>
</ol>
<table>
<thead>
<tr>
<th>IRP类型</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>IRP_MJ_DEVICE_CONTROL</td>
<td>DeviceControl函数会产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_POWER</td>
<td>在操作系统处理电源消息时，产生次IRP</td>
</tr>
<tr>
<td>IRP_MJ_SHUTDOWN</td>
<td>关闭系统前会产生此IRP</td>
</tr>
</tbody>
</table>
<h2 id="遣函数在哪里注册呢？"><a href="#遣函数在哪里注册呢？" class="headerlink" title="遣函数在哪里注册呢？"></a>遣函数在哪里注册呢？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B</span><br><span class="line">....</span><br><span class="line">   +<span class="number">0x030</span> DriverStartIo    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x034</span> DriverUnload     : Ptr32     <span class="keyword">void</span> 		<span class="comment">//卸载函数</span></span><br><span class="line">   +<span class="number">0x038</span> MajorFunction    : [<span class="number">28</span>] Ptr32     <span class="keyword">long</span> 	<span class="comment">//派遣函数</span></span><br></pre></td></tr></table></figure>
<h2 id="注册派遣函数"><a href="#注册派遣函数" class="headerlink" title="注册派遣函数"></a>注册派遣函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">( 。。。。)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//设置卸载函数   </span></span><br><span class="line">    pDriverObject-&gt;DriverUnload = 卸载函数;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置派遣函数   </span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] 	= 派遣函数<span class="number">1</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] 	= 派遣函数<span class="number">2</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] 	= 派遣函数<span class="number">3</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_READ] 	= 派遣函数<span class="number">4</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] 	= 派遣函数<span class="number">5</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SET_INFORMATION] 	= 派遣函数<span class="number">6</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] 	= 派遣函数<span class="number">7</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SHUTDOWN] 		= 派遣函数<span class="number">8</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SYSTEM_CONTROL] 	= 派遣函数<span class="number">9</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">IRP_MJ_MAXIMUM_FUNCTION   派遣函数的最大值</span><br></pre></td></tr></table></figure>
<h2 id="派遣函数的格式"><a href="#派遣函数的格式" class="headerlink" title="派遣函数的格式"></a>派遣函数的格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//派遣函数的格式：</span><br><span class="line"></span><br><span class="line">NTSTATUS MyDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><br><span class="line">&#123;</span><br><span class="line">	//处理自己的业务...</span><br><span class="line"></span><br><span class="line">	//设置返回状态</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	//  getlasterror()得到的就是这个值</span><br><span class="line">	pIrp-&gt;IoStatus.Information = 0;		//  返回给3环多少数据 没有填0</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通讯流程"><a href="#通讯流程" class="headerlink" title="通讯流程"></a>通讯流程</h2><p>用户层与内核层通讯，首先要CreateFile打开设备（通讯资源），这是一个多功能的函数，可打开或创建以下对象，并返回可访问的句柄：控制台，通信资源，目录（只读打开），磁盘驱动器，文件，邮槽，管道。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(</span><br><span class="line">		L&quot;\\.\Hello&quot;,//打开设备的符号连接</span><br><span class="line">		FILE_ALL_ACCESS,</span><br><span class="line">		NULL,</span><br><span class="line">		NULL,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		NULL</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>
<p>然后通讯通过下面函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DeviceIoControl(</span><br><span class="line">    _In_ HANDLE hDevice,//设备句柄</span><br><span class="line">    _In_ DWORD dwIoControlCode,//操作码</span><br><span class="line">    _In_reads_bytes_opt_(nInBufferSize) LPVOID lpInBuffer,//</span><br><span class="line">    _In_ DWORD nInBufferSize,</span><br><span class="line">    _Out_writes_bytes_to_opt_(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,</span><br><span class="line">    _In_ DWORD nOutBufferSize,</span><br><span class="line">    _Out_opt_ LPDWORD lpBytesReturned,</span><br><span class="line">    _Inout_opt_ LPOVERLAPPED lpOverlapped</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    参数类型及说明</span><br><span class="line">hDevice Long，设备句柄</span><br><span class="line">dwIoControlCode Long，应用程序调用驱动程序的控制命令，就是IOCTL_XXX IOCTLs。</span><br><span class="line">lpInBuffer Any，应用程序传递给驱动程序的数据缓冲区地址。</span><br><span class="line">nInBufferSize Long，应用程序传递给驱动程序的数据缓冲区大小，字节数。</span><br><span class="line">lpOutBuffer Any，驱动程序返回给应用程序的数据缓冲区地址。</span><br><span class="line">nOutBufferSize Long，驱动程序返回给应用程序的数据缓冲区大小，字节数。</span><br><span class="line">lpBytesReturned Long，驱动程序实际返回给应用程序的数据字节数地址。</span><br><span class="line">lpOverlapped OVERLAPPED，这个结构用于重叠操作。针对同步操作，请用ByVal As Long传递零值</span><br></pre></td></tr></table></figure>
<p>用户层跟内核层通讯的方式，有通过读写方式进行通宵，即使用ReadFile，ControlFile与内核层通讯，在内核层通过IRP处理函数得到缓冲区。  （irp-&gt;AssociatedIrp.SystemBuffer）<br>或者通过控制码通讯，简单说就是给设备对象发送控制码<br>不能随便写，需要一个宏订制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span><br><span class="line">((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span><br><span class="line">)</span><br><span class="line">#define FILE_DEVICE_UNKNOWN             0x00000022</span><br><span class="line">#define METHOD_BUFFERED                 0</span><br><span class="line">#define METHOD_IN_DIRECT                1   //直接读取方式</span><br><span class="line">#define FILE_READ_DATA            ( 0x0001 )    // file &amp; pipe</span><br><span class="line">#define FILE_WRITE_DATA           ( 0x0002 )    // file &amp; pipe</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define CTL_CODE(DeviceType,Function,Method,Access)</span><br><span class="line">DeviceType:设备对象类型   </span><br><span class="line">Function：驱动IOCTL码</span><br><span class="line">0x000到0x7FF为微软保留</span><br><span class="line">0x800到0xFFF程序员定义</span><br><span class="line">Method：操作模式METHOD_BUFFERED，METHOD_IN_DIRECT,METHOD_NEITHER</span><br><span class="line">Access:访问权限一般是FILE_ANY_ACCESS</span><br></pre></td></tr></table></figure>
<h4 id="函数所占属性"><a href="#函数所占属性" class="headerlink" title="函数所占属性"></a>函数所占属性</h4><p>可以用#pragma alloc_text(类型，函数名)<br>指定函数占用内存的类型，有以下几种：<br>INIT，调用玩可释放<br>PAGE，位于分页内存<br>NONE_PAGE，位于非分页内存   </p>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>用一个宏检测是否成功 NT_SUCCESS</p>
<h4 id="IRQL"><a href="#IRQL" class="headerlink" title="IRQL"></a>IRQL</h4><p>保证内核安全，修改某个全局变量造成问题，提出中断请求级别概念（Interrupt ReQuest Level，IRQL）概念<br>DIspatch：所有运行在这个级别代码都是被进行原子操作，切不能访问分页内存，也就是说操作系统在一个世界只能运行一段Dispatch级的代码，且必须将其完全执行和才会发生线程切换<br>APC：比Dispatch低一个级别，可以访问分页内存<br>Passive：最低的优先级，大多数代码运行的级别   </p>
<h1 id="SSDT-HOOK"><a href="#SSDT-HOOK" class="headerlink" title="SSDT HOOK"></a>SSDT HOOK</h1><p>首先要明白SSDTHOOK就是自己再写一份函数，替换了SSDT表中的地址替换掉<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/qudong/1.png" alt="SystemServiceTable系统服务表"></p>
<h2 id="如何访问系统服务表呢？"><a href="#如何访问系统服务表呢？" class="headerlink" title="如何访问系统服务表呢？"></a>如何访问系统服务表呢？</h2><p>SSDT  的全称是 System Services Descriptor Table，系统服务描述符表</p>
<p>下面这个是个全局变量<br>kd&gt; dd  KeServiceDescriptorTable(SSDT)</p>
<p>这个导出的 声明一下就可以使用了</p>
<p>kd&gt; dd  KeServiceDescriptorTableShadow(SSDT Shadow)</p>
<p>这个未导出 需要用其他的方式来查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83fac9c0  83ec0d9c 00000000 00000191 83ec13e4</span><br><span class="line">83fac9d0  00000000 00000000 00000000 00000000</span><br><span class="line">83fac9e0  83f1f6af 00000000 025355a9 000000bb</span><br><span class="line">83fac9f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83faca00  83ec0d9c 00000000 00000191 83ec13e4</span><br><span class="line">83faca10  956d6000 00000000 00000339 956d702c</span><br><span class="line">83faca20  00000000 00000000 83faca24 00000340</span><br><span class="line">83faca30  00000340 865fab00 00000007 00000000</span><br></pre></td></tr></table></figure>
<p>其中83ec0d9c是函数地址，00000191是函数个数，83ec13e4是函数参数个数，单位是一个字节，除以4就是函数地址表上对应函数的个数，第一个函数对第一个个数。</p>
<h2 id="下面就是函数地址表"><a href="#下面就是函数地址表" class="headerlink" title="下面就是函数地址表"></a>下面就是函数地址表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd 83ec0d9c</span><br><span class="line">83ec0d9c  840bcc28 83f0340d 8404cb68 83e6788a</span><br><span class="line">83ec0dac  840be4ff 83f403fa 8412eb05 8412eb4e</span><br><span class="line">83ec0dbc  840413bd 84148368 841495c1 84037b95</span><br><span class="line">83ec0dcc  840c8b35 84121963 84074a56 840446cc</span><br><span class="line">83ec0ddc  83fda928 84113898 8402b14e 8406da62</span><br><span class="line">83ec0dec  840b9df1 8401b238 840b91fe 84038c0c</span><br><span class="line">83ec0dfc  840ca5bc 8403b28f 840ca39c 840c2afc</span><br><span class="line">83ec0e0c  8404d0f0 8410e657 840bfec9 840ca7ee</span><br><span class="line"></span><br><span class="line">根据这个定义一个结构体</span><br><span class="line">//下面这个是系统服务表的结构体</span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE  </span><br><span class="line">&#123;  </span><br><span class="line">    PULONG  ServiceTableBase;                               		// 服务函数地址表基址  </span><br><span class="line">    PULONG  ServiceCounterTableBase;                        	    </span><br><span class="line">    ULONG   NumberOfService;                                		// 服务函数的个数  </span><br><span class="line">    PULONG   ParamTableBase;                                		// 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure>
<h2 id="下面就是函数参数个数表除四就是真正个数"><a href="#下面就是函数参数个数表除四就是真正个数" class="headerlink" title="下面就是函数参数个数表除四就是真正个数"></a>下面就是函数参数个数表除四就是真正个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; db 83ec13e4</span><br><span class="line">83ec13e4  18 20 2c 2c 40 2c 40 44-0c 08 08 18 18 08 04 04  . ,,@,@D........</span><br><span class="line">83ec13f4  0c 0c 10 18 24 0c 2c 0c-18 10 0c 0c 0c 0c 0c 0c  ....$.,.........</span><br><span class="line">83ec1404  08 0c 18 18 14 18 0c 20-10 08 08 08 0c 08 0c 0c  ....... ........</span><br><span class="line">83ec1414  08 04 04 0c 08 08 08 08-0c 04 04 20 08 10 0c 20  ........... ... </span><br><span class="line">83ec1424  14 0c 2c 10 0c 0c 1c 10-20 20 10 38 10 14 10 20  ..,.....  .8... </span><br><span class="line">83ec1434  24 24 28 1c 1c 14 10 20-2c 10 34 28 18 2c 14 28  $$(.... ,.4(.,.(</span><br><span class="line">83ec1444  08 0c 08 04 04 04 04 04-0c 04 08 28 00 04 04 1c  ...........(....</span><br><span class="line">83ec1454  18 00 08 08 18 0c 14 18-08 18 0c 08 08 0c 04 00  ................</span><br></pre></td></tr></table></figure>
<h2 id="如何得到函数表地址"><a href="#如何得到函数表地址" class="headerlink" title="如何得到函数表地址"></a>如何得到函数表地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个就是SSDT的结构体，即系统服务描述表，里面就是多个系统服务表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    KSYSTEM_SERVICE_TABLE   ntoskrnl;                       <span class="comment">// ntoskrnl.exe 的服务函数  </span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   win32k;                         <span class="comment">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed1;  </span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed2;  </span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>//导出由 ntoskrnl（10-10-12）所导出的 SSDT<br>extern PKSERVICE_TABLE_DESCRIPTOR    KeServiceDescriptorTable;   </p>
<p>//这个是导出的，要到内核文件找，所以名字不能瞎起</p>
<p>下面的代码是查看到SSDT表地址的代码，可以打印显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">#include&lt;ntstatus.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">	PULONG  ServiceTableBase;                               		// 服务函数地址表基址  </span><br><span class="line">	PULONG  ServiceCounterTableBase;</span><br><span class="line">	ULONG   NumberOfService;                                		// 服务函数的个数  </span><br><span class="line">	PULONG   ParamTableBase;                                		// 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE   ntoskrnl;                       // ntoskrnl.exe 的服务函数  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   win32k;                         // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导出由 ntoskrnl所导出的 SSDT</span><br><span class="line">extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;//这个是导出的，要到内核文件找，所以名字不能瞎起</span><br><span class="line"></span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">	KdPrint((&quot;My Dirver is unloading...&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath) &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">	KdPrint((&quot;-&gt;%x \n&quot;, KeServiceDescriptorTable));</span><br><span class="line">	pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过页表基址修改页属性"><a href="#通过页表基址修改页属性" class="headerlink" title="通过页表基址修改页属性"></a>通过页表基址修改页属性</h2><p>SSDT所在的物理页是只读的，如果要修改，先要修改页属性为可写：</p>
<p>1、第一种办法，用我们学过的知识，通过页表基址直接修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if(RCR4 &amp; 0x00000020)</span><br><span class="line">&#123;//说明是2-9-9-12分页</span><br><span class="line">	KdPrint((&quot;2-9-9-12分页 %p\n&quot;,RCR4));</span><br><span class="line">	KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));</span><br><span class="line">	*(DWORD64*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8)) |= 0x02; </span><br><span class="line">	KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;//说明是10-10-12分页</span><br><span class="line">	KdPrint((&quot;10-10-12分页\n&quot;));</span><br><span class="line">	KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));</span><br><span class="line">	*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC)) |= 0x02;</span><br><span class="line">	KdPrint((&quot;PTE2 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过修改CR0寄存器（WP位置改成0）"><a href="#通过修改CR0寄存器（WP位置改成0）" class="headerlink" title="通过修改CR0寄存器（WP位置改成0）"></a>通过修改CR0寄存器（WP位置改成0）</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/qudong/2.png" alt="CR0寄存器">  </p>
<p>比如我们要SSDTHOOKNtOpenProcess，就要先通过IDA找到kernelBase的OpenProcess，在经过一系列查看最后在ntdll里找到ZWOpenProcess，所在位置看到了NtOpenProcess</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:77F05D88                 mov     eax, 0BEh       ; NtOpenProcess</span><br><span class="line">.text:77F05D8D                 mov     edx, 7FFE0300h</span><br><span class="line">.text:77F05D92                 call    dword ptr [edx]</span><br><span class="line">.text:77F05D94                 retn    10h</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83f789c0  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f789d0  00000000 00000000 00000000 00000000</span><br><span class="line">83f789e0  83eeb6af 00000000 025355a9 000000bb</span><br><span class="line">83f789f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83f78a00  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f78a10  95d46000 00000000 00000339 95d4702c</span><br><span class="line">83f78a20  00000000 00000000 83f78a24 00000340</span><br><span class="line">83f78a30  00000340 865fab00 00000007 00000000</span><br><span class="line">kd&gt; dd 83e8cd9c+4*BE</span><br><span class="line">83e8d094  840219dc 84073fff 84061b37 83f8d0c7</span><br><span class="line">83e8d0a4  84079674 83ff50c6 84096977 8405db6f</span><br><span class="line">83e8d0b4  8406dd87 840882e4 84061c4e 84119e0f</span><br><span class="line">83e8d0c4  841026f1 84103989 83ff3506 84050970</span><br><span class="line">83e8d0d4  841022a2 84101fc2 8410235a 8410207a</span><br><span class="line">83e8d0e4  8400693f 83fd5f60 83ff0a51 841040e4</span><br><span class="line">83e8d0f4  841041aa 84052403 840a35a7 840679a1</span><br><span class="line">83e8d104  84114a3e 84114e83 83ed2d34 84086b8c</span><br><span class="line">kd&gt; u 840219dc </span><br><span class="line">nt!NtOpenProcess:</span><br><span class="line">840219dc 8bff            mov     edi,edi</span><br><span class="line">840219de 55              push    ebp</span><br><span class="line">840219df 8bec            mov     ebp,esp</span><br><span class="line">840219e1 51              push    ecx</span><br><span class="line">840219e2 51              push    ecx</span><br><span class="line">840219e3 64a124010000    mov     eax,dword ptr fs:[00000124h]</span><br><span class="line">840219e9 8a803a010000    mov     al,byte ptr [eax+13Ah]</span><br><span class="line">840219ef 8b4d14          mov     ecx,dword ptr [ebp+14h]</span><br></pre></td></tr></table></figure>
<p>下面说一下通过MDL修改页属性。<br>就是 Memory Descriptor List，简称 MDL。有的同学可能会问了，MDL究竟是个什么东西呢？从字面意思看，不难理解，内存描述符列表。MDL包含了内存区域的起始、拥有者proc、字节数、标记等。OK，我们需要先定义一个MDL的指针。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">PMDL MDLSystemCall;</span><br></pre></td></tr></table></figure>
<p>定义了MDL的指针以后，我们要通过MAPPED系列的参数来使内存拥有可写性，然后锁定内存中的MDL，那么我们就要定义一个PVOID的指针，来供MmMap操作。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PVOID *MappedSCT;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MDLSystemCall = MmCreateMdl(</span><br><span class="line">NULL, //内存描述符列表</span><br><span class="line">KeServiceDescriptorTable.ServiceTableBase,//</span><br><span class="line">内存地址</span><br><span class="line">KeServiceDescriptorTable.NumberOfServices*4);//内存长度</span><br><span class="line">if(!MDLSystemCall)</span><br><span class="line">  return STATUS_UNSUCCESSFUL;</span><br></pre></td></tr></table></figure>
<p>建立了MDL，填充一下页数组   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MmBuildMdlForNonPagedPool(MDLSystemCall);//建立内存页的MDL描述   </span><br><span class="line">MDLSystemCall-&gt;MdlFlags = MDLSystemCall-&gt;MdlFlags | MDL_MAPPED_TO_SYSTEM_VA; //设置MDL标记为可写</span><br><span class="line">MappedSCT = MmMapLockedPages(MDLSystemCall, KernelMode);</span><br></pre></td></tr></table></figure>
<p>然后做自己的操作，比如这里的Hook</p>
<p>然后另外还有释放MDL的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(MDSystemCall)</span><br><span class="line">   &#123;</span><br><span class="line">      MmUnmapLockedPages(MappedSCT, MDSystemCall);</span><br><span class="line">      IoFreeMdl(MDSystemCall);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面是SSDT-Hook代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">#include&lt;ntstatus.h&gt;</span><br><span class="line">//1.找到系统服务表的函数地址表</span><br><span class="line">//定义一个全局变量用来存放之前的NtOpenProcess地址</span><br><span class="line">ULONG uOldNtOpenProcess;</span><br><span class="line">//有了地址还需要一个函数NtOpenProcess指针，用于调用原来的NtOpenProcess</span><br><span class="line"></span><br><span class="line">//定义修复和恢复页属性的函数</span><br><span class="line">PMDL MDSystemCall;</span><br><span class="line">PVOID *MappedSCT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef NTSTATUS(*NTOPENPROCESS)(</span><br><span class="line">	__out PHANDLE  ProcessHandle,</span><br><span class="line">	__in ACCESS_MASK  DesiredAccess,</span><br><span class="line">	__in POBJECT_ATTRIBUTES  ObjectAttributes,</span><br><span class="line">	__in_opt PCLIENT_ID  ClientId</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">	PULONG  ServiceTableBase;                               		// 服务函数地址表基址  </span><br><span class="line">	PULONG  ServiceCounterTableBase;</span><br><span class="line">	ULONG   NumberOfService;                                		// 服务函数的个数  </span><br><span class="line">	PULONG   ParamTableBase;                                		// 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE   ntoskrnl;                       // ntoskrnl.exe 的服务函数  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   win32k;                         // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导出由 ntoskrnl所导出的 SSDT</span><br><span class="line">extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;//这个是导出的，要到内核文件找，所以名字不能瞎起</span><br><span class="line"></span><br><span class="line">//准备用于替换的函数</span><br><span class="line">NTSTATUS NTAPI MyNtOpenProcess(__out PHANDLE  ProcessHandle,</span><br><span class="line">	__in ACCESS_MASK  DesiredAccess,</span><br><span class="line">	__in POBJECT_ATTRIBUTES  ObjectAttributes,</span><br><span class="line">	__in_opt PCLIENT_ID  ClientId</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	NTSTATUS Status;</span><br><span class="line">	Status = STATUS_SUCCESS;</span><br><span class="line">	//这里填自己的业务。。。各种过滤，修改返回结构等</span><br><span class="line">	KdPrint((&quot;MyNtOpenProcess %x %x %x %x \n&quot;, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId));</span><br><span class="line">	//后面这里填的是打开原来的函数，因为这个函数也要实现原来的功能，不然就乱套了，除非你自己在自己业务里实现了</span><br><span class="line">	return ((NTOPENPROCESS)uOldNtOpenProcess)(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PageProtectOff() &#123;</span><br><span class="line"></span><br><span class="line">	//MDSystemCall = MmCreateMdl(NULL, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase, KeServiceDescriptorTable-&gt;ntoskrnl.NumberOfService * 4);</span><br><span class="line">	//if (!MDSystemCall)</span><br><span class="line">	//	//return STATUS_UNSUCCESSFUL;</span><br><span class="line">	//	return;</span><br><span class="line">	//MmBuildMdlForNonPagedPool(MDSystemCall);</span><br><span class="line">	//MDSystemCall-&gt;MdlFlags = MDSystemCall-&gt;MdlFlags | MDL_MAPPED_TO_SYSTEM_VA;</span><br><span class="line">	//MappedSCT = MmMapLockedPages(MDSystemCall, KernelMode);</span><br><span class="line">	__asm &#123; //关闭内存保护</span><br><span class="line">		push eax;</span><br><span class="line">		mov eax, cr0;</span><br><span class="line">		and eax, ~0x10000;</span><br><span class="line">		mov cr0, eax;</span><br><span class="line">		pop eax;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PageProtectOn() &#123;</span><br><span class="line">	////解锁、释放MDL</span><br><span class="line">	//if (MDSystemCall)</span><br><span class="line">	//&#123;</span><br><span class="line">	//	MmUnmapLockedPages(MappedSCT, MDSystemCall);</span><br><span class="line">	//	IoFreeMdl(MDSystemCall);</span><br><span class="line">	//&#125;</span><br><span class="line">	__asm &#123; //恢复内存保护</span><br><span class="line">		push eax;</span><br><span class="line">		mov eax, cr0;</span><br><span class="line">		or eax, 0x10000;</span><br><span class="line">		mov cr0, eax;</span><br><span class="line">		pop eax;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//3.修改函数地址,准备个函数用来修改函数地址</span><br><span class="line">void HookNtOpenProcess() &#123;</span><br><span class="line">	NTSTATUS Status;</span><br><span class="line">	Status = STATUS_SUCCESS;</span><br><span class="line">	PageProtectOff();</span><br><span class="line">	uOldNtOpenProcess = KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE];</span><br><span class="line">	KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE] = (ULONG)MyNtOpenProcess;</span><br><span class="line">	PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line">//4.恢复</span><br><span class="line">void UnHookNtOpenProcess() &#123;</span><br><span class="line">	PageProtectOff();</span><br><span class="line">	KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE] = (ULONG)uOldNtOpenProcess;</span><br><span class="line">	PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">	UnHookNtOpenProcess();</span><br><span class="line"></span><br><span class="line">	KdPrint((&quot;My Dirver is unloading...&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath) &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">	KdPrint((&quot;-&gt;%x \n&quot;, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE]));//得到函数地址表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	HookNtOpenProcess();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h1><p>jmp 到没用的地方<br>pushad,pushfd,<br>做自己的事<br>popfd,popad.<br>加上被覆盖的代码<br>jmp 到被覆盖代码的下一行   </p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>位置的选择：</p>
<p><1> JMP/CALL指令至少占用5个字节</1></p>
<p><2> 绕开全局变量，因为全局变量的硬编码会随着指令变</2></p>
<p><3> 根据业务来决定在哪里HOOK：过滤参数？修改返回结果？</3></p>
<p>inline hook本质是改硬编码，改成<br>E9 +Code<br>Code = 要跳转的地址 - 补丁地址 - 5</p>
<p>比如从4183D7调到418221code就是285，采用小端存储就是<br>85 02 00 00</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：滴水视频</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yangruiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/07/02/驱动学习笔记上/">http://yoursite.com/2018/07/02/驱动学习笔记上/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">manyouyou</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/驱动/">驱动</a><a class="post-meta__tags" href="/tags/MDL/">MDL</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/zhifubao.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/weixin.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/02/驱动学习笔记下/"><i class="fa fa-chevron-left">  </i><span>驱动学习笔记下</span></a></div><div class="next-post pull-right"><a href="/2018/07/01/SSDT-Hook和MDL/"><span>SSDT—Hook和MDL</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'yangruiqiyr',
  repo: 'BlogGitment',
  oauth: {
    client_id: 'dfbfacd2fb59427cee9e',
    client_secret: 'a39b872c7d6ddf551a16ebf9a3d59ce9b57508bb'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2018 By yangruiqi</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="www.yangruiqiyr.com">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.5"></script><script src="/js/fancybox.js?version=1.5.5"></script><script src="/js/sidebar.js?version=1.5.5"></script><script src="/js/copy.js?version=1.5.5"></script><script src="/js/fireworks.js?version=1.5.5"></script><script src="/js/transition.js?version=1.5.5"></script><script src="/js/scroll.js?version=1.5.5"></script><script src="/js/head.js?version=1.5.5"></script></body></html>