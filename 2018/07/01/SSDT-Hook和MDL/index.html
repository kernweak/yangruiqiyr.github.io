<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="SSDT—Hook和MDL"><meta name="keywords" content="内核学习,SSDT—Hook"><meta name="author" content="yangruiqi,undefined"><meta name="copyright" content="yangruiqi"><title>SSDT—Hook和MDL | manyouyou</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.5"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SSDT-HOOK"><span class="toc-number">1.</span> <span class="toc-text">SSDT HOOK</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何访问系统服务表呢？"><span class="toc-number">1.1.</span> <span class="toc-text">如何访问系统服务表呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下面就是函数地址表"><span class="toc-number">1.2.</span> <span class="toc-text">下面就是函数地址表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下面就是函数参数个数表除四就是真正个数"><span class="toc-number">1.3.</span> <span class="toc-text">下面就是函数参数个数表除四就是真正个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何得到函数表地址"><span class="toc-number">1.4.</span> <span class="toc-text">如何得到函数表地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过页表基址修改页属性"><span class="toc-number">1.5.</span> <span class="toc-text">通过页表基址修改页属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过修改CR0寄存器（WP位置改成0）"><span class="toc-number">1.6.</span> <span class="toc-text">通过修改CR0寄存器（WP位置改成0）</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/%E5%A4%B4%E5%83%8F/touxiang.jpg"></div><div class="author-info__name text-center">yangruiqi</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/yangruiqiyr" target="_blank">跟随我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">相关网址</div><a class="author-info-links__name text-center" href="https://www.baidu.com/" target="_blank">百度</a><a class="author-info-links__name text-center" href="https://bbs.pediy.com/" target="_blank">看雪</a><a class="author-info-links__name text-center" href="http://www.freebuf.com/" target="_blank">FreeBuf</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/主题/主题1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">manyouyou</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">档案</a><a class="site-page" href="/tags">标题</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">SSDT—Hook和MDL</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/笔记-Hook笔记/">笔记 - Hook笔记</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="SSDT-HOOK"><a href="#SSDT-HOOK" class="headerlink" title="SSDT HOOK"></a>SSDT HOOK</h1><p>首先要明白SSDTHOOK就是自己再写一份函数，替换了SSDT表中的地址替换掉<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/qudong/1.png" alt="SystemServiceTable系统服务表"></p>
<h2 id="如何访问系统服务表呢？"><a href="#如何访问系统服务表呢？" class="headerlink" title="如何访问系统服务表呢？"></a>如何访问系统服务表呢？</h2><p>SSDT  的全称是 System Services Descriptor Table，系统服务描述符表</p>
<p>下面这个是个全局变量<br>kd&gt; dd  KeServiceDescriptorTable(SSDT)</p>
<p>这个导出的 声明一下就可以使用了</p>
<p>kd&gt; dd  KeServiceDescriptorTableShadow(SSDT Shadow)</p>
<p>这个未导出 需要用其他的方式来查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83fac9c0  83ec0d9c 00000000 00000191 83ec13e4</span><br><span class="line">83fac9d0  00000000 00000000 00000000 00000000</span><br><span class="line">83fac9e0  83f1f6af 00000000 025355a9 000000bb</span><br><span class="line">83fac9f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83faca00  83ec0d9c 00000000 00000191 83ec13e4</span><br><span class="line">83faca10  956d6000 00000000 00000339 956d702c</span><br><span class="line">83faca20  00000000 00000000 83faca24 00000340</span><br><span class="line">83faca30  00000340 865fab00 00000007 00000000</span><br></pre></td></tr></table></figure>
<p>其中83ec0d9c是函数地址，00000191是函数个数，83ec13e4是函数参数个数，单位是一个字节，除以4就是函数地址表上对应函数的个数，第一个函数对第一个个数。</p>
<h2 id="下面就是函数地址表"><a href="#下面就是函数地址表" class="headerlink" title="下面就是函数地址表"></a>下面就是函数地址表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd 83ec0d9c</span><br><span class="line">83ec0d9c  840bcc28 83f0340d 8404cb68 83e6788a</span><br><span class="line">83ec0dac  840be4ff 83f403fa 8412eb05 8412eb4e</span><br><span class="line">83ec0dbc  840413bd 84148368 841495c1 84037b95</span><br><span class="line">83ec0dcc  840c8b35 84121963 84074a56 840446cc</span><br><span class="line">83ec0ddc  83fda928 84113898 8402b14e 8406da62</span><br><span class="line">83ec0dec  840b9df1 8401b238 840b91fe 84038c0c</span><br><span class="line">83ec0dfc  840ca5bc 8403b28f 840ca39c 840c2afc</span><br><span class="line">83ec0e0c  8404d0f0 8410e657 840bfec9 840ca7ee</span><br><span class="line"></span><br><span class="line">根据这个定义一个结构体</span><br><span class="line">//下面这个是系统服务表的结构体</span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE  </span><br><span class="line">&#123;  </span><br><span class="line">    PULONG  ServiceTableBase;                               		// 服务函数地址表基址  </span><br><span class="line">    PULONG  ServiceCounterTableBase;                        	    </span><br><span class="line">    ULONG   NumberOfService;                                		// 服务函数的个数  </span><br><span class="line">    PULONG   ParamTableBase;                                		// 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure>
<h2 id="下面就是函数参数个数表除四就是真正个数"><a href="#下面就是函数参数个数表除四就是真正个数" class="headerlink" title="下面就是函数参数个数表除四就是真正个数"></a>下面就是函数参数个数表除四就是真正个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; db 83ec13e4</span><br><span class="line">83ec13e4  18 20 2c 2c 40 2c 40 44-0c 08 08 18 18 08 04 04  . ,,@,@D........</span><br><span class="line">83ec13f4  0c 0c 10 18 24 0c 2c 0c-18 10 0c 0c 0c 0c 0c 0c  ....$.,.........</span><br><span class="line">83ec1404  08 0c 18 18 14 18 0c 20-10 08 08 08 0c 08 0c 0c  ....... ........</span><br><span class="line">83ec1414  08 04 04 0c 08 08 08 08-0c 04 04 20 08 10 0c 20  ........... ... </span><br><span class="line">83ec1424  14 0c 2c 10 0c 0c 1c 10-20 20 10 38 10 14 10 20  ..,.....  .8... </span><br><span class="line">83ec1434  24 24 28 1c 1c 14 10 20-2c 10 34 28 18 2c 14 28  $$(.... ,.4(.,.(</span><br><span class="line">83ec1444  08 0c 08 04 04 04 04 04-0c 04 08 28 00 04 04 1c  ...........(....</span><br><span class="line">83ec1454  18 00 08 08 18 0c 14 18-08 18 0c 08 08 0c 04 00  ................</span><br></pre></td></tr></table></figure>
<h2 id="如何得到函数表地址"><a href="#如何得到函数表地址" class="headerlink" title="如何得到函数表地址"></a>如何得到函数表地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个就是SSDT的结构体，即系统服务描述表，里面就是多个系统服务表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    KSYSTEM_SERVICE_TABLE   ntoskrnl;                       <span class="comment">// ntoskrnl.exe 的服务函数  </span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   win32k;                         <span class="comment">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed1;  </span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed2;  </span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>//导出由 ntoskrnl（10-10-12）所导出的 SSDT<br>extern PKSERVICE_TABLE_DESCRIPTOR    KeServiceDescriptorTable;   </p>
<p>//这个是导出的，要到内核文件找，所以名字不能瞎起</p>
<p>下面的代码是查看到SSDT表地址的代码，可以打印显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">#include&lt;ntstatus.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">	PULONG  ServiceTableBase;                               		// 服务函数地址表基址  </span><br><span class="line">	PULONG  ServiceCounterTableBase;</span><br><span class="line">	ULONG   NumberOfService;                                		// 服务函数的个数  </span><br><span class="line">	PULONG   ParamTableBase;                                		// 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE   ntoskrnl;                       // ntoskrnl.exe 的服务函数  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   win32k;                         // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导出由 ntoskrnl所导出的 SSDT</span><br><span class="line">extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;//这个是导出的，要到内核文件找，所以名字不能瞎起</span><br><span class="line"></span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">	KdPrint((&quot;My Dirver is unloading...&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath) &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">	KdPrint((&quot;-&gt;%x \n&quot;, KeServiceDescriptorTable));</span><br><span class="line">	pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过页表基址修改页属性"><a href="#通过页表基址修改页属性" class="headerlink" title="通过页表基址修改页属性"></a>通过页表基址修改页属性</h2><p>SSDT所在的物理页是只读的，如果要修改，先要修改页属性为可写：</p>
<p>1、第一种办法，用我们学过的知识，通过页表基址直接修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if(RCR4 &amp; 0x00000020)</span><br><span class="line">&#123;//说明是2-9-9-12分页</span><br><span class="line">	KdPrint((&quot;2-9-9-12分页 %p\n&quot;,RCR4));</span><br><span class="line">	KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));</span><br><span class="line">	*(DWORD64*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8)) |= 0x02; </span><br><span class="line">	KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;//说明是10-10-12分页</span><br><span class="line">	KdPrint((&quot;10-10-12分页\n&quot;));</span><br><span class="line">	KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));</span><br><span class="line">	*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC)) |= 0x02;</span><br><span class="line">	KdPrint((&quot;PTE2 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过修改CR0寄存器（WP位置改成0）"><a href="#通过修改CR0寄存器（WP位置改成0）" class="headerlink" title="通过修改CR0寄存器（WP位置改成0）"></a>通过修改CR0寄存器（WP位置改成0）</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/qudong/2.png" alt="CR0寄存器">  </p>
<p>比如我们要SSDTHOOKNtOpenProcess，就要先通过IDA找到kernelBase的OpenProcess，在经过一系列查看最后在ntdll里找到ZWOpenProcess，所在位置看到了NtOpenProcess</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:77F05D88                 mov     eax, 0BEh       ; NtOpenProcess</span><br><span class="line">.text:77F05D8D                 mov     edx, 7FFE0300h</span><br><span class="line">.text:77F05D92                 call    dword ptr [edx]</span><br><span class="line">.text:77F05D94                 retn    10h</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83f789c0  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f789d0  00000000 00000000 00000000 00000000</span><br><span class="line">83f789e0  83eeb6af 00000000 025355a9 000000bb</span><br><span class="line">83f789f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83f78a00  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f78a10  95d46000 00000000 00000339 95d4702c</span><br><span class="line">83f78a20  00000000 00000000 83f78a24 00000340</span><br><span class="line">83f78a30  00000340 865fab00 00000007 00000000</span><br><span class="line">kd&gt; dd 83e8cd9c+4*BE</span><br><span class="line">83e8d094  840219dc 84073fff 84061b37 83f8d0c7</span><br><span class="line">83e8d0a4  84079674 83ff50c6 84096977 8405db6f</span><br><span class="line">83e8d0b4  8406dd87 840882e4 84061c4e 84119e0f</span><br><span class="line">83e8d0c4  841026f1 84103989 83ff3506 84050970</span><br><span class="line">83e8d0d4  841022a2 84101fc2 8410235a 8410207a</span><br><span class="line">83e8d0e4  8400693f 83fd5f60 83ff0a51 841040e4</span><br><span class="line">83e8d0f4  841041aa 84052403 840a35a7 840679a1</span><br><span class="line">83e8d104  84114a3e 84114e83 83ed2d34 84086b8c</span><br><span class="line">kd&gt; u 840219dc </span><br><span class="line">nt!NtOpenProcess:</span><br><span class="line">840219dc 8bff            mov     edi,edi</span><br><span class="line">840219de 55              push    ebp</span><br><span class="line">840219df 8bec            mov     ebp,esp</span><br><span class="line">840219e1 51              push    ecx</span><br><span class="line">840219e2 51              push    ecx</span><br><span class="line">840219e3 64a124010000    mov     eax,dword ptr fs:[00000124h]</span><br><span class="line">840219e9 8a803a010000    mov     al,byte ptr [eax+13Ah]</span><br><span class="line">840219ef 8b4d14          mov     ecx,dword ptr [ebp+14h]</span><br></pre></td></tr></table></figure>
<p>下面说一下通过MDL修改页属性。<br>就是 Memory Descriptor List，简称 MDL。有的同学可能会问了，MDL究竟是个什么东西呢？从字面意思看，不难理解，内存描述符列表。MDL包含了内存区域的起始、拥有者proc、字节数、标记等。OK，我们需要先定义一个MDL的指针。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">PMDL MDLSystemCall;</span><br></pre></td></tr></table></figure>
<p>定义了MDL的指针以后，我们要通过MAPPED系列的参数来使内存拥有可写性，然后锁定内存中的MDL，那么我们就要定义一个PVOID的指针，来供MmMap操作。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PVOID *MappedSCT;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MDLSystemCall = MmCreateMdl(</span><br><span class="line">NULL, //内存描述符列表</span><br><span class="line">KeServiceDescriptorTable.ServiceTableBase,//</span><br><span class="line">内存地址</span><br><span class="line">KeServiceDescriptorTable.NumberOfServices*4);//内存长度</span><br><span class="line">if(!MDLSystemCall)</span><br><span class="line">  return STATUS_UNSUCCESSFUL;</span><br></pre></td></tr></table></figure>
<p>建立了MDL，填充一下页数组   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MmBuildMdlForNonPagedPool(MDLSystemCall);//建立内存页的MDL描述   </span><br><span class="line">MDLSystemCall-&gt;MdlFlags = MDLSystemCall-&gt;MdlFlags | MDL_MAPPED_TO_SYSTEM_VA; //设置MDL标记为可写</span><br><span class="line">MappedSCT = MmMapLockedPages(MDLSystemCall, KernelMode);</span><br></pre></td></tr></table></figure>
<p>然后做自己的操作，比如这里的Hook</p>
<p>然后另外还有释放MDL的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(MDSystemCall)</span><br><span class="line">   &#123;</span><br><span class="line">      MmUnmapLockedPages(MappedSCT, MDSystemCall);</span><br><span class="line">      IoFreeMdl(MDSystemCall);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面是SSDT-Hook代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">#include&lt;ntstatus.h&gt;</span><br><span class="line">//1.找到系统服务表的函数地址表</span><br><span class="line">//定义一个全局变量用来存放之前的NtOpenProcess地址</span><br><span class="line">ULONG uOldNtOpenProcess;</span><br><span class="line">//有了地址还需要一个函数NtOpenProcess指针，用于调用原来的NtOpenProcess</span><br><span class="line"></span><br><span class="line">//定义修复和恢复页属性的函数</span><br><span class="line">PMDL MDSystemCall;</span><br><span class="line">PVOID *MappedSCT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef NTSTATUS(*NTOPENPROCESS)(</span><br><span class="line">	__out PHANDLE  ProcessHandle,</span><br><span class="line">	__in ACCESS_MASK  DesiredAccess,</span><br><span class="line">	__in POBJECT_ATTRIBUTES  ObjectAttributes,</span><br><span class="line">	__in_opt PCLIENT_ID  ClientId</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">	PULONG  ServiceTableBase;                               		// 服务函数地址表基址  </span><br><span class="line">	PULONG  ServiceCounterTableBase;</span><br><span class="line">	ULONG   NumberOfService;                                		// 服务函数的个数  </span><br><span class="line">	PULONG   ParamTableBase;                                		// 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE   ntoskrnl;                       // ntoskrnl.exe 的服务函数  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   win32k;                         // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导出由 ntoskrnl所导出的 SSDT</span><br><span class="line">extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;//这个是导出的，要到内核文件找，所以名字不能瞎起</span><br><span class="line"></span><br><span class="line">//准备用于替换的函数</span><br><span class="line">NTSTATUS NTAPI MyNtOpenProcess(__out PHANDLE  ProcessHandle,</span><br><span class="line">	__in ACCESS_MASK  DesiredAccess,</span><br><span class="line">	__in POBJECT_ATTRIBUTES  ObjectAttributes,</span><br><span class="line">	__in_opt PCLIENT_ID  ClientId</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	NTSTATUS Status;</span><br><span class="line">	Status = STATUS_SUCCESS;</span><br><span class="line">	//这里填自己的业务。。。各种过滤，修改返回结构等</span><br><span class="line">	KdPrint((&quot;MyNtOpenProcess %x %x %x %x \n&quot;, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId));</span><br><span class="line">	//后面这里填的是打开原来的函数，因为这个函数也要实现原来的功能，不然就乱套了，除非你自己在自己业务里实现了</span><br><span class="line">	return ((NTOPENPROCESS)uOldNtOpenProcess)(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PageProtectOff() &#123;</span><br><span class="line"></span><br><span class="line">	//MDSystemCall = MmCreateMdl(NULL, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase, KeServiceDescriptorTable-&gt;ntoskrnl.NumberOfService * 4);</span><br><span class="line">	//if (!MDSystemCall)</span><br><span class="line">	//	//return STATUS_UNSUCCESSFUL;</span><br><span class="line">	//	return;</span><br><span class="line">	//MmBuildMdlForNonPagedPool(MDSystemCall);</span><br><span class="line">	//MDSystemCall-&gt;MdlFlags = MDSystemCall-&gt;MdlFlags | MDL_MAPPED_TO_SYSTEM_VA;</span><br><span class="line">	//MappedSCT = MmMapLockedPages(MDSystemCall, KernelMode);</span><br><span class="line">	__asm &#123; //关闭内存保护</span><br><span class="line">		push eax;</span><br><span class="line">		mov eax, cr0;</span><br><span class="line">		and eax, ~0x10000;</span><br><span class="line">		mov cr0, eax;</span><br><span class="line">		pop eax;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PageProtectOn() &#123;</span><br><span class="line">	////解锁、释放MDL</span><br><span class="line">	//if (MDSystemCall)</span><br><span class="line">	//&#123;</span><br><span class="line">	//	MmUnmapLockedPages(MappedSCT, MDSystemCall);</span><br><span class="line">	//	IoFreeMdl(MDSystemCall);</span><br><span class="line">	//&#125;</span><br><span class="line">	__asm &#123; //恢复内存保护</span><br><span class="line">		push eax;</span><br><span class="line">		mov eax, cr0;</span><br><span class="line">		or eax, 0x10000;</span><br><span class="line">		mov cr0, eax;</span><br><span class="line">		pop eax;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//3.修改函数地址,准备个函数用来修改函数地址</span><br><span class="line">void HookNtOpenProcess() &#123;</span><br><span class="line">	NTSTATUS Status;</span><br><span class="line">	Status = STATUS_SUCCESS;</span><br><span class="line">	PageProtectOff();</span><br><span class="line">	uOldNtOpenProcess = KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE];</span><br><span class="line">	KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE] = (ULONG)MyNtOpenProcess;</span><br><span class="line">	PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line">//4.恢复</span><br><span class="line">void UnHookNtOpenProcess() &#123;</span><br><span class="line">	PageProtectOff();</span><br><span class="line">	KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE] = (ULONG)uOldNtOpenProcess;</span><br><span class="line">	PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">	UnHookNtOpenProcess();</span><br><span class="line"></span><br><span class="line">	KdPrint((&quot;My Dirver is unloading...&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath) &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">	KdPrint((&quot;-&gt;%x \n&quot;, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE]));//得到函数地址表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	HookNtOpenProcess();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后操作时可以用PChunt观察HOOk前后这个函数地址变化</p>
<p>这是hook前<img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E9%A9%B1%E5%8A%A8/3.png?x-oss-process=style/yangruiqi.com" alt="image"></p>
<p>这是Hook后<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E9%A9%B1%E5%8A%A8/4.png?x-oss-process=style/yangruiqi.com" alt="image"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yangruiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/07/01/SSDT-Hook和MDL/">http://yoursite.com/2018/07/01/SSDT-Hook和MDL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">manyouyou</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/内核学习/">内核学习</a><a class="post-meta__tags" href="/tags/SSDT—Hook/">SSDT—Hook</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/zhifubao.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/收款码/weixin.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/02/驱动学习笔记上/"><i class="fa fa-chevron-left">  </i><span>驱动学习笔记上</span></a></div><div class="next-post pull-right"><a href="/2018/06/30/通过进程挂靠实现改其它进程的数据/"><span>通过进程挂靠实现改其它进程的数据</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'yangruiqiyr',
  repo: 'BlogGitment',
  oauth: {
    client_id: 'dfbfacd2fb59427cee9e',
    client_secret: 'a39b872c7d6ddf551a16ebf9a3d59ce9b57508bb'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2018 By yangruiqi</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="www.yangruiqiyr.com">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.5"></script><script src="/js/fancybox.js?version=1.5.5"></script><script src="/js/sidebar.js?version=1.5.5"></script><script src="/js/copy.js?version=1.5.5"></script><script src="/js/fireworks.js?version=1.5.5"></script><script src="/js/transition.js?version=1.5.5"></script><script src="/js/scroll.js?version=1.5.5"></script><script src="/js/head.js?version=1.5.5"></script></body></html>