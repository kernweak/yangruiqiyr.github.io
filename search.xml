<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>通过进程挂靠实现改其它进程的数据</title>
      <link href="/2018/06/30/%E9%80%9A%E8%BF%87%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E5%AE%9E%E7%8E%B0%E6%94%B9%E5%85%B6%E5%AE%83%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/06/30/%E9%80%9A%E8%BF%87%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E5%AE%9E%E7%8E%B0%E6%94%B9%E5%85%B6%E5%AE%83%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>0环下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntifs.h&gt;</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver);</span><br><span class="line">// 根据PID返回进程EPROCESS，失败返回NULL</span><br><span class="line">PEPROCESS LookupProcess(HANDLE hPid)</span><br><span class="line">&#123;</span><br><span class="line">    PEPROCESS pEProcess = NULL;</span><br><span class="line">    if (NT_SUCCESS(PsLookupProcessByProcessId(</span><br><span class="line">        hPid, &amp;pEProcess)))</span><br><span class="line">        return pEProcess;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID ChangeData(ULONG uId)</span><br><span class="line">&#123;</span><br><span class="line">    KAPC_STATE ks;</span><br><span class="line"></span><br><span class="line">    //1 根据ID获得进程内核对象</span><br><span class="line">    PEPROCESS pEprocess = LookupProcess((HANDLE)uId);</span><br><span class="line"></span><br><span class="line">    //2 挂靠到此进程上去</span><br><span class="line">    //需要注意：不能挂靠之后，将内存中的数据往用户层地址存储，是不对的。</span><br><span class="line">    //因为当挂靠到目标进程之后，用户层地址就是目标进程的了，也就存储到</span><br><span class="line">    //目标进程中，而且目标进程的那个地址不一定有效，可能造成崩溃。</span><br><span class="line">    KeStackAttachProcess(</span><br><span class="line">        pEprocess,</span><br><span class="line">        &amp;ks</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    //3 修改内存</span><br><span class="line">    char * p = (char *)0x1dfaf0;</span><br><span class="line">    p[5] = &apos;h&apos;;</span><br><span class="line">    p[6] = &apos;a&apos;;</span><br><span class="line">    p[7] = &apos;h&apos;;</span><br><span class="line">    p[8] = &apos;a&apos;;</span><br><span class="line">    p[9] = &apos;\0&apos;;</span><br><span class="line">    //4 解除挂靠</span><br><span class="line">    KeUnstackDetachProcess(&amp;ks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath)</span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">    DbgBreakPoint();</span><br><span class="line"></span><br><span class="line">    ChangeData(1716);</span><br><span class="line"></span><br><span class="line">    pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver)</span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    char *ch = &quot;allenboy&quot;;</span><br><span class="line">    printf(&quot;%c,%x&quot;, ch, ch);</span><br><span class="line">    getchar();</span><br><span class="line">    printf(&quot;%c,%x&quot;, ch, ch);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 笔记 - 驱动学习编辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核学习 </tag>
            
            <tag> 进次挂靠 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统调用笔记下</title>
      <link href="/2018/06/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B8%8B/"/>
      <url>/2018/06/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B8%8B/</url>
      <content type="html"><![CDATA[<h1 id="API函数的调用过程（SystemServiceTable）"><a href="#API函数的调用过程（SystemServiceTable）" class="headerlink" title="API函数的调用过程（SystemServiceTable）"></a>API函数的调用过程（SystemServiceTable）</h1><p>在上中，讲到进0环后，3环的各种寄存器都会保留到<br>_Trap_Frame结构体中，这篇我讲解</p><p>如何根据系统服务号(eax中存储)找到要执行的内核函数？<br>调用时参数是存储到3环的堆栈，如何传递给内核函数？</p><h2 id="SystemServiceTable-系统服务表"><a href="#SystemServiceTable-系统服务表" class="headerlink" title="SystemServiceTable 系统服务表"></a>SystemServiceTable 系统服务表</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/8.png" alt="系统服务表"><br>ServiceTable存了系统服务表里函数地址表（4字节）<br>Count是当前系统服务表被调用了几次<br>serviceLimit存了有多少个函数<br>ArgmentTable存了有多少个参数（以字节为单位，比如穿了2个参数，每个参数4字节，所以这里存8，一个单元1字节）<br>绿色的是导出的函数      </p><p>黄色结构是一样的，区别就是绿色的是Ntoskrl.exe的，黄色的是Win32k.sys（图形显示之类的模块）的。   </p><p>那么程序执行的时候去哪找系统服务表，是_KTHREAD的偏移0xE0处。</p><p>下面系统服务号eax怎么找这个对应的函数呢，虽然eax32位，真正使用的只有13位，如下</p><h2 id="判断要调用的函数在哪个表"><a href="#判断要调用的函数在哪个表" class="headerlink" title="判断要调用的函数在哪个表"></a>判断要调用的函数在哪个表</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/10.png" alt="系统服务号"><br>低12位找对应偏移的函数，相同维序的参数表就是这个函数的参数。<br>下面来分析代码，2种调用除了开始寄存器保存不一样（KiSystemServer多做了一些读取内存寄存器的操作），后来都执行相同的代码所以直接开始分析KiSystemServer执行完跳转到KiFastCallEntry里的代码</p><p>下面先列一下不同于KiSystemServer，KiFastCallEntry多用到的结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTSS</span><br><span class="line">nt!_KTSS</span><br><span class="line">   +0x000 Backlink         : Uint2B</span><br><span class="line">   +0x002 Reserved0        : Uint2B</span><br><span class="line">   +0x004 Esp0             : Uint4B</span><br><span class="line">   +0x008 Ss0              : Uint2B</span><br><span class="line">   +0x00a Reserved1        : Uint2B</span><br><span class="line">   +0x00c NotUsed1         : [4] Uint4B</span><br><span class="line">   +0x01c CR3              : Uint4B</span><br><span class="line">   +0x020 Eip              : Uint4B</span><br><span class="line">   +0x024 EFlags           : Uint4B</span><br><span class="line">   +0x028 Eax              : Uint4B</span><br><span class="line">   +0x02c Ecx              : Uint4B</span><br><span class="line">   +0x030 Edx              : Uint4B</span><br><span class="line">   +0x034 Ebx              : Uint4B</span><br><span class="line">   +0x038 Esp              : Uint4B</span><br><span class="line">   +0x03c Ebp              : Uint4B</span><br><span class="line">   +0x040 Esi              : Uint4B</span><br><span class="line">   +0x044 Edi              : Uint4B</span><br><span class="line">   +0x048 Es               : Uint2B</span><br><span class="line">   +0x04a Reserved2        : Uint2B</span><br><span class="line">   +0x04c Cs               : Uint2B</span><br><span class="line">   +0x04e Reserved3        : Uint2B</span><br><span class="line">   +0x050 Ss               : Uint2B</span><br><span class="line">   +0x052 Reserved4        : Uint2B</span><br><span class="line">   +0x054 Ds               : Uint2B</span><br><span class="line">   +0x056 Reserved5        : Uint2B</span><br><span class="line">   +0x058 Fs               : Uint2B</span><br><span class="line">   +0x05a Reserved6        : Uint2B</span><br><span class="line">   +0x05c Gs               : Uint2B</span><br><span class="line">   +0x05e Reserved7        : Uint2B</span><br><span class="line">   +0x060 LDT              : Uint2B</span><br><span class="line">   +0x062 Reserved8        : Uint2B</span><br><span class="line">   +0x064 Flags            : Uint2B</span><br><span class="line">   +0x066 IoMapBase        : Uint2B</span><br><span class="line">   +0x068 IoMaps           : [1] _KiIoAccessMap</span><br><span class="line">   +0x208c IntDirectionMap  : [32] UChar</span><br></pre></td></tr></table></figure><p>FS寄存器，在用户层的时候，指向的是TEB，在内核层的时候，指向的是KPC<br>下面是通过IDA观察的_KiSystemService函数   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">.text:0043567E _KiSystemService proc near              ; CODE XREF: ZwAcceptConnectPort(x,x,x,x,x,x)+Cp</span><br><span class="line">.text:0043567E                                         ; ZwAccessCheck(x,x,x,x,x,x,x,x)+Cp ...</span><br><span class="line">.text:0043567E</span><br><span class="line">.text:0043567E arg_0           = dword ptr  4</span><br><span class="line">.text:0043567E</span><br><span class="line">.text:0043567E                 push    0               ; _KTRAP_FRAME +0x064 ErrCode</span><br><span class="line">.text:00435680                 push    ebp             ; 0x060 Ebp,3环寄存器入栈</span><br><span class="line">.text:00435681                 push    ebx             ; 0x05C,ebx</span><br><span class="line">.text:00435682                 push    esi             ; 0x058 Esi</span><br><span class="line">.text:00435683                 push    edi             ; 0x054 Edi</span><br><span class="line">.text:00435684                 push    fs              ; 0x050 SegFs</span><br><span class="line">.text:00435686                 mov     ebx, 30h        ; 为FS寄存器赋值,30就是段选择子，在GDTR找到相应的段描述符，加载到，FS，指向KPCR结构体</span><br><span class="line">.text:0043568B                 mov     fs, bx          ; Windows内核有个特殊的基本要求，就是只要CPU在内核运行，就得使</span><br><span class="line">.text:0043568B                                         ; mov ebx,30 //0011 0000  所以就是0环GDT索引6</span><br><span class="line">.text:0043568B                                         ; mov fs,bx</span><br><span class="line">.text:0043568B                                         ;</span><br><span class="line">.text:0043568B                                         ; 0环的FS.Base指向CPU自己的KPCR，不是指向当前线程</span><br><span class="line">.text:0043568B                                         ; 选择码，0x30的结构分析如下：</span><br><span class="line">.text:0043568B                                         ; 1.bit0~bit1:RPL,Requested Privilege Level,要求运行的级别，这里是0</span><br><span class="line">.text:0043568B                                         ; 2.bit2：找GDT还是IDT，这里是0，GDT</span><br><span class="line">.text:0043568B                                         ; 3.bit3！bit15，是在GDT或者IDT的下标</span><br><span class="line">.text:0043568B                                         ; windbg查看段描述符：834093f2 dc003748</span><br><span class="line">.text:0043568B                                         ; Base:83f2dc00 指向当前的_KPCR</span><br><span class="line">.text:0043568E                 mov     ebx, 23h</span><br><span class="line">.text:00435693                 mov     ds, ebx</span><br><span class="line">.text:00435695                 mov     es, ebx</span><br><span class="line">.text:00435697                 mov     esi, large fs:124h ; 查看下KPCR偏移124h是什么，查训发现是当前CPU所执行线程的_ETHREAD</span><br><span class="line">.text:0043569E                 push    large dword ptr fs:0 ; 保存老的ExceptionList</span><br><span class="line">.text:0043569E                                         ; _KPCR偏移+0x00-&gt;NT_TIB-&gt;ExceptionList</span><br><span class="line">.text:004356A5                 mov     large dword ptr fs:0, 0FFFFFFFFh ; 新的ExceptonList为空白，因为3环的异常链表，不能用，要进0环了</span><br><span class="line">.text:004356B0                 push    dword ptr [esi+13Ah] ; 因为Esi存的_KTHREAD,他的偏移13A存的PreviousMode,</span><br><span class="line">.text:004356B0                                         ; 就是保存老的先前模式到堆栈</span><br><span class="line">.text:004356B0                                         ; 先前模式就是当调用这些代码时候，原来是几环的数就是几，比如原来0环，先前模式就是0，原来3环就是1</span><br><span class="line">.text:004356B0                                         ; 因为有些内核代码可以从0和3调用，但是执行内容不一样，通过这个知道执行什么。</span><br><span class="line">.text:004356B6                 sub     esp, 48h        ; ESP 提升到_KTRAP_FRAME结构体第一个成员，也就是这个结构体指针</span><br><span class="line">.text:004356B9                 mov     ebx, [esp+68h+arg_0] ; 查了下这个位置是3环CS</span><br><span class="line">.text:004356B9                                         ; 所以这句是取出3环压入的参数CS _KTRAP_FRAME + 0x6C</span><br><span class="line">.text:004356BD                 and     ebx, 1          ; 上面的CS跟1与运算</span><br><span class="line">.text:004356BD                                         ; 0环最低位是0,3环最低位为1</span><br><span class="line">.text:004356C0                 mov     [esi+13Ah], bl  ; 上面的运算结果存到esi+0x13Ah这个位置的偏移，就是新的&quot;先前模式&quot;</span><br><span class="line">.text:004356C6                 mov     ebp, esp        ; 抬高栈针,ebp=esp=_KTRAP_FRAME指针</span><br><span class="line">.text:004356C8                 mov     ebx, [esi+128h] ; _KTHTEAD中的TrapFrame给ebx</span><br><span class="line">.text:004356CE                 mov     [ebp+3Ch], ebx  ; 将_KTHREAD中的Trap_Frame暂时存在这个位置后面</span><br><span class="line">.text:004356CE                                         ; //会将这个值取出来，重新恢复给_KTHREAD的Trap_Frame</span><br><span class="line">.text:004356CE                                         ;</span><br><span class="line">.text:004356CE                                         ; 零时存在这</span><br><span class="line">.text:004356D1                 and     dword ptr [ebp+2Ch], 0 ; Dr7清0</span><br><span class="line">.text:004356D5                 test    byte ptr [esi+3], 0DFh ; 查看当前线程是否处于调试状态</span><br><span class="line">.text:004356D5                                         ; 看看是不是-1，</span><br><span class="line">.text:004356D9                 mov     [esi+128h], ebp ; 因为有改变堆栈中的_KTRAP_FRAME,将其重新赋值给_KTHREAD中的TRAPFRAME</span><br><span class="line">.text:004356DF                 cld</span><br><span class="line">.text:004356E0                 jnz     Dr_kss_a        ; 处于调试的话跳转,跳转那边的代码是讲调试寄存器都存到Trap_Frame里</span><br><span class="line">.text:004356E6</span><br><span class="line">.text:004356E6 loc_4356E6:                             ; CODE XREF: Dr_kss_a+Dj</span><br><span class="line">.text:004356E6                                         ; Dr_kss_a+79j</span><br><span class="line">.text:004356E6                 mov     ebx, [ebp+60h]  ; 3环的EPB给ebx</span><br><span class="line">.text:004356E9                 mov     edi, [ebp+68h]  ; 3环的Eip</span><br><span class="line">.text:004356EC                 mov     [ebp+0Ch], edx  ; edx存的3环参数指针：</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; _kiFastSystemCall函数</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; mov edx，esp</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; sysenter</span><br><span class="line">.text:004356EF                 mov     dword ptr [ebp+8], 0BADB0D00h ; 这个是操作系统的标志</span><br><span class="line">.text:004356F6                 mov     [ebp+0], ebx    ; 3环的ebp存储到KTRAP_FRAME+0x000 DbgEbp的位置</span><br><span class="line">.text:004356F9                 mov     [ebp+4], edi    ; 3环的ebp存储到KTRAP_FRAME+0x004 DbgEip的位置</span><br><span class="line">.text:004356FC                 sti</span><br><span class="line">.text:004356FD                 jmp     loc_4357DF      ; 跳到KiFastCallEntry</span><br><span class="line">.text:004356FD _KiSystemService endp</span><br><span class="line">.text:004356FD</span><br><span class="line">.text:00435702</span><br><span class="line">.text:00435702 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00435702</span><br><span class="line">.text:00435702</span><br><span class="line">.text:00435702 _KiFastCallEntry2 proc near             ; DATA XREF: _KiTrap01:loc_436724o</span><br><span class="line">.text:00435702                 mov     ecx, 30h</span><br><span class="line">.text:00435707                 mov     fs, ecx</span><br><span class="line">.text:00435709                 mov     ecx, 23h</span><br><span class="line">.text:0043570E                 mov     ds, ecx</span><br><span class="line">.text:00435710                 mov     es, ecx</span><br><span class="line">.text:00435712                 mov     ecx, large fs:40h</span><br><span class="line">.text:00435719                 mov     esp, [ecx+4]</span><br><span class="line">.text:0043571C                 push    23h</span><br><span class="line">.text:0043571E                 push    edx</span><br><span class="line">.text:0043571F                 pushf</span><br><span class="line">.text:00435720                 or      byte ptr [esp+1], 1</span><br><span class="line">.text:00435725                 jmp     short loc_43576B ; Sanitize eflags, clear direction, NT etc;设置eflags为2,,表示所有标志位都是0(中断被关闭)，就是清除所有标志位</span><br><span class="line">.text:00435725 _KiFastCallEntry2 endp</span><br><span class="line">.text:00435725</span><br><span class="line">.text:00435727 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00435727 ; START OF FUNCTION CHUNK FOR _KiFastCallEntry</span><br><span class="line">.text:00435727</span><br><span class="line">.text:00435727 loc_435727:                             ; CODE XREF: _KiFastCallEntry:loc_43574Bj</span><br><span class="line">.text:00435727                 mov     ecx, large fs:40h</span><br><span class="line">.text:0043572E                 mov     esp, [ecx+4]</span><br><span class="line">.text:00435731                 push    0</span><br><span class="line">.text:00435733                 push    0</span><br><span class="line">.text:00435735                 push    0</span><br><span class="line">.text:00435737                 push    0</span><br><span class="line">.text:00435739                 push    23h</span><br><span class="line">.text:0043573B                 push    0</span><br><span class="line">.text:0043573D                 push    20202h</span><br><span class="line">.text:00435742                 push    1Bh</span><br><span class="line">.text:00435744                 push    0</span><br><span class="line">.text:00435746                 jmp     _KiTrap06</span><br><span class="line">.text:0043574B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0043574B</span><br><span class="line">.text:0043574B loc_43574B:                             ; CODE XREF: _KiFastCallEntry+62j</span><br><span class="line">.text:0043574B                 jmp     short loc_435727</span><br><span class="line">.text:0043574B ; END OF FUNCTION CHUNK FOR _KiFastCallEntry</span><br><span class="line">.text:0043574B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0043574D                 align 10h</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 ; ;此时:</span><br><span class="line">.text:00435750 ; ;eax指向服务编号</span><br><span class="line">.text:00435750 ; ;edx指向当前用户栈,edx+8为参数列表</span><br><span class="line">.text:00435750 ;</span><br><span class="line">.text:00435750 ; KGDT_R3_DATA OR RPL_MASK  给ecx</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 _KiFastCallEntry proc near              ; DATA XREF: KiLoadFastSyscallMachineSpecificRegisters(x)+21o</span><br><span class="line">.text:00435750                                         ; _KiTrap01+71o</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 var_7C          = dword ptr -7Ch</span><br><span class="line">.text:00435750 var_B           = byte ptr -0Bh</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 ; FUNCTION CHUNK AT .text:00435727 SIZE 00000026 BYTES</span><br><span class="line">.text:00435750 ; FUNCTION CHUNK AT .text:00435A75 SIZE 00000014 BYTES</span><br><span class="line">.text:00435750 ; FUNCTION CHUNK AT .text:00435BCB SIZE 00000038 BYTES</span><br><span class="line">.text:00435750 ; FUNCTION CHUNK AT .text:00435C04 SIZE 0000001A BYTES</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750                 mov     ecx, 23h</span><br><span class="line">.text:00435755                 push    30h             ; 这里的30是KGDT_R0_PCR，也就是0环的GDT的PCR，要给fs，使fs指向KPCR</span><br><span class="line">.text:00435757                 pop     fs              ; 为FS寄存器赋值,30就是段选择子，在GDTR找到相应的段描述符，加载到，FS，指向KPCR结构体</span><br><span class="line">.text:00435759                 mov     ds, ecx         ; ds指向用户数据段</span><br><span class="line">.text:0043575B                 mov     es, ecx         ; es指向用户数据段</span><br><span class="line">.text:0043575D                 mov     ecx, large fs:40h ; 传说中的TSS，保存了一大堆寄存器的值</span><br><span class="line">.text:00435764                 mov     esp, [ecx+4]    ; tts中获得当前线程堆栈的esp,0环ESP给ESP</span><br><span class="line">.text:00435767                 push    23h             ; 23是 KGDT_R3_DATA OR RPL_MASK   ; Push user SS(压入用户态线程的堆栈段寄存器ss)</span><br><span class="line">.text:00435769                 push    edx             ; edx,参数入栈,</span><br><span class="line">.text:00435769                                         ; edx保存的是用户层的堆栈，也就是Push ESP(压入esp)</span><br><span class="line">.text:0043576A                 pushf                   ; 压入标志寄存器</span><br><span class="line">.text:0043576B</span><br><span class="line">.text:0043576B loc_43576B:                             ; CODE XREF: _KiFastCallEntry2+23j</span><br><span class="line">.text:0043576B                 push    2               ; Sanitize eflags, clear direction, NT etc;设置eflags为2,,表示所有标志位都是0(中断被关闭)，就是清除所有标志位</span><br><span class="line">.text:0043576D                 add     edx, 8          ; edx+8就是dex移动到了参数位置</span><br><span class="line">.text:00435770                 popf                    ; .errnz(EFLAGS_INTERRUPT_MASK AND 0FFFF00FFh)</span><br><span class="line">.text:00435771                 or      [esp+0Ch+var_B], 2 ; or byte ptr [esp+1], EFLAGS_INTERRUPT_MASK/0100h ; Enable interrupts in eflags(打开用户态eflags的中断)</span><br><span class="line">.text:00435776                 push    1Bh             ; Push user CS</span><br><span class="line">.text:00435778                 push    dword ptr ds:0FFDF0304h ; push return address(使其返回时指向用户空间</span><br><span class="line">.text:00435778                                         ; push dword ptr ds:[USER_SHARED_DATA+UsSystemCallReturn] ;</span><br><span class="line">.text:0043577E                 push    0               ; put pad dword for error on stack</span><br><span class="line">.text:00435780                 push    ebp             ;  save the non-volatile registers</span><br><span class="line">.text:00435781                 push    ebx</span><br><span class="line">.text:00435782                 push    esi</span><br><span class="line">.text:00435783                 push    edi             ; 保存现场</span><br><span class="line">.text:00435784                 mov     ebx, large fs:1Ch ; Ptr32 _KPCR     指向KPCR自己</span><br><span class="line">.text:0043578B                 push    3Bh             ; Push user mode FS</span><br><span class="line">.text:0043578B                                         ; push KGDT_R3_TEB OR RPL_MASK</span><br><span class="line">.text:0043578D                 mov     esi, [ebx+124h] ; esi为指向当前线程的结构体KTHREAD</span><br><span class="line">.text:00435793                 push    dword ptr [ebx] ; 吧KPCR入栈</span><br><span class="line">.text:00435795                 mov     dword ptr [ebx], 0FFFFFFFFh ; ebx等于-1</span><br><span class="line">.text:0043579B                 mov     ebp, [esi+28h]  ; 这个位置是InitialStack</span><br><span class="line">.text:0043579B                                         ; 使ebp指向当前线程堆栈的栈顶</span><br><span class="line">.text:0043579E                 push    1               ; Save previous mode as user(保存先前模式)</span><br><span class="line">.text:004357A0                 sub     esp, 48h        ; 给ESP分配48h字节, 也就是DbgEbp到Eax所占据的空间</span><br><span class="line">.text:004357A0                                         ; allocate remainder of trap frame</span><br><span class="line">.text:004357A3                 sub     ebp, 29Ch       ; sub ebp, NPX_FRAME_LENGTH + KTRAP_FRAME_LENGTH</span><br><span class="line">.text:004357A3                                         ; 就是ebp指向了 _Ktrap_frame</span><br><span class="line">.text:004357A9                 mov     byte ptr [esi+13Ah], 1 ; esi+0x13Ah这个位置的偏移，就是新的&quot;先前模式&quot;为1，就是之前是从3环调用的这个代码</span><br><span class="line">.text:004357B0                 cmp     ebp, esp        ; 判断堆栈内压入的值是否正确(这些堆栈内压入的东西,就好比一个trap框架)</span><br><span class="line">.text:004357B2                 jnz     short loc_43574B ; 不正确重新来一遍</span><br><span class="line">.text:004357B4                 and     dword ptr [ebp+2Ch], 0 ; sDr7置0</span><br><span class="line">.text:004357B8                 test    byte ptr [esi+3], 0DFh ; 检查是否被调试</span><br><span class="line">.text:004357BC                 mov     [esi+128h], ebp ; 重新把修改过的TrapFrame设置回_KTHREAD的相应参数位置</span><br><span class="line">.text:004357C2                 jnz     Dr_FastCallDrSave ; 处于调试则保存那些寄存器</span><br><span class="line">.text:004357C8</span><br><span class="line">.text:004357C8 loc_4357C8:                             ; CODE XREF: Dr_FastCallDrSave+Dj</span><br><span class="line">.text:004357C8                                         ; Dr_FastCallDrSave+79j</span><br><span class="line">.text:004357C8                 mov     ebx, [ebp+60h]  ; Ebp给ebx</span><br><span class="line">.text:004357CB                 mov     edi, [ebp+68h]  ; eip给Edi</span><br><span class="line">.text:004357CE                 mov     [ebp+0Ch], edx  ; 参数地址给DbgArgPointer</span><br><span class="line">.text:004357D1                 mov     dword ptr [ebp+8], 0BADB0D00h</span><br><span class="line">.text:004357D8                 mov     [ebp+0], ebx    ; 3环ebp给调试DbgEbp</span><br><span class="line">.text:004357DB                 mov     [ebp+4], edi    ; 3环Eip给DbgEip</span><br><span class="line">.text:004357DE                 sti                     ; 开中断，允许硬件中断</span><br><span class="line">.text:004357DF</span><br><span class="line">.text:004357DF loc_4357DF:                             ; CODE XREF: _KiBBTUnexpectedRange+18j</span><br><span class="line">.text:004357DF                                         ; _KiSystemService+7Fj</span><br><span class="line">.text:004357DF                 mov     edi, eax        ; 取出系统调用号，给edi</span><br><span class="line">.text:004357E1                 shr     edi, 8          ; 系统调用号右移8位</span><br><span class="line">.text:004357E4                 and     edi, 10h        ; 将第12位；与1与，得到的数，看看是哪个的系统服务表，是Ntoskrl的还是Win32k.sys的</span><br><span class="line">.text:004357E7                 mov     ecx, edi        ; 调用号给ecx</span><br><span class="line">.text:004357E9                 add     edi, [esi+0BCh] ; edi的值加上ServiceTable，如果0就是第一个表，1就是第二个表</span><br><span class="line">.text:004357E9                                         ; 就是SSDT表</span><br><span class="line">.text:004357EF                 mov     ebx, eax        ; 调用序号给ebx</span><br><span class="line">.text:004357F1                 and     eax, 0FFFh      ; 系统调用号，只要后面12位</span><br><span class="line">.text:004357F6                 cmp     eax, [edi+8]    ; 调用号跟系统表函数总数作比较</span><br><span class="line">.text:004357F9                 jnb     _KiBBTUnexpectedRange ; 大于等于说明越界，到处理越界的地方去</span><br><span class="line">.text:004357FF                 cmp     ecx, 10h        ; 看看是1还是0，就是说看看是哪一张表</span><br><span class="line">.text:00435802                 jnz     short loc_43581E ; 是0，第一张表往上面跳转</span><br><span class="line">.text:00435804                 mov     ecx, [esi+88h]  ; Teb给ecx</span><br><span class="line">.text:0043580A                 xor     esi, esi        ; esi清0</span><br><span class="line">.text:0043580C</span><br><span class="line">.text:0043580C loc_43580C:                             ; DATA XREF: _KiTrap0E+156o</span><br><span class="line">.text:0043580C                 or      esi, [ecx+0F70h]</span><br><span class="line">.text:00435812                 jz      short loc_43581E</span><br><span class="line">.text:00435814                 push    edx</span><br><span class="line">.text:00435815                 push    eax</span><br><span class="line">.text:00435816                 call    ds:_KeGdiFlushUserBatch ; 是第二张表跳转到的函数,一般都是图像相关，动态加载的</span><br><span class="line">.text:0043581C                 pop     eax</span><br><span class="line">.text:0043581D                 pop     edx</span><br><span class="line">.text:0043581E</span><br><span class="line">.text:0043581E loc_43581E:                             ; CODE XREF: _KiFastCallEntry+B2j</span><br><span class="line">.text:0043581E                                         ; _KiFastCallEntry+C2j</span><br><span class="line">.text:0043581E                 inc     large dword ptr fs:6B0h</span><br><span class="line">.text:00435825                 mov     esi, edx        ; edx存储着3环传入函数的指针</span><br><span class="line">.text:00435827                 xor     ecx, ecx</span><br><span class="line">.text:00435829                 mov     edx, [edi+0Ch]  ; edi存的SSDT表，所以这里+0x0Ch是SSDT参数表起始的的地址</span><br><span class="line">.text:0043582C                 mov     edi, [edi]      ; 指向函数表的地址</span><br><span class="line">.text:0043582E                 mov     cl, [eax+edx]   ; eax系统调用号 参数表+调用号得到参数个数</span><br><span class="line">.text:00435831                 mov     edx, [edi+eax*4] ; 0环函数的地址,函数地址表参数4字节</span><br><span class="line">.text:00435834                 sub     esp, ecx        ; 提升堆栈，提高为Cl,因为参数是3环的，要把3环参数存到0环，所以是抬高这么高的栈针</span><br><span class="line">.text:00435836                 shr     ecx, 2          ; 为了下面rep movsd，一次复制4字节，复制ecx次，ecx保存参数个数单位是一字节，所以这里要除以4</span><br><span class="line">.text:00435839                 mov     edi, esp        ; 设置要复制的地址</span><br><span class="line">.text:0043583B                 cmp     esi, ds:_MmUserProbeAddress ; 判断用户函数地址范围有没有越界</span><br><span class="line">.text:00435841                 jnb     loc_435A75</span><br><span class="line">.text:00435847</span><br><span class="line">.text:00435847 loc_435847:                             ; CODE XREF: _KiFastCallEntry+329j</span><br><span class="line">.text:00435847                                         ; DATA XREF: _KiTrap0E:loc_438AD8o</span><br><span class="line">.text:00435847                 rep movsd               ; 开始复制参数</span><br><span class="line">.text:00435849                 test    byte ptr [ebp+6Ch], 1 ; SegCs</span><br><span class="line">.text:0043584D                 jz      short loc_435865</span><br><span class="line">.text:0043584F                 mov     ecx, large fs:124h</span><br><span class="line">.text:00435856                 mov     edi, [esp+7Ch+var_7C]</span><br><span class="line">.text:00435859                 mov     [ecx+13Ch], ebx</span><br><span class="line">.text:0043585F                 mov     [ecx+12Ch], edi</span><br><span class="line">.text:00435865</span><br><span class="line">.text:00435865 loc_435865:                             ; CODE XREF: _KiFastCallEntry+FDj</span><br><span class="line">.text:00435865                 mov     ebx, edx</span><br><span class="line">.text:00435867                 test    byte ptr ds:dword_52E0C8, 40h</span><br><span class="line">.text:0043586E                 setnz   byte ptr [ebp+12h]</span><br><span class="line">.text:00435872                 jnz     loc_435C04</span><br><span class="line">.text:00435878</span><br><span class="line">.text:00435878 loc_435878:                             ; CODE XREF: _KiFastCallEntry+4BBj</span><br><span class="line">.text:00435878                 call    ebx             ; 调用函数</span><br></pre></td></tr></table></figure><h2 id="API函数的调用过程（SSDT）"><a href="#API函数的调用过程（SSDT）" class="headerlink" title="API函数的调用过程（SSDT）"></a>API函数的调用过程（SSDT）</h2><p>在上一节课中，我们讲到系统服务表的结构，以及如何找到系统服务<br>表(KTHREAD  0xbc偏移).  </p><p>也可以通过SSDT访问<br>SSDT  的全称是 System Services Descriptor Table，系统服务描述符表<br>kd&gt; dd  KeServiceDescriptorTable(SSDT)ntosKrl是内核导出的<br>导出的 声明一下就可以使用了<br>kd&gt; dd  KeServiceDescriptorTableShadow(SSDT Shadow)<br>未导出 需要用其他的方式来查找   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83f789c0  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f789d0  00000000 00000000 00000000 00000000</span><br><span class="line">83f789e0  83eeb6af 00000000 025355a9 000000bb</span><br><span class="line">83f789f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83f78a00  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f78a10  95d46000 00000000 00000339 95d4702c</span><br><span class="line">83f78a20  00000000 00000000 83f78a24 00000340</span><br><span class="line">83f78a30  00000340 865fab00 00000007 00000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kd&gt; dd KeServiceDescriptorTableShadow</span><br><span class="line">83f78a00  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f78a10  95d46000 00000000 00000339 95d4702c</span><br><span class="line">83f78a20  00000000 00000000 83f78a24 00000340</span><br><span class="line">83f78a30  00000340 865fab00 00000007 00000000</span><br><span class="line">83f78a40  865faa38 865fa7e0 865fa970 865fa8a8</span><br><span class="line">83f78a50  00000000 865fa718 00000000 00000000</span><br><span class="line">83f78a60  83e86809 83e93eed 83ea23a5 00000003</span><br><span class="line">83f78a70  80783000 80784000 00000120 ffffffff</span><br></pre></td></tr></table></figure><p>因为KeServiceDescriptorTableShadow没有导出，所以一般采用内存搜索获取这张表   </p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：毛德操，《Windows内核情景分析》<br>[2]：滴水视频<br>[3]: 一大堆的别人的博客，重点博客<a href="https://blog.csdn.net/Sunny_wwc/article/details/5939848" target="_blank" rel="noopener">https://blog.csdn.net/Sunny_wwc/article/details/5939848</a>  </p>]]></content>
      
      <categories>
          
          <category> 笔记 - 系统调用笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用 </tag>
            
            <tag> 驱动学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统调用笔记上</title>
      <link href="/2018/06/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B8%8A/"/>
      <url>/2018/06/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B8%8A/</url>
      <content type="html"><![CDATA[<h1 id="API函数的调用过程（3环部分）"><a href="#API函数的调用过程（3环部分）" class="headerlink" title="API函数的调用过程（3环部分）"></a>API函数的调用过程（3环部分）</h1><h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><ol><li>Application Programming Interface，简称 API 函数。</li><li><p>Windows有多少个API?<br>主要是存放在 C:\WINDOWS\system32 下面所有的dll，dll里面函数都是API</p></li><li><p>几个重要的DLL<br>Kernel32.dll:最核心的功能模块，比如管理内存、进程和线程相关的函数等.<br>User32.dll:是Windows用户界面相关应用程序接口,如创建窗口和发送消息等.<br>GDI32.dll:全称是Graphical Device Interface(图形设备接口),包含用于画图和显示文本的函数.比如要显示一个程序窗口，就调用了其中的函数来画这个窗口.<br>Ntdll.dll:大多数API都会通过这个DLL进入内核(0环).</p></li></ol><p>做实验找 ReadProcessMemory<br>首先打开IDA，打开kernelBase.dll（XP是kernel32.dll），按ATL+T，如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/1.png?x-oss-process=style/yangruiqi.com" alt="图1"></p><p>然后就打开了ReadProcessMemory，如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/2.png?x-oss-process=style/yangruiqi.com" alt="图二"><br>发现是调用了NtReadVirtualMemory。<br>再去import里面找这个函数就知道谁调用了他<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/3.png?x-oss-process=style/yangruiqi.com" alt="3"></p><p>发现时ntdll，然后去找ntdll,的这个函数<br>NtReadVirtualMemory<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/4.png?x-oss-process=style/yangruiqi.com" alt="4"><br>真正读取进程内存的函数在0环，在这里的114h是一个编号，这个编号，对应的是真正的操作系统内核中某个函数，所以我们的API进内核都需要一个编号，这个编号就是真正执行的函数。下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx,7FFE0300h</span><br></pre></td></tr></table></figure><p>这是一个内存地址，存了一个函数，这个函数觉得了用什么方式进0环，也就是这段代码就是找到一个编号通过一个函数（edx）进入0环。<br>所以3环的API函数都是提供一个进入0环的接口而已。   </p><h1 id="API函数的调用过程（3环进0环-上）"><a href="#API函数的调用过程（3环进0环-上）" class="headerlink" title="API函数的调用过程（3环进0环 上）"></a>API函数的调用过程（3环进0环 上）</h1><p>下面我们说一下上面的7FFE0300h函数是什么，所以先了解下0x7ffe0000这页内存是什么。</p><h2 id="KUSER-SHARED-DATA（Kernel和Use共享了一块数据）"><a href="#KUSER-SHARED-DATA（Kernel和Use共享了一块数据）" class="headerlink" title="_KUSER_SHARED_DATA（Kernel和Use共享了一块数据）"></a>_KUSER_SHARED_DATA（Kernel和Use共享了一块数据）</h2><p>这块任何一个3环的程序都可以访问，他的地址是确定的。地址如下</p><ol><li>在 User 层和 Kernel 层分别定义了一个 _KUSER_SHARED_DATA 结构区域，用于 User 层和 Kernel 层共享某些数据   </li><li>它们使用固定的地址值映射，_KUSER_SHARED_DATA 结构区域在 User 和 Kernel 层地址分别为：<ol><li>User 层地址为：0x7ffe0000   </li><li>Kernnel 层地址为：0xffdf0000  </li></ol></li></ol><p>这两个不同的线性地址，指向的是同一个物理页，区别就是0环通过这个线性地址对这块内存可读可写，但是3环是只读，虽然指向的是同一个物理页，但在User 层是只读的，在Kernnel层是可写的.<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/5XFT%24MTSEVTT3PC%7B0V_38%40P.png?x-oss-process=style/yangruiqi.com" alt="5"></p><p>如上图，查看下内容一样</p><h2 id="0x7FFE0300到底存储的是什么？"><a href="#0x7FFE0300到底存储的是什么？" class="headerlink" title="0x7FFE0300到底存储的是什么？"></a>0x7FFE0300到底存储的是什么？</h2><p>然后查看下_KUSER_SHARED_DATA这个内存<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/FM%60M1%7EA%7D3G%25PL6E%29LD2JKSC.png?x-oss-process=style/yangruiqi.com" alt="6"></p><p>查看到300处偏移就是一个叫SystemCall，这个位置存储的函数有两种情况：   </p><p>实验：是否支持快速调用</p><p>当通过eax=1来执行cpuid指令时，处理器的特征信息被放在ecx和edx寄存器中，其中edx包含了一个SEP位（11位），该位指明了当前处理器知否支持sysenter/sysexit指令</p><p>支持：<br>ntdll.dll!KiFastSystemCall()//这个不是内核函数，是ntdll的</p><p>不支持：<br>ntdll.dll!KiIntSystemCall()<br>实验如下，改eax=1，ecx，edx清0，命令改成CPUID</p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/Z00%5D%5BD8IRJPWLRBM7DSX%254I.png?x-oss-process=style/yangruiqi.com" alt="7"><br>edx=0F8BFBFF，2进制是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‭1111100010111111101111111111‬</span><br></pre></td></tr></table></figure></p><p>第11位是1，支持，支持时把KiFastSystemCall()写到300偏移处的地址上，不支持KiIntSystemCall()写过去   </p><h2 id="进0环需要更改哪些寄存器？"><a href="#进0环需要更改哪些寄存器？" class="headerlink" title="进0环需要更改哪些寄存器？"></a>进0环需要更改哪些寄存器？</h2><ol><li>CS的权限由3变为0  意味着需要新的CS</li></ol><p>2) SS与CS的权限永远一致 需要新的SS</p><p>3) 权限发生切换的时候，堆栈也一定会切换，需要新的ESP</p><p>4) 进0环后代码的位置，需要EIP  </p><h2 id="不支持快速调用时候，中断门进0环："><a href="#不支持快速调用时候，中断门进0环：" class="headerlink" title="不支持快速调用时候，中断门进0环："></a>不支持快速调用时候，中断门进0环：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:77F070C0                 public KiIntSystemCall</span><br><span class="line">.text:77F070C0 KiIntSystemCall proc near               ; DATA XREF: .text:off_77EF61B8o</span><br><span class="line">.text:77F070C0</span><br><span class="line">.text:77F070C0 arg_4           = byte ptr  8</span><br><span class="line">.text:77F070C0</span><br><span class="line">.text:77F070C0                 lea     edx, [esp+arg_4]//edx是参数指针，系统调用号在eax寄存器</span><br><span class="line">.text:77F070C4                 int     2Eh             ; DOS 2+ internal - EXECUTE COMMAND</span><br><span class="line">.text:77F070C4                                         ; DS:SI -&gt; counted CR-terminated command string</span><br><span class="line">.text:77F070C6                 retn</span><br><span class="line">.text:77F070C6 KiIntSystemCall endp</span><br></pre></td></tr></table></figure><p>就2行，把当前函数参数地址存到edx，我们之前往eax存了个内核函数编号，直接通过中断门进入内核。    </p><h2 id="当CPU支持快速调用时候"><a href="#当CPU支持快速调用时候" class="headerlink" title="当CPU支持快速调用时候"></a>当CPU支持快速调用时候</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text:77F070B0 KiFastSystemCall proc near              ; DATA XREF: .text:off_77EF61B8o</span><br><span class="line">.text:77F070B0                 mov     edx, esp</span><br><span class="line">.text:77F070B2                 sysenter</span><br></pre></td></tr></table></figure><p>edx是参数，eax还是编号，没用中断门了，用的sysenter</p><h3 id="为什么叫快速调用？"><a href="#为什么叫快速调用？" class="headerlink" title="为什么叫快速调用？"></a>为什么叫快速调用？</h3><p>中断门进0环，需要的CS、EIP在IDT表中，需要查内存(SS与ESP由TSS提供)，比较慢<br>而CPU如果支持sysenter指令时，操作系统会提前将CS/SS/ESP/EIP的值存储在MSR寄存器中，sysenter指令执行时，CPU会将MSR寄存器中的值直接写入相关<br>寄存器，没有读内存的过程，所以叫快速调用，本质是一样的！</p><h2 id="中断门-INT-0x2E进0环"><a href="#中断门-INT-0x2E进0环" class="headerlink" title="中断门 INT 0x2E进0环"></a>中断门 INT 0x2E进0环</h2><p>步骤一：在IDT表中找到0x2E号门描述符</p><p>步骤二：分析CS/SS/ESP/EIP的来源</p><p>步骤三：分析EIP是什么</p><p>所以做如下实验：   </p><p>通过windbg先查看IDT表，然后找到2Eh也就是第46项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dq 80b95400 l40</span><br><span class="line">80b95400  83e48e00`00080fc0 83e48e00`00081150</span><br><span class="line">80b95410  00008500`00580000 83e4ee00`000815c0</span><br><span class="line">80b95420  83e4ee00`00081748 83e48e00`000818a8</span><br><span class="line">80b95430  83e48e00`00081a1c 83e48e00`00082018</span><br><span class="line">80b95440  00008500`00500000 83e48e00`00082478</span><br><span class="line">80b95450  83e48e00`0008259c 83e48e00`000826dc</span><br><span class="line">80b95460  83e48e00`0008293c 83e48e00`00082c2c</span><br><span class="line">80b95470  83e48e00`000832fc 83e48e00`000836b0</span><br><span class="line">80b95480  83e48e00`000837d4 83e48e00`00083914</span><br><span class="line">80b95490  00008500`00a00000 83e48e00`00083a80</span><br><span class="line">80b954a0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954b0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954c0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954d0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954e0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954f0  83e48e00`000836b0 84228e00`0008eaf8</span><br><span class="line">80b95500  00000000`00080000 00000000`00080000</span><br><span class="line">80b95510  00000000`00080000 00000000`00080000</span><br><span class="line">80b95520  00000000`00080000 00000000`00080000</span><br><span class="line">80b95530  00000000`00080000 00000000`00080000</span><br><span class="line">80b95540  00000000`00080000 00000000`00080000</span><br><span class="line">80b95550  83e4ee00`0008063a 83e4ee00`000807c0</span><br><span class="line">80b95560  83e4ee00`000808fc 83e4ee00`00081498</span><br><span class="line">80b95570  83e3ee00`0008ffee 83e48e00`000836b0</span><br><span class="line">80b95580  83e38e00`0008f6b0 83e38e00`0008f6ba</span><br><span class="line">80b95590  83e38e00`0008f6c4 83e38e00`0008f6ce</span><br><span class="line">80b955a0  83e38e00`0008f6d8 83e38e00`0008f6e2</span><br><span class="line">80b955b0  83e38e00`0008f6ec 84228e00`0008e104</span><br><span class="line">80b955c0  83e38e00`0008f700 83e38e00`0008f70a</span><br><span class="line">80b955d0  83e38e00`0008f714 83e38e00`0008f71e</span><br><span class="line">80b955e0  83e38e00`0008f728 83e38e00`0008f732</span><br><span class="line">80b955f0  83e38e00`0008f73c 83e38e00`0008f746</span><br></pre></td></tr></table></figure></p><p>所以通过中断门进入0环就是83e3ee00`0008ffee，</p><p>根据描述符，是中断门，代码段选择子cs是0008，要执行的EIP是前后2字节83e3ffee,ss,esp由TSS得的，下面分析进入0环时候，代码从哪开始执行，用U可以对地址反汇编。<br>所以通过中断门进入0环要执行的函数是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; u 83e3ffee</span><br><span class="line">nt!KiSystemService://nt,所以是真正的内核模块了</span><br><span class="line">83e3ffee 6a00            push    0</span><br><span class="line">83e3fff0 55              push    ebp</span><br><span class="line">83e3fff1 53              push    ebx</span><br><span class="line">83e3fff2 56              push    esi</span><br><span class="line">83e3fff3 57              push    edi</span><br><span class="line">83e3fff4 0fa0            push    fs</span><br><span class="line">83e3fff6 bb30000000      mov     ebx,30h</span><br><span class="line">83e3fffb 668ee3          mov     fs,bx</span><br></pre></td></tr></table></figure><h2 id="sysenter进0环"><a href="#sysenter进0环" class="headerlink" title="sysenter进0环"></a>sysenter进0环</h2><p>因为通过sysenter进0环省略查找IDT，TSS表的步骤，所以快，所以这些信息在执行sysenter指令之前，操作系统必须指定0环的CS段、SS段、EIP以及ESP，存在MSR寄存器里<br>MSR | 地址<br>—|—<br>IA32_SYSENTER_CS | 174H<br>IA32_SYSENTER_ESP | 175H<br>IA32_SYSENTER_EIP|176H</p><p>可以通过RDMSR/WRMST来进行读写（操作系统使用WRMST写该寄存器）:</p><p>kd&gt; rdmsr 174   //查看CS，cs+8就是ss选择子<br>kd&gt; rdmsr 175   //查看ESP<br>kd&gt; rdmsr 176   //查看EIP   </p><p>参考：Intel白皮书第二卷(搜索sysenter)<br>这些都是硬件CPU做的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; rdmsr 174</span><br><span class="line">msr[174] = 00000000`00000008</span><br><span class="line">kd&gt; rdmst 175</span><br><span class="line">        ^ Bad register error in &apos;rdmst 175&apos;</span><br><span class="line">kd&gt; rdmsr 175</span><br><span class="line">msr[175] = 00000000`80792000</span><br><span class="line">kd&gt; rdmsr 176</span><br><span class="line">msr[176] = 00000000`83e400c0</span><br><span class="line">kd&gt; u 83e400c0</span><br><span class="line">nt!KiFastCallEntry:</span><br><span class="line">83e400c0 b923000000      mov     ecx,23h</span><br><span class="line">83e400c5 6a30            push    30h</span><br><span class="line">83e400c7 0fa1            pop     fs</span><br><span class="line">83e400c9 8ed9            mov     ds,cx</span><br><span class="line">83e400cb 8ec1            mov     es,cx</span><br><span class="line">83e400cd 648b0d40000000  mov     ecx,dword ptr fs:[40h]</span><br><span class="line">83e400d4 8b6104          mov     esp,dword ptr [ecx+4]</span><br><span class="line">83e400d7 6a23            push    23h</span><br></pre></td></tr></table></figure><p>根据查看通过sysenter进入0环，用的函数是KiFastCallEntry   </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>API通过中断门进0环：</p><pre><code>1)  固定中断号为0x2E2)  CS/EIP由门描述符提供   ESP/SS由TSS提供3)  进入0环后执行的内核函数：NT!KiSystemService</code></pre><p>API通过sysenter指令进0环：</p><pre><code>1)  CS/ESP/EIP由MSR寄存器提供(SS是算出来的)2)  进入0环后执行的内核函数：NT!KiFastCallEntry</code></pre><p>内核模块：ntoskrnl.exe/ntkrnlpa.exe   </p><h3 id="1、自己实现通过中断门直接调用内核函数。"><a href="#1、自己实现通过中断门直接调用内核函数。" class="headerlink" title="1、自己实现通过中断门直接调用内核函数。"></a>1、自己实现通过中断门直接调用内核函数。</h3><p>Call XXXXEE000008XXXX//xxxx是内核函数地址偏移，让Eax等于调用号，然后调KiSystemService和KiFastCallEntry，E是构造了个1110，是p位有效，11是3环就能访问我，0是系统段。   </p><h1 id="进0环后，原来的寄存器存在哪里？"><a href="#进0环后，原来的寄存器存在哪里？" class="headerlink" title="进0环后，原来的寄存器存在哪里？"></a>进0环后，原来的寄存器存在哪里？</h1><p>拿KiSystemService举例。<br>首先要认识几个结构体：<br>Trap_Frame结构：<br>不论通过中断门和快速调用进入0环，所有寄存器都存这。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _Ktrap_frame</span><br><span class="line">ntdll!_KTRAP_FRAME</span><br><span class="line">   +0x000 DbgEbp           : Uint4B</span><br><span class="line">   +0x004 DbgEip           : Uint4B</span><br><span class="line">   +0x008 DbgArgMark       : Uint4B</span><br><span class="line">   +0x00c DbgArgPointer    : Uint4B</span><br><span class="line">   +0x010 TempSegCs        : Uint2B</span><br><span class="line">   +0x012 Logging          : UChar</span><br><span class="line">   +0x013 Reserved         : UChar</span><br><span class="line">   +0x014 TempEsp          : Uint4B</span><br><span class="line">   +0x018 Dr0              : Uint4B</span><br><span class="line">   +0x01c Dr1              : Uint4B</span><br><span class="line">   +0x020 Dr2              : Uint4B</span><br><span class="line">   +0x024 Dr3              : Uint4B</span><br><span class="line">   +0x028 Dr6              : Uint4B</span><br><span class="line">   +0x02c Dr7              : Uint4B</span><br><span class="line">   +0x030 SegGs            : Uint4B</span><br><span class="line">   +0x034 SegEs            : Uint4B</span><br><span class="line">   +0x038 SegDs            : Uint4B</span><br><span class="line">   +0x03c Edx              : Uint4B</span><br><span class="line">   +0x040 Ecx              : Uint4B</span><br><span class="line">   +0x044 Eax              : Uint4B</span><br><span class="line">   +0x048 PreviousPreviousMode : Uint4B</span><br><span class="line">   +0x04c ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x050 SegFs            : Uint4B</span><br><span class="line">   +0x054 Edi              : Uint4B</span><br><span class="line">   +0x058 Esi              : Uint4B</span><br><span class="line">   +0x05c Ebx              : Uint4B</span><br><span class="line">   +0x060 Ebp              : Uint4B</span><br><span class="line">   +0x064 ErrCode          : Uint4B</span><br><span class="line">   +0x068 Eip              : Uint4B</span><br><span class="line">   +0x06c SegCs            : Uint4B</span><br><span class="line">   +0x070 EFlags           : Uint4B</span><br><span class="line">   +0x074 HardwareEsp      : Uint4B</span><br><span class="line">   +0x078 HardwareSegSs    : Uint4B</span><br><span class="line">   +0x07c V86Es            : Uint4B</span><br><span class="line">   +0x080 V86Ds            : Uint4B</span><br><span class="line">   +0x084 V86Fs            : Uint4B</span><br><span class="line">   +0x088 V86Gs            : Uint4B</span><br></pre></td></tr></table></figure><p>ETHREAD线程相关的结构体。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x200 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x208 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x208 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x210 ExitStatus       : Int4B</span><br><span class="line">   +0x214 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x214 ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   +0x218 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x21c TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x21c ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x21c KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x220 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x224 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x22c Cid              : _CLIENT_ID</span><br><span class="line">   +0x234 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x234 AlpcWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x248 ClientSecurity   : _PS_CLIENT_SECURITY_CONTEXT</span><br><span class="line">   +0x24c IrpList          : _LIST_ENTRY</span><br><span class="line">   +0x254 TopLevelIrp      : Uint4B</span><br><span class="line">   +0x258 DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x25c CpuQuotaApc      : Ptr32 _PSP_CPU_QUOTA_APC</span><br><span class="line">   +0x260 Win32StartAddress : Ptr32 Void</span><br><span class="line">   +0x264 LegacyPowerObject : Ptr32 Void</span><br><span class="line">   +0x268 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x270 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x274 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +0x278 ReadClusterSize  : Uint4B</span><br><span class="line">   +0x27c MmLockOrdering   : Int4B</span><br><span class="line">   +0x280 CrossThreadFlags : Uint4B</span><br><span class="line">   +0x280 Terminated       : Pos 0, 1 Bit</span><br><span class="line">   +0x280 ThreadInserted   : Pos 1, 1 Bit</span><br><span class="line">   +0x280 HideFromDebugger : Pos 2, 1 Bit</span><br><span class="line">   +0x280 ActiveImpersonationInfo : Pos 3, 1 Bit</span><br><span class="line">   +0x280 Reserved         : Pos 4, 1 Bit</span><br><span class="line">   +0x280 HardErrorsAreDisabled : Pos 5, 1 Bit</span><br><span class="line">   +0x280 BreakOnTermination : Pos 6, 1 Bit</span><br><span class="line">   +0x280 SkipCreationMsg  : Pos 7, 1 Bit</span><br><span class="line">   +0x280 SkipTerminationMsg : Pos 8, 1 Bit</span><br><span class="line">   +0x280 CopyTokenOnOpen  : Pos 9, 1 Bit</span><br><span class="line">   +0x280 ThreadIoPriority : Pos 10, 3 Bits</span><br><span class="line">   +0x280 ThreadPagePriority : Pos 13, 3 Bits</span><br><span class="line">   +0x280 RundownFail      : Pos 16, 1 Bit</span><br><span class="line">   +0x280 NeedsWorkingSetAging : Pos 17, 1 Bit</span><br><span class="line">   +0x284 SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +0x284 ActiveExWorker   : Pos 0, 1 Bit</span><br><span class="line">   +0x284 ExWorkerCanWaitUser : Pos 1, 1 Bit</span><br><span class="line">   +0x284 MemoryMaker      : Pos 2, 1 Bit</span><br><span class="line">   +0x284 ClonedThread     : Pos 3, 1 Bit</span><br><span class="line">   +0x284 KeyedEventInUse  : Pos 4, 1 Bit</span><br><span class="line">   +0x284 RateApcState     : Pos 5, 2 Bits</span><br><span class="line">   +0x284 SelfTerminate    : Pos 7, 1 Bit</span><br><span class="line">   +0x288 SameThreadApcFlags : Uint4B</span><br><span class="line">   +0x288 Spare            : Pos 0, 1 Bit</span><br><span class="line">   +0x288 StartAddressInvalid : Pos 1, 1 Bit</span><br><span class="line">   +0x288 EtwPageFaultCalloutActive : Pos 2, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetExclusive : Pos 3, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetShared : Pos 4, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetExclusive : Pos 5, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetShared : Pos 6, 1 Bit</span><br><span class="line">   +0x288 OwnsSessionWorkingSetExclusive : Pos 7, 1 Bit</span><br><span class="line">   +0x289 OwnsSessionWorkingSetShared : Pos 0, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceExclusive : Pos 1, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceShared : Pos 2, 1 Bit</span><br><span class="line">   +0x289 SuppressSymbolLoad : Pos 3, 1 Bit</span><br><span class="line">   +0x289 Prefetching      : Pos 4, 1 Bit</span><br><span class="line">   +0x289 OwnsDynamicMemoryShared : Pos 5, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaExclusive : Pos 6, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaShared : Pos 7, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetExclusive : Pos 0, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetShared : Pos 1, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetExclusive : Pos 2, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetShared : Pos 3, 1 Bit</span><br><span class="line">   +0x28a TrimTrigger      : Pos 4, 2 Bits</span><br><span class="line">   +0x28a Spare1           : Pos 6, 2 Bits</span><br><span class="line">   +0x28b PriorityRegionActive : UChar</span><br><span class="line">   +0x28c CacheManagerActive : UChar</span><br><span class="line">   +0x28d DisablePageFaultClustering : UChar</span><br><span class="line">   +0x28e ActiveFaultCount : UChar</span><br><span class="line">   +0x28f LockOrderState   : UChar</span><br><span class="line">   +0x290 AlpcMessageId    : Uint4B</span><br><span class="line">   +0x294 AlpcMessage      : Ptr32 Void</span><br><span class="line">   +0x294 AlpcReceiveAttributeSet : Uint4B</span><br><span class="line">   +0x298 AlpcWaitListEntry : _LIST_ENTRY</span><br><span class="line">   +0x2a0 CacheManagerCount : Uint4B</span><br><span class="line">   +0x2a4 IoBoostCount     : Uint4B</span><br><span class="line">   +0x2a8 IrpListLock      : Uint4B</span><br><span class="line">   +0x2ac ReservedForSynchTracking : Ptr32 Void</span><br><span class="line">   +0x2b0 CmCallbackListHead : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p>上面的结构体有个相对比较重要的结构体，KTHREAD如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   上面这个可以拆解会用到03DebugActive</span><br><span class="line">   </span><br><span class="line">   kd&gt; dt _DISPATCHER_HEADER</span><br><span class="line">ntdll!_DISPATCHER_HEADER</span><br><span class="line">   +0x000 Type             : UChar</span><br><span class="line">   +0x001 TimerControlFlags : UChar</span><br><span class="line">   +0x001 Absolute         : Pos 0, 1 Bit</span><br><span class="line">   +0x001 Coalescable      : Pos 1, 1 Bit</span><br><span class="line">   +0x001 KeepShifting     : Pos 2, 1 Bit</span><br><span class="line">   +0x001 EncodedTolerableDelay : Pos 3, 5 Bits</span><br><span class="line">   +0x001 Abandoned        : UChar</span><br><span class="line">   +0x001 Signalling       : UChar</span><br><span class="line">   +0x002 ThreadControlFlags : UChar</span><br><span class="line">   +0x002 CpuThrottled     : Pos 0, 1 Bit</span><br><span class="line">   +0x002 CycleProfiling   : Pos 1, 1 Bit</span><br><span class="line">   +0x002 CounterProfiling : Pos 2, 1 Bit</span><br><span class="line">   +0x002 Reserved         : Pos 3, 5 Bits</span><br><span class="line">   +0x002 Hand             : UChar</span><br><span class="line">   +0x002 Size             : UChar</span><br><span class="line">   +0x003 TimerMiscFlags   : UChar</span><br><span class="line">   +0x003 Index            : Pos 0, 1 Bit</span><br><span class="line">   +0x003 Processor        : Pos 1, 5 Bits</span><br><span class="line">   +0x003 Inserted         : Pos 6, 1 Bit</span><br><span class="line">   +0x003 Expired          : Pos 7, 1 Bit</span><br><span class="line">   +0x003 DebugActive      : UChar</span><br><span class="line">   +0x003 ActiveDR7        : Pos 0, 1 Bit</span><br><span class="line">   +0x003 Instrumented     : Pos 1, 1 Bit</span><br><span class="line">   +0x003 Reserved2        : Pos 2, 4 Bits</span><br><span class="line">   +0x003 UmsScheduled     : Pos 6, 1 Bit</span><br><span class="line">   +0x003 UmsPrimary       : Pos 7, 1 Bit</span><br><span class="line">   +0x003 DpcActive        : UChar</span><br><span class="line">   +0x000 Lock             : Int4B</span><br><span class="line">   +0x004 SignalState      : Int4B</span><br><span class="line">   +0x008 WaitListHead     : _LIST_ENTRY</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   +0x010 CycleTime        : Uint8B</span><br><span class="line">   +0x018 HighCycleTime    : Uint4B</span><br><span class="line">   +0x020 QuantumTarget    : Uint8B</span><br><span class="line">   +0x028 InitialStack     : Ptr32 Void</span><br><span class="line">   +0x02c StackLimit       : Ptr32 Void</span><br><span class="line">   +0x030 KernelStack      : Ptr32 Void</span><br><span class="line">   +0x034 ThreadLock       : Uint4B</span><br><span class="line">   +0x038 WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   +0x039 Running          : UChar</span><br><span class="line">   +0x03a Alerted          : [2] UChar</span><br><span class="line">   +0x03c KernelStackResident : Pos 0, 1 Bit</span><br><span class="line">   +0x03c ReadyTransition  : Pos 1, 1 Bit</span><br><span class="line">   +0x03c ProcessReadyQueue : Pos 2, 1 Bit</span><br><span class="line">   +0x03c WaitNext         : Pos 3, 1 Bit</span><br><span class="line">   +0x03c SystemAffinityActive : Pos 4, 1 Bit</span><br><span class="line">   +0x03c Alertable        : Pos 5, 1 Bit</span><br><span class="line">   +0x03c GdiFlushActive   : Pos 6, 1 Bit</span><br><span class="line">   +0x03c UserStackWalkActive : Pos 7, 1 Bit</span><br><span class="line">   +0x03c ApcInterruptRequest : Pos 8, 1 Bit</span><br><span class="line">   +0x03c ForceDeferSchedule : Pos 9, 1 Bit</span><br><span class="line">   +0x03c QuantumEndMigrate : Pos 10, 1 Bit</span><br><span class="line">   +0x03c UmsDirectedSwitchEnable : Pos 11, 1 Bit</span><br><span class="line">   +0x03c TimerActive      : Pos 12, 1 Bit</span><br><span class="line">   +0x03c SystemThread     : Pos 13, 1 Bit</span><br><span class="line">   +0x03c Reserved         : Pos 14, 18 Bits</span><br><span class="line">   +0x03c MiscFlags        : Int4B</span><br><span class="line">   +0x040 ApcState         : _KAPC_STATE</span><br><span class="line">   +0x040 ApcStateFill     : [23] UChar</span><br><span class="line">   +0x057 Priority         : Char</span><br><span class="line">   +0x058 NextProcessor    : Uint4B</span><br><span class="line">   +0x05c DeferredProcessor : Uint4B</span><br><span class="line">   +0x060 ApcQueueLock     : Uint4B</span><br><span class="line">   +0x064 ContextSwitches  : Uint4B</span><br><span class="line">   +0x068 State            : UChar</span><br><span class="line">   +0x069 NpxState         : Char</span><br><span class="line">   +0x06a WaitIrql         : UChar</span><br><span class="line">   +0x06b WaitMode         : Char</span><br><span class="line">   +0x06c WaitStatus       : Int4B</span><br><span class="line">   +0x070 WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   +0x074 WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   +0x074 SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x07c Queue            : Ptr32 _KQUEUE</span><br><span class="line">   +0x080 WaitTime         : Uint4B</span><br><span class="line">   +0x084 KernelApcDisable : Int2B</span><br><span class="line">   +0x086 SpecialApcDisable : Int2B</span><br><span class="line">   +0x084 CombinedApcDisable : Uint4B</span><br><span class="line">   +0x088 Teb              : Ptr32 Void</span><br><span class="line">   +0x090 Timer            : _KTIMER</span><br><span class="line">   +0x0b8 AutoAlignment    : Pos 0, 1 Bit</span><br><span class="line">   +0x0b8 DisableBoost     : Pos 1, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc1Inserted : Pos 2, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc2Inserted : Pos 3, 1 Bit</span><br><span class="line">   +0x0b8 CalloutActive    : Pos 4, 1 Bit</span><br><span class="line">   +0x0b8 ApcQueueable     : Pos 5, 1 Bit</span><br><span class="line">   +0x0b8 EnableStackSwap  : Pos 6, 1 Bit</span><br><span class="line">   +0x0b8 GuiThread        : Pos 7, 1 Bit</span><br><span class="line">   +0x0b8 UmsPerformingSyscall : Pos 8, 1 Bit</span><br><span class="line">   +0x0b8 VdmSafe          : Pos 9, 1 Bit</span><br><span class="line">   +0x0b8 UmsDispatched    : Pos 10, 1 Bit</span><br><span class="line">   +0x0b8 ReservedFlags    : Pos 11, 21 Bits</span><br><span class="line">   +0x0b8 ThreadFlags      : Int4B</span><br><span class="line">   +0x0bc ServiceTable     : Ptr32 Void</span><br><span class="line">   +0x0c0 WaitBlock        : [4] _KWAIT_BLOCK</span><br><span class="line">   +0x120 QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   +0x128 TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   +0x12c FirstArgument    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackStack    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackDepth    : Uint4B</span><br><span class="line">   +0x134 ApcStateIndex    : UChar</span><br><span class="line">   +0x135 BasePriority     : Char</span><br><span class="line">   +0x136 PriorityDecrement : Char</span><br><span class="line">   +0x136 ForegroundBoost  : Pos 0, 4 Bits</span><br><span class="line">   +0x136 UnusualBoost     : Pos 4, 4 Bits</span><br><span class="line">   +0x137 Preempted        : UChar</span><br><span class="line">   +0x138 AdjustReason     : UChar</span><br><span class="line">   +0x139 AdjustIncrement  : Char</span><br><span class="line">   +0x13a PreviousMode     : Char</span><br><span class="line">   +0x13b Saturation       : Char</span><br><span class="line">   +0x13c SystemCallNumber : Uint4B</span><br><span class="line">   +0x140 FreezeCount      : Uint4B</span><br><span class="line">   +0x144 UserAffinity     : _GROUP_AFFINITY</span><br><span class="line">   +0x150 Process          : Ptr32 _KPROCESS</span><br><span class="line">   +0x154 Affinity         : _GROUP_AFFINITY</span><br><span class="line">   +0x160 IdealProcessor   : Uint4B</span><br><span class="line">   +0x164 UserIdealProcessor : Uint4B</span><br><span class="line">   +0x168 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcState    : _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcStateFill : [23] UChar</span><br><span class="line">   +0x187 WaitReason       : UChar</span><br><span class="line">   +0x188 SuspendCount     : Char</span><br><span class="line">   +0x189 Spare1           : Char</span><br><span class="line">   +0x18a OtherPlatformFill : UChar</span><br><span class="line">   +0x18c Win32Thread      : Ptr32 Void</span><br><span class="line">   +0x190 StackBase        : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApc       : _KAPC</span><br><span class="line">   +0x194 SuspendApcFill0  : [1] UChar</span><br><span class="line">   +0x195 ResourceIndex    : UChar</span><br><span class="line">   +0x194 SuspendApcFill1  : [3] UChar</span><br><span class="line">   +0x197 QuantumReset     : UChar</span><br><span class="line">   +0x194 SuspendApcFill2  : [4] UChar</span><br><span class="line">   +0x198 KernelTime       : Uint4B</span><br><span class="line">   +0x194 SuspendApcFill3  : [36] UChar</span><br><span class="line">   +0x1b8 WaitPrcb         : Ptr32 _KPRCB</span><br><span class="line">   +0x194 SuspendApcFill4  : [40] UChar</span><br><span class="line">   +0x1bc LegoData         : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApcFill5  : [47] UChar</span><br><span class="line">   +0x1c3 LargeStack       : UChar</span><br><span class="line">   +0x1c4 UserTime         : Uint4B</span><br><span class="line">   +0x1c8 SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1c8 SuspendSemaphorefill : [20] UChar</span><br><span class="line">   +0x1dc SListFaultCount  : Uint4B</span><br><span class="line">   +0x1e0 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x1e8 MutantListHead   : _LIST_ENTRY</span><br><span class="line">   +0x1f0 SListFaultAddress : Ptr32 Void</span><br><span class="line">   +0x1f4 ThreadCounters   : Ptr32 _KTHREAD_COUNTERS</span><br><span class="line">   +0x1f8 XStateSave       : Ptr32 _XSTATE_SAVE</span><br></pre></td></tr></table></figure><p>线程有一个结构体描述他的状态如上，CPU也有是PCR<br>即CPU控制区（Process Control Region）<br>CPU也有自己的控制块，每一个CPU有一个，叫KPCR，有几个核就几个<br>查看CPU数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeNumberProcessors</span><br><span class="line">83f6c96c  00000001 83ef8f33 00000002 00000001</span><br><span class="line">83f6c97c  00000000 00000000 00000020 1fc10000</span><br><span class="line">83f6c98c  00110006 00003c03 77ab7058 77ab6f58</span><br><span class="line">83f6c99c  77ab6fc0 77ab7008 77aa5a8f 77aa5a8d</span><br><span class="line">83f6c9ac  77aa5a64 00000000 00c671e3 841c55b0</span><br><span class="line">83f6c9bc  8412f4f2 83e80d9c 00000000 00000191</span><br><span class="line">83f6c9cc  83e813e4 00000000 00000000 00000000</span><br><span class="line">83f6c9dc  00000000 83edf6af 00000000 025355a9</span><br></pre></td></tr></table></figure><p>还可以通过下面命令查看当前的KPCR存在哪，有几核就几个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiProcessorBlock L8//显示一个说明单核</span><br><span class="line">83f6c8c0  83f2dd20 00000000 00000000 00000000</span><br><span class="line">83f6c8d0  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dt _KPCR</span><br><span class="line">ntdll!_KPCR</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x000 Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 Used_StackBase   : Ptr32 Void</span><br><span class="line">   +0x008 Spare2           : Ptr32 Void</span><br><span class="line">   +0x00c TssCopy          : Ptr32 Void</span><br><span class="line">   +0x010 ContextSwitches  : Uint4B</span><br><span class="line">   +0x014 SetMemberCopy    : Uint4B</span><br><span class="line">   +0x018 Used_Self        : Ptr32 Void</span><br><span class="line">   +0x01c SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +0x020 Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +0x024 Irql             : UChar</span><br><span class="line">   +0x028 IRR              : Uint4B</span><br><span class="line">   +0x02c IrrActive        : Uint4B</span><br><span class="line">   +0x030 IDR              : Uint4B</span><br><span class="line">   +0x034 KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +0x038 IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : Ptr32 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : Uint2B</span><br><span class="line">   +0x046 MinorVersion     : Uint2B</span><br><span class="line">   +0x048 SetMember        : Uint4B</span><br><span class="line">   +0x04c StallScaleFactor : Uint4B</span><br><span class="line">   +0x050 SpareUnused      : UChar</span><br><span class="line">   +0x051 Number           : UChar</span><br><span class="line">   +0x052 Spare0           : UChar</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +0x054 VdmAlert         : Uint4B</span><br><span class="line">   +0x058 KernelReserved   : [14] Uint4B</span><br><span class="line">   +0x090 SecondLevelCacheSize : Uint4B</span><br><span class="line">   +0x094 HalReserved      : [16] Uint4B</span><br><span class="line">   +0x0d4 InterruptMode    : Uint4B</span><br><span class="line">   +0x0d8 Spare1           : UChar</span><br><span class="line">   +0x0dc KernelReserved2  : [17] Uint4B</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br></pre></td></tr></table></figure><p>最后一个_KPRCB结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPRCB</span><br><span class="line">ntdll!_KPRCB</span><br><span class="line">   +0x000 MinorVersion     : Uint2B</span><br><span class="line">   +0x002 MajorVersion     : Uint2B</span><br><span class="line">   +0x004 CurrentThread    : Ptr32 _KTHREAD</span><br><span class="line">   +0x008 NextThread       : Ptr32 _KTHREAD</span><br><span class="line">   +0x00c IdleThread       : Ptr32 _KTHREAD</span><br><span class="line">   +0x010 LegacyNumber     : UChar</span><br><span class="line">   +0x011 NestingLevel     : UChar</span><br><span class="line">   +0x012 BuildType        : Uint2B</span><br><span class="line">   +0x014 CpuType          : Char</span><br><span class="line">   +0x015 CpuID            : Char</span><br><span class="line">   +0x016 CpuStep          : Uint2B</span><br><span class="line">   +0x016 CpuStepping      : UChar</span><br><span class="line">   +0x017 CpuModel         : UChar</span><br><span class="line">   +0x018 ProcessorState   : _KPROCESSOR_STATE</span><br><span class="line">   +0x338 KernelReserved   : [16] Uint4B</span><br><span class="line">   +0x378 HalReserved      : [16] Uint4B</span><br><span class="line">   +0x3b8 CFlushSize       : Uint4B</span><br><span class="line">   +0x3bc CoresPerPhysicalProcessor : UChar</span><br><span class="line">   +0x3bd LogicalProcessorsPerCore : UChar</span><br><span class="line">   +0x3be PrcbPad0         : [2] UChar</span><br><span class="line">   +0x3c0 MHz              : Uint4B</span><br><span class="line">   +0x3c4 CpuVendor        : UChar</span><br><span class="line">   +0x3c5 GroupIndex       : UChar</span><br><span class="line">   +0x3c6 Group            : Uint2B</span><br><span class="line">   +0x3c8 GroupSetMember   : Uint4B</span><br><span class="line">   +0x3cc Number           : Uint4B</span><br><span class="line">   +0x3d0 PrcbPad1         : [72] UChar</span><br><span class="line">   +0x418 LockQueue        : [17] _KSPIN_LOCK_QUEUE</span><br><span class="line">   +0x4a0 NpxThread        : Ptr32 _KTHREAD</span><br><span class="line">   +0x4a4 InterruptCount   : Uint4B</span><br><span class="line">   +0x4a8 KernelTime       : Uint4B</span><br><span class="line">   +0x4ac UserTime         : Uint4B</span><br><span class="line">   +0x4b0 DpcTime          : Uint4B</span><br><span class="line">   +0x4b4 DpcTimeCount     : Uint4B</span><br><span class="line">   +0x4b8 InterruptTime    : Uint4B</span><br><span class="line">   +0x4bc AdjustDpcThreshold : Uint4B</span><br><span class="line">   +0x4c0 PageColor        : Uint4B</span><br><span class="line">   +0x4c4 DebuggerSavedIRQL : UChar</span><br><span class="line">   +0x4c5 NodeColor        : UChar</span><br><span class="line">   +0x4c6 PrcbPad20        : [2] UChar</span><br><span class="line">   +0x4c8 NodeShiftedColor : Uint4B</span><br><span class="line">   +0x4cc ParentNode       : Ptr32 _KNODE</span><br><span class="line">   +0x4d0 SecondaryColorMask : Uint4B</span><br><span class="line">   +0x4d4 DpcTimeLimit     : Uint4B</span><br><span class="line">   +0x4d8 PrcbPad21        : [2] Uint4B</span><br><span class="line">   +0x4e0 CcFastReadNoWait : Uint4B</span><br><span class="line">   +0x4e4 CcFastReadWait   : Uint4B</span><br><span class="line">   +0x4e8 CcFastReadNotPossible : Uint4B</span><br><span class="line">   +0x4ec CcCopyReadNoWait : Uint4B</span><br><span class="line">   +0x4f0 CcCopyReadWait   : Uint4B</span><br><span class="line">   +0x4f4 CcCopyReadNoWaitMiss : Uint4B</span><br><span class="line">   +0x4f8 MmSpinLockOrdering : Int4B</span><br><span class="line">   +0x4fc IoReadOperationCount : Int4B</span><br><span class="line">   +0x500 IoWriteOperationCount : Int4B</span><br><span class="line">   +0x504 IoOtherOperationCount : Int4B</span><br><span class="line">   +0x508 IoReadTransferCount : _LARGE_INTEGER</span><br><span class="line">   +0x510 IoWriteTransferCount : _LARGE_INTEGER</span><br><span class="line">   +0x518 IoOtherTransferCount : _LARGE_INTEGER</span><br><span class="line">   +0x520 CcFastMdlReadNoWait : Uint4B</span><br><span class="line">   +0x524 CcFastMdlReadWait : Uint4B</span><br><span class="line">   +0x528 CcFastMdlReadNotPossible : Uint4B</span><br><span class="line">   +0x52c CcMapDataNoWait  : Uint4B</span><br><span class="line">   +0x530 CcMapDataWait    : Uint4B</span><br><span class="line">   +0x534 CcPinMappedDataCount : Uint4B</span><br><span class="line">   +0x538 CcPinReadNoWait  : Uint4B</span><br><span class="line">   +0x53c CcPinReadWait    : Uint4B</span><br><span class="line">   +0x540 CcMdlReadNoWait  : Uint4B</span><br><span class="line">   +0x544 CcMdlReadWait    : Uint4B</span><br><span class="line">   +0x548 CcLazyWriteHotSpots : Uint4B</span><br><span class="line">   +0x54c CcLazyWriteIos   : Uint4B</span><br><span class="line">   +0x550 CcLazyWritePages : Uint4B</span><br><span class="line">   +0x554 CcDataFlushes    : Uint4B</span><br><span class="line">   +0x558 CcDataPages      : Uint4B</span><br><span class="line">   +0x55c CcLostDelayedWrites : Uint4B</span><br><span class="line">   +0x560 CcFastReadResourceMiss : Uint4B</span><br><span class="line">   +0x564 CcCopyReadWaitMiss : Uint4B</span><br><span class="line">   +0x568 CcFastMdlReadResourceMiss : Uint4B</span><br><span class="line">   +0x56c CcMapDataNoWaitMiss : Uint4B</span><br><span class="line">   +0x570 CcMapDataWaitMiss : Uint4B</span><br><span class="line">   +0x574 CcPinReadNoWaitMiss : Uint4B</span><br><span class="line">   +0x578 CcPinReadWaitMiss : Uint4B</span><br><span class="line">   +0x57c CcMdlReadNoWaitMiss : Uint4B</span><br><span class="line">   +0x580 CcMdlReadWaitMiss : Uint4B</span><br><span class="line">   +0x584 CcReadAheadIos   : Uint4B</span><br><span class="line">   +0x588 KeAlignmentFixupCount : Uint4B</span><br><span class="line">   +0x58c KeExceptionDispatchCount : Uint4B</span><br><span class="line">   +0x590 KeSystemCalls    : Uint4B</span><br><span class="line">   +0x594 AvailableTime    : Uint4B</span><br><span class="line">   +0x598 PrcbPad22        : [2] Uint4B</span><br><span class="line">   +0x5a0 PPLookasideList  : [16] _PP_LOOKASIDE_LIST</span><br><span class="line">   +0x620 PPNPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0xf20 PPPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0x1820 PacketBarrier    : Uint4B</span><br><span class="line">   +0x1824 ReverseStall     : Int4B</span><br><span class="line">   +0x1828 IpiFrame         : Ptr32 Void</span><br><span class="line">   +0x182c PrcbPad3         : [52] UChar</span><br><span class="line">   +0x1860 CurrentPacket    : [3] Ptr32 Void</span><br><span class="line">   +0x186c TargetSet        : Uint4B</span><br><span class="line">   +0x1870 WorkerRoutine    : Ptr32     void </span><br><span class="line">   +0x1874 IpiFrozen        : Uint4B</span><br><span class="line">   +0x1878 PrcbPad4         : [40] UChar</span><br><span class="line">   +0x18a0 RequestSummary   : Uint4B</span><br><span class="line">   +0x18a4 SignalDone       : Ptr32 _KPRCB</span><br><span class="line">   +0x18a8 PrcbPad50        : [56] UChar</span><br><span class="line">   +0x18e0 DpcData          : [2] _KDPC_DATA</span><br><span class="line">   +0x1908 DpcStack         : Ptr32 Void</span><br><span class="line">   +0x190c MaximumDpcQueueDepth : Int4B</span><br><span class="line">   +0x1910 DpcRequestRate   : Uint4B</span><br><span class="line">   +0x1914 MinimumDpcRate   : Uint4B</span><br><span class="line">   +0x1918 DpcLastCount     : Uint4B</span><br><span class="line">   +0x191c PrcbLock         : Uint4B</span><br><span class="line">   +0x1920 DpcGate          : _KGATE</span><br><span class="line">   +0x1930 ThreadDpcEnable  : UChar</span><br><span class="line">   +0x1931 QuantumEnd       : UChar</span><br><span class="line">   +0x1932 DpcRoutineActive : UChar</span><br><span class="line">   +0x1933 IdleSchedule     : UChar</span><br><span class="line">   +0x1934 DpcRequestSummary : Int4B</span><br><span class="line">   +0x1934 DpcRequestSlot   : [2] Int2B</span><br><span class="line">   +0x1934 NormalDpcState   : Int2B</span><br><span class="line">   +0x1936 DpcThreadActive  : Pos 0, 1 Bit</span><br><span class="line">   +0x1936 ThreadDpcState   : Int2B</span><br><span class="line">   +0x1938 TimerHand        : Uint4B</span><br><span class="line">   +0x193c LastTick         : Uint4B</span><br><span class="line">   +0x1940 MasterOffset     : Int4B</span><br><span class="line">   +0x1944 PrcbPad41        : [2] Uint4B</span><br><span class="line">   +0x194c PeriodicCount    : Uint4B</span><br><span class="line">   +0x1950 PeriodicBias     : Uint4B</span><br><span class="line">   +0x1958 TickOffset       : Uint8B</span><br><span class="line">   +0x1960 TimerTable       : _KTIMER_TABLE</span><br><span class="line">   +0x31a0 CallDpc          : _KDPC</span><br><span class="line">   +0x31c0 ClockKeepAlive   : Int4B</span><br><span class="line">   +0x31c4 ClockCheckSlot   : UChar</span><br><span class="line">   +0x31c5 ClockPollCycle   : UChar</span><br><span class="line">   +0x31c6 PrcbPad6         : [2] UChar</span><br><span class="line">   +0x31c8 DpcWatchdogPeriod : Int4B</span><br><span class="line">   +0x31cc DpcWatchdogCount : Int4B</span><br><span class="line">   +0x31d0 ThreadWatchdogPeriod : Int4B</span><br><span class="line">   +0x31d4 ThreadWatchdogCount : Int4B</span><br><span class="line">   +0x31d8 KeSpinLockOrdering : Int4B</span><br><span class="line">   +0x31dc PrcbPad70        : [1] Uint4B</span><br><span class="line">   +0x31e0 WaitListHead     : _LIST_ENTRY</span><br><span class="line">   +0x31e8 WaitLock         : Uint4B</span><br><span class="line">   +0x31ec ReadySummary     : Uint4B</span><br><span class="line">   +0x31f0 QueueIndex       : Uint4B</span><br><span class="line">   +0x31f4 DeferredReadyListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x31f8 StartCycles      : Uint8B</span><br><span class="line">   +0x3200 CycleTime        : Uint8B</span><br><span class="line">   +0x3208 HighCycleTime    : Uint4B</span><br><span class="line">   +0x320c PrcbPad71        : Uint4B</span><br><span class="line">   +0x3210 PrcbPad72        : [2] Uint8B</span><br><span class="line">   +0x3220 DispatcherReadyListHead : [32] _LIST_ENTRY</span><br><span class="line">   +0x3320 ChainedInterruptList : Ptr32 Void</span><br><span class="line">   +0x3324 LookasideIrpFloat : Int4B</span><br><span class="line">   +0x3328 MmPageFaultCount : Int4B</span><br><span class="line">   +0x332c MmCopyOnWriteCount : Int4B</span><br><span class="line">   +0x3330 MmTransitionCount : Int4B</span><br><span class="line">   +0x3334 MmCacheTransitionCount : Int4B</span><br><span class="line">   +0x3338 MmDemandZeroCount : Int4B</span><br><span class="line">   +0x333c MmPageReadCount  : Int4B</span><br><span class="line">   +0x3340 MmPageReadIoCount : Int4B</span><br><span class="line">   +0x3344 MmCacheReadCount : Int4B</span><br><span class="line">   +0x3348 MmCacheIoCount   : Int4B</span><br><span class="line">   +0x334c MmDirtyPagesWriteCount : Int4B</span><br><span class="line">   +0x3350 MmDirtyWriteIoCount : Int4B</span><br><span class="line">   +0x3354 MmMappedPagesWriteCount : Int4B</span><br><span class="line">   +0x3358 MmMappedWriteIoCount : Int4B</span><br><span class="line">   +0x335c CachedCommit     : Uint4B</span><br><span class="line">   +0x3360 CachedResidentAvailable : Uint4B</span><br><span class="line">   +0x3364 HyperPte         : Ptr32 Void</span><br><span class="line">   +0x3368 PrcbPad8         : [4] UChar</span><br><span class="line">   +0x336c VendorString     : [13] UChar</span><br><span class="line">   +0x3379 InitialApicId    : UChar</span><br><span class="line">   +0x337a LogicalProcessorsPerPhysicalProcessor : UChar</span><br><span class="line">   +0x337b PrcbPad9         : [5] UChar</span><br><span class="line">   +0x3380 FeatureBits      : Uint4B</span><br><span class="line">   +0x3388 UpdateSignature  : _LARGE_INTEGER</span><br><span class="line">   +0x3390 IsrTime          : Uint8B</span><br><span class="line">   +0x3398 RuntimeAccumulation : Uint8B</span><br><span class="line">   +0x33a0 PowerState       : _PROCESSOR_POWER_STATE</span><br><span class="line">   +0x3468 DpcWatchdogDpc   : _KDPC</span><br><span class="line">   +0x3488 DpcWatchdogTimer : _KTIMER</span><br><span class="line">   +0x34b0 WheaInfo         : Ptr32 Void</span><br><span class="line">   +0x34b4 EtwSupport       : Ptr32 Void</span><br><span class="line">   +0x34b8 InterruptObjectPool : _SLIST_HEADER</span><br><span class="line">   +0x34c0 HypercallPageList : _SLIST_HEADER</span><br><span class="line">   +0x34c8 HypercallPageVirtual : Ptr32 Void</span><br><span class="line">   +0x34cc VirtualApicAssist : Ptr32 Void</span><br><span class="line">   +0x34d0 StatisticsPage   : Ptr32 Uint8B</span><br><span class="line">   +0x34d4 RateControl      : Ptr32 Void</span><br><span class="line">   +0x34d8 Cache            : [5] _CACHE_DESCRIPTOR</span><br><span class="line">   +0x3514 CacheCount       : Uint4B</span><br><span class="line">   +0x3518 CacheProcessorMask : [5] Uint4B</span><br><span class="line">   +0x352c PackageProcessorSet : _KAFFINITY_EX</span><br><span class="line">   +0x3538 PrcbPad91        : [1] Uint4B</span><br><span class="line">   +0x353c CoreProcessorSet : Uint4B</span><br><span class="line">   +0x3540 TimerExpirationDpc : _KDPC</span><br><span class="line">   +0x3560 SpinLockAcquireCount : Uint4B</span><br><span class="line">   +0x3564 SpinLockContentionCount : Uint4B</span><br><span class="line">   +0x3568 SpinLockSpinCount : Uint4B</span><br><span class="line">   +0x356c IpiSendRequestBroadcastCount : Uint4B</span><br><span class="line">   +0x3570 IpiSendRequestRoutineCount : Uint4B</span><br><span class="line">   +0x3574 IpiSendSoftwareInterruptCount : Uint4B</span><br><span class="line">   +0x3578 ExInitializeResourceCount : Uint4B</span><br><span class="line">   +0x357c ExReInitializeResourceCount : Uint4B</span><br><span class="line">   +0x3580 ExDeleteResourceCount : Uint4B</span><br><span class="line">   +0x3584 ExecutiveResourceAcquiresCount : Uint4B</span><br><span class="line">   +0x3588 ExecutiveResourceContentionsCount : Uint4B</span><br><span class="line">   +0x358c ExecutiveResourceReleaseExclusiveCount : Uint4B</span><br><span class="line">   +0x3590 ExecutiveResourceReleaseSharedCount : Uint4B</span><br><span class="line">   +0x3594 ExecutiveResourceConvertsCount : Uint4B</span><br><span class="line">   +0x3598 ExAcqResExclusiveAttempts : Uint4B</span><br><span class="line">   +0x359c ExAcqResExclusiveAcquiresExclusive : Uint4B</span><br><span class="line">   +0x35a0 ExAcqResExclusiveAcquiresExclusiveRecursive : Uint4B</span><br><span class="line">   +0x35a4 ExAcqResExclusiveWaits : Uint4B</span><br><span class="line">   +0x35a8 ExAcqResExclusiveNotAcquires : Uint4B</span><br><span class="line">   +0x35ac ExAcqResSharedAttempts : Uint4B</span><br><span class="line">   +0x35b0 ExAcqResSharedAcquiresExclusive : Uint4B</span><br><span class="line">   +0x35b4 ExAcqResSharedAcquiresShared : Uint4B</span><br><span class="line">   +0x35b8 ExAcqResSharedAcquiresSharedRecursive : Uint4B</span><br><span class="line">   +0x35bc ExAcqResSharedWaits : Uint4B</span><br><span class="line">   +0x35c0 ExAcqResSharedNotAcquires : Uint4B</span><br><span class="line">   +0x35c4 ExAcqResSharedStarveExclusiveAttempts : Uint4B</span><br><span class="line">   +0x35c8 ExAcqResSharedStarveExclusiveAcquiresExclusive : Uint4B</span><br><span class="line">   +0x35cc ExAcqResSharedStarveExclusiveAcquiresShared : Uint4B</span><br><span class="line">   +0x35d0 ExAcqResSharedStarveExclusiveAcquiresSharedRecursive : Uint4B</span><br><span class="line">   +0x35d4 ExAcqResSharedStarveExclusiveWaits : Uint4B</span><br><span class="line">   +0x35d8 ExAcqResSharedStarveExclusiveNotAcquires : Uint4B</span><br><span class="line">   +0x35dc ExAcqResSharedWaitForExclusiveAttempts : Uint4B</span><br><span class="line">   +0x35e0 ExAcqResSharedWaitForExclusiveAcquiresExclusive : Uint4B</span><br><span class="line">   +0x35e4 ExAcqResSharedWaitForExclusiveAcquiresShared : Uint4B</span><br><span class="line">   +0x35e8 ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive : Uint4B</span><br><span class="line">   +0x35ec ExAcqResSharedWaitForExclusiveWaits : Uint4B</span><br><span class="line">   +0x35f0 ExAcqResSharedWaitForExclusiveNotAcquires : Uint4B</span><br><span class="line">   +0x35f4 ExSetResOwnerPointerExclusive : Uint4B</span><br><span class="line">   +0x35f8 ExSetResOwnerPointerSharedNew : Uint4B</span><br><span class="line">   +0x35fc ExSetResOwnerPointerSharedOld : Uint4B</span><br><span class="line">   +0x3600 ExTryToAcqExclusiveAttempts : Uint4B</span><br><span class="line">   +0x3604 ExTryToAcqExclusiveAcquires : Uint4B</span><br><span class="line">   +0x3608 ExBoostExclusiveOwner : Uint4B</span><br><span class="line">   +0x360c ExBoostSharedOwners : Uint4B</span><br><span class="line">   +0x3610 ExEtwSynchTrackingNotificationsCount : Uint4B</span><br><span class="line">   +0x3614 ExEtwSynchTrackingNotificationsAccountedCount : Uint4B</span><br><span class="line">   +0x3618 Context          : Ptr32 _CONTEXT</span><br><span class="line">   +0x361c ContextFlags     : Uint4B</span><br><span class="line">   +0x3620 ExtendedState    : Ptr32 _XSAVE_AREA</span><br></pre></td></tr></table></figure><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/7.png?x-oss-process=style/yangruiqi.com" alt="7"></p><p>最后面4个是保护模式下用不的到的，中断门在发生权限切换时候，会向0环的堆栈压入5个值，就是0x068到0x078，快速调用没有。<br>代码中push 0 ，就是0x64，errorcode，</p><p>下面是KiSystemServer的反汇编加注释，用到了上面的结构体：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">.text:0043567E _KiSystemService proc near              ; CODE XREF: ZwAcceptConnectPort(x,x,x,x,x,x)+Cp</span><br><span class="line">.text:0043567E                                         ; ZwAccessCheck(x,x,x,x,x,x,x,x)+Cp ...</span><br><span class="line">.text:0043567E</span><br><span class="line">.text:0043567E arg_0           = dword ptr  4</span><br><span class="line">.text:0043567E</span><br><span class="line">.text:0043567E                 push    0               ; _KTRAP_FRAME +0x064 ErrCode</span><br><span class="line">.text:00435680                 push    ebp             ; 0x060 Ebp,3环寄存器入栈</span><br><span class="line">.text:00435681                 push    ebx             ; 0x05C,ebx</span><br><span class="line">.text:00435682                 push    esi             ; 0x058 Esi</span><br><span class="line">.text:00435683                 push    edi             ; 0x054 Edi</span><br><span class="line">.text:00435684                 push    fs              ; 0x050 SegFs</span><br><span class="line">.text:00435686                 mov     ebx, 30h        ; 为FS寄存器赋值,30就是段选择子，在GDTR找到相应的段描述符，加载到，FS，指向KPCR结构体</span><br><span class="line">.text:0043568B                 mov     fs, bx          ; Windows内核有个特殊的基本要求，就是只要CPU在内核运行，就得使</span><br><span class="line">.text:0043568B                                         ; mov ebx,30 //0011 0000  所以就是0环GDT索引6</span><br><span class="line">.text:0043568B                                         ; mov fs,bx</span><br><span class="line">.text:0043568B                                         ;</span><br><span class="line">.text:0043568B                                         ; 0环的FS.Base指向CPU自己的KPCR，不是指向当前线程</span><br><span class="line">.text:0043568B                                         ; 选择码，0x30的结构分析如下：</span><br><span class="line">.text:0043568B                                         ; 1.bit0~bit1:RPL,Requested Privilege Level,要求运行的级别，这里是0</span><br><span class="line">.text:0043568B                                         ; 2.bit2：找GDT还是IDT，这里是0，GDT</span><br><span class="line">.text:0043568B                                         ; 3.bit3！bit15，是在GDT或者IDT的下标</span><br><span class="line">.text:0043568B                                         ; windbg查看段描述符：834093f2 dc003748</span><br><span class="line">.text:0043568B                                         ; Base:83f2dc00 指向当前的_KPCR</span><br><span class="line">.text:0043568E                 mov     ebx, 23h</span><br><span class="line">.text:00435693                 mov     ds, ebx</span><br><span class="line">.text:00435695                 mov     es, ebx</span><br><span class="line">.text:00435697                 mov     esi, large fs:124h ; 查看下KPCR偏移124h是什么，查训发现是当前CPU所执行线程的_ETHREAD</span><br><span class="line">.text:0043569E                 push    large dword ptr fs:0 ; 保存老的ExceptionList</span><br><span class="line">.text:0043569E                                         ; _KPCR偏移+0x00-&gt;NT_TIB-&gt;ExceptionList</span><br><span class="line">.text:004356A5                 mov     large dword ptr fs:0, 0FFFFFFFFh ; 新的ExceptonList为空白，因为3环的异常链表，不能用，要进0环了</span><br><span class="line">.text:004356B0                 push    dword ptr [esi+13Ah] ; 因为Esi存的_KTHREAD,他的偏移13A存的PreviousMode,</span><br><span class="line">.text:004356B0                                         ; 就是保存老的先前模式到堆栈</span><br><span class="line">.text:004356B0                                         ; 先前模式就是当调用这些代码时候，原来是几环的数就是几，比如原来0环，先前模式就是0，原来3环就是1</span><br><span class="line">.text:004356B0                                         ; 因为有些内核代码可以从0和3调用，但是执行内容不一样，通过这个知道执行什么。</span><br><span class="line">.text:004356B6                 sub     esp, 48h        ; ESP 提升到_KTRAP_FRAME结构体第一个成员，也就是这个结构体指针</span><br><span class="line">.text:004356B9                 mov     ebx, [esp+68h+arg_0] ; 查了下这个位置是3环CS</span><br><span class="line">.text:004356B9                                         ; 所以这句是取出3环压入的参数CS _KTRAP_FRAME + 0x6C</span><br><span class="line">.text:004356BD                 and     ebx, 1          ; 上面的CS跟1与运算</span><br><span class="line">.text:004356BD                                         ; 0环最低位是0,3环最低位为1</span><br><span class="line">.text:004356C0                 mov     [esi+13Ah], bl  ; 上面的运算结果存到esi+0x13Ah这个位置的偏移，就是新的&quot;先前模式&quot;</span><br><span class="line">.text:004356C6                 mov     ebp, esp        ; 抬高栈针,ebp=esp=_KTRAP_FRAME指针</span><br><span class="line">.text:004356C8                 mov     ebx, [esi+128h] ; _KTHTEAD中的TrapFrame给ebx</span><br><span class="line">.text:004356CE                 mov     [ebp+3Ch], ebx  ; 将_KTHREAD中的Trap_Frame暂时存在这个位置后面</span><br><span class="line">.text:004356CE                                         ; //会将这个值取出来，重新恢复给_KTHREAD的Trap_Frame</span><br><span class="line">.text:004356CE                                         ;</span><br><span class="line">.text:004356CE                                         ; 零时存在这</span><br><span class="line">.text:004356D1                 and     dword ptr [ebp+2Ch], 0 ; Dr7清0</span><br><span class="line">.text:004356D5                 test    byte ptr [esi+3], 0DFh ; 查看当前线程是否处于调试状态</span><br><span class="line">.text:004356D5                                         ; 看看是不是-1，</span><br><span class="line">.text:004356D9                 mov     [esi+128h], ebp ; 因为有改变堆栈中的_KTRAP_FRAME,将其重新赋值给_KTHREAD中的TRAPFRAME</span><br><span class="line">.text:004356DF                 cld</span><br><span class="line">.text:004356E0                 jnz     Dr_kss_a        ; 处于调试的话跳转,跳转那边的代码是讲调试寄存器都存到Trap_Frame里</span><br><span class="line">.text:004356E6</span><br><span class="line">.text:004356E6 loc_4356E6:                             ; CODE XREF: Dr_kss_a+Dj</span><br><span class="line">.text:004356E6                                         ; Dr_kss_a+79j</span><br><span class="line">.text:004356E6                 mov     ebx, [ebp+60h]  ; 3环的Ebx给ebx</span><br><span class="line">.text:004356E9                 mov     edi, [ebp+68h]  ; 3环的Eip</span><br><span class="line">.text:004356EC                 mov     [ebp+0Ch], edx  ; edx存的3环参数指针：</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; _kiFastSystemCall函数</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; mov edx，esp</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; sysenter</span><br><span class="line">.text:004356EF                 mov     dword ptr [ebp+8], 0BADB0D00h ; 这个是操作系统的标志</span><br><span class="line">.text:004356F6                 mov     [ebp+0], ebx    ; 3环的ebp存储到KTRAP_FRAME+0x000 DbgEbp的位置</span><br><span class="line">.text:004356F9                 mov     [ebp+4], edi    ; 3环的ebp存储到KTRAP_FRAME+0x004 DbgEip的位置</span><br><span class="line">.text:004356FC                 sti</span><br><span class="line">.text:004356FD                 jmp     loc_4357DF      ; 跳到KiFastCallEntry</span><br><span class="line">.text:004356FD _KiSystemService endp</span><br></pre></td></tr></table></figure><p>最后还是跳到了KiFastCallEntry，最后发现从两个口进来最后都要执行一样的代码</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：毛德操，《Windows内核情景分析》<br>[2]：滴水视频<br>[3]: 一大堆的别人的博客  </p>]]></content>
      
      <categories>
          
          <category> 笔记 - 系统调用笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用 </tag>
            
            <tag> 驱动学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>object_Hook相关知识</title>
      <link href="/2018/06/28/object-Hook%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/06/28/object-Hook%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h4 id="首先，分析OBJECT（内核对象）"><a href="#首先，分析OBJECT（内核对象）" class="headerlink" title="首先，分析OBJECT（内核对象）"></a>首先，分析OBJECT（内核对象）</h4><p>先找到一个进程内核对象的地址，使用!process 0 0查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROCESS 885de030  SessionId: 1  Cid: 0700    Peb: 7ffd9000  ParentCid: 0418</span><br><span class="line">    DirBase: 7f3602e0  ObjectTable: 98a8c548  HandleCount:  60.</span><br><span class="line">    Image: Commnuication_ring3.exe</span><br></pre></td></tr></table></figure><p>然后查看最后一个这个进程   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; dt _OBJECT_HEADER 885de030-18</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : 0n41</span><br><span class="line">   +0x004 HandleCount      : 0n2</span><br><span class="line">   +0x004 NextToFree       : 0x00000002 Void</span><br><span class="line">   +0x008 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x00c TypeIndex        : 0x7 &apos;&apos;</span><br><span class="line">   +0x00d TraceFlags       : 0 &apos;&apos;</span><br><span class="line">   +0x00e InfoMask         : 0x8 &apos;&apos;</span><br><span class="line">   +0x00f Flags            : 0 &apos;&apos;</span><br><span class="line">   +0x010 ObjectCreateInfo : 0x83f78cc0 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x010 QuotaBlockCharged : 0x83f78cc0 Void</span><br><span class="line">   +0x014 SecurityDescriptor : 0x8c6f64fe Void</span><br><span class="line">   +0x018 Body             : _QUAD</span><br></pre></td></tr></table></figure><p>PointerCount保存的是对象的指针计数，HandeCount保存的是对象句柄计数（也就是我们说的引用计数）<br>当我们通过API得到对象的句柄：   </p><ul><li>打开一个对象时，对象指针计数（差了下windows内核情景分析一书，这个翻译成引用计数，感觉更好一些，因为如果是引用计数，后面获得对象就不会增加句柄计数，指挥增加引用计数）与句柄计数都会被加1。   </li><li>关闭句柄的时候，对象的指针计数和句柄计数都会被减一。   </li><li>我们在内核层获得对象时，会增加其指针计数，一般我们需要通过ObDeferenceObject降低计数。   </li><li>当指针计数与句柄计数都为0，内核对象回本销毁。  </li><li>TypeIndex表示对象的类型，他是一个数组的下标，数组名叫做ObTypeIndexTable.由nt模块导出   </li></ul><p>下面查看一下ObTypeIndexTable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd ObTypeIndexTable</span><br><span class="line">83f86900  00000000 bad0b0b0 86544768 865446a0</span><br><span class="line">83f86910  865445d8 865de040 865def00 865dee38</span><br><span class="line">83f86920  865ded70 865deca8 865debe0 865de528</span><br><span class="line">83f86930  866059c8 86601418 86601350 866094d0</span><br><span class="line">83f86940  86609408 86609340 865f5de8 865f5d20</span><br><span class="line">83f86950  865f5c58 865fac90 865fabc8 865fab00</span><br><span class="line">83f86960  865faa38 865fa970 865fa8a8 865fa7e0</span><br><span class="line">83f86970  865fa718 86603f78 86603eb0 86603de8</span><br></pre></td></tr></table></figure><p>上面的对象是这个里面第七个位置的类型，查看一下，7号位置就是865dee38，他是_OBJECT_TYPE的地址。我们查看_OBJECT_TYPE的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE 865dee38</span><br><span class="line">ntdll!_OBJECT_TYPE</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY [ 0x865dee38 - 0x865dee38 ]</span><br><span class="line">   +0x008 Name             : _UNICODE_STRING &quot;Process&quot;</span><br><span class="line">   +0x010 DefaultObject    : (null) </span><br><span class="line">   +0x014 Index            : 0x7 &apos;&apos;</span><br><span class="line">   +0x018 TotalNumberOfObjects : 0x23</span><br><span class="line">   +0x01c TotalNumberOfHandles : 0xcc</span><br><span class="line">   +0x020 HighWaterNumberOfObjects : 0x2a</span><br><span class="line">   +0x024 HighWaterNumberOfHandles : 0x104</span><br><span class="line">   +0x028 TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x078 TypeLock         : _EX_PUSH_LOCK</span><br><span class="line">   +0x07c Key              : 0x636f7250</span><br><span class="line">   +0x080 CallbackList     : _LIST_ENTRY [ 0x865deeb8 - 0x865deeb8 ]</span><br></pre></td></tr></table></figure><p>接下来，我们再分析一下_OBJECT_TYPE,其中有一个TypeInfo类型是OBJECT_TYPE_INITIALIZER</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE_INITIALIZER</span><br><span class="line">ntdll!_OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x000 Length           : Uint2B</span><br><span class="line">   +0x002 ObjectTypeFlags  : UChar</span><br><span class="line">   +0x002 CaseInsensitive  : Pos 0, 1 Bit</span><br><span class="line">   +0x002 UnnamedObjectsOnly : Pos 1, 1 Bit</span><br><span class="line">   +0x002 UseDefaultObject : Pos 2, 1 Bit</span><br><span class="line">   +0x002 SecurityRequired : Pos 3, 1 Bit</span><br><span class="line">   +0x002 MaintainHandleCount : Pos 4, 1 Bit</span><br><span class="line">   +0x002 MaintainTypeList : Pos 5, 1 Bit</span><br><span class="line">   +0x002 SupportsObjectCallbacks : Pos 6, 1 Bit</span><br><span class="line">   +0x004 ObjectTypeCode   : Uint4B</span><br><span class="line">   +0x008 InvalidAttributes : Uint4B</span><br><span class="line">   +0x00c GenericMapping   : _GENERIC_MAPPING</span><br><span class="line">   +0x01c ValidAccessMask  : Uint4B</span><br><span class="line">   +0x020 RetainAccess     : Uint4B</span><br><span class="line">   +0x024 PoolType         : _POOL_TYPE</span><br><span class="line">   +0x028 DefaultPagedPoolCharge : Uint4B</span><br><span class="line">   +0x02c DefaultNonPagedPoolCharge : Uint4B</span><br><span class="line">   +0x030 DumpProcedure    : Ptr32     void </span><br><span class="line">   +0x034 OpenProcedure    : Ptr32     long </span><br><span class="line">   +0x038 CloseProcedure   : Ptr32     void </span><br><span class="line">   +0x03c DeleteProcedure  : Ptr32     void </span><br><span class="line">   +0x040 ParseProcedure   : Ptr32     long </span><br><span class="line">   +0x044 SecurityProcedure : Ptr32     long </span><br><span class="line">   +0x048 QueryNameProcedure : Ptr32     long </span><br><span class="line">   +0x04c OkayToCloseProcedure : Ptr32     unsigned char</span><br></pre></td></tr></table></figure><p>我们在内核层经常需要使用一个内核对象句柄获得内核对象，比如用户层传入一个时间对象句柄，用于分析内核层与用户层进行同步。<br>我们可以使用ObReferenceObjectByHandle函数根据句柄获得内核对象<br>注意：   </p><ul><li>当你调用这个函数时候，需要确保处于当前进程环境。   </li><li>用户模式的句柄，将AccessMode指定为userMode   </li><li>使用完毕，请调用ObDererfanceObject降低指针引用计数。   </li></ul><h1 id="下面就是相关的代码"><a href="#下面就是相关的代码" class="headerlink" title="下面就是相关的代码"></a>下面就是相关的代码</h1><p>通过内核对下头部，能够获得此类型内核对象的创建信息，在这些信息中有一组函数指针非常重要。<br>我们通过Hook这些函数指针，能够达到监控内核对象操作的目的。<br>这种Hook被称为Object-Hook，下面的代码平台是Win32<br>总得来说就是找到地址然后把在OBJECT_TYPE里OBJECT_TYPE_INITIALIZER的参数ParseProcedure替换成自己的    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT objDriver)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ULONG</span><span class="params">(*OBGETOBJECTTYPE)</span><span class="params">(PVOID Object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(*PARSEPRODECEDURE)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID ParseObject,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PVOID ObjectType,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PACCESS_STATE AccessState,</span></span></span><br><span class="line"><span class="function"><span class="params">IN KPROCESSOR_MODE AccessMode,</span></span></span><br><span class="line"><span class="function"><span class="params">IN ULONG Attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING CompleteName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING RemainingName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PVOID Context OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">OUT PVOID *Object)</span></span>;</span><br><span class="line">PARSEPRODECEDURE g_OldFun;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">NewParseProcedure</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID ParseObject,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PVOID ObjectType,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PACCESS_STATE AccessState,</span></span></span><br><span class="line"><span class="function"><span class="params">IN KPROCESSOR_MODE AccessMode,</span></span></span><br><span class="line"><span class="function"><span class="params">IN ULONG Attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING CompleteName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING RemainingName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PVOID Context OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">OUT PVOID *Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">KdPrint((<span class="string">"Hook Success\n"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> g_OldFun(ParseObject, ObjectType, AccessState, AccessMode, Attributes,</span><br><span class="line">CompleteName,</span><br><span class="line">RemainingName, Context, SecurityQos, Object);</span><br><span class="line">&#125;</span><br><span class="line">OBGETOBJECTTYPE g_OBGetObjectType;</span><br><span class="line"><span class="comment">//获得一个函数地址，这个函数能够通过内核对象得到内核对象的类型</span></span><br><span class="line"><span class="function">VOID <span class="title">GetObjectTypeAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PUCHAR addr;</span><br><span class="line">UNICODE_STRING pslookup;</span><br><span class="line">RtlInitUnicodeString(&amp;pslookup, <span class="string">L"ObGetObjectType"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//               类似于应用层的GetProcAddress</span></span><br><span class="line">addr = (PUCHAR)MmGetSystemRoutineAddress(&amp;pslookup);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_OBGetObjectType = (OBGETOBJECTTYPE)addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span> &#123;</span></span><br><span class="line">USHORT Length;</span><br><span class="line">UCHAR ObjectTypeFlags;</span><br><span class="line">UCHAR CaseInsensitive;</span><br><span class="line">UCHAR UnnamedObjectsOnly;</span><br><span class="line">UCHAR  UseDefaultObject;</span><br><span class="line">UCHAR  SecurityRequired;</span><br><span class="line">UCHAR MaintainHandleCount;</span><br><span class="line">UCHAR MaintainTypeList;</span><br><span class="line">UCHAR SupportsObjectCallbacks;</span><br><span class="line">UCHAR CacheAligned;</span><br><span class="line">ULONG ObjectTypeCode;</span><br><span class="line">BOOLEAN InvalidAttributes;</span><br><span class="line">GENERIC_MAPPING GenericMapping;</span><br><span class="line">BOOLEAN   ValidAccessMask;</span><br><span class="line">BOOLEAN   RetainAccess;</span><br><span class="line">POOL_TYPE PoolType;</span><br><span class="line">BOOLEAN DefaultPagedPoolCharge;</span><br><span class="line">BOOLEAN DefaultNonPagedPoolCharge;</span><br><span class="line">PVOID DumpProcedure;</span><br><span class="line">ULONG OpenProcedure;</span><br><span class="line">PVOID CloseProcedure;</span><br><span class="line">PVOID DeleteProcedure;</span><br><span class="line">ULONG ParseProcedure;</span><br><span class="line">ULONG SecurityProcedure;</span><br><span class="line">ULONG QueryNameProcedure;</span><br><span class="line">UCHAR OkayToCloseProcedure;</span><br><span class="line">&#125; OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE</span> &#123;</span></span><br><span class="line">LIST_ENTRY TypeList;</span><br><span class="line">UNICODE_STRING Name;</span><br><span class="line">PVOID DefaultObject;</span><br><span class="line">ULONG Index;</span><br><span class="line">ULONG TotalNumberOfObjects;</span><br><span class="line">ULONG TotalNumberOfHandles;</span><br><span class="line">ULONG HighWaterNumberOfObjects;</span><br><span class="line">ULONG HighWaterNumberOfHandles;</span><br><span class="line">OBJECT_TYPE_INITIALIZER TypeInfo;</span><br><span class="line">ULONG  TypeLock;</span><br><span class="line">ULONG   Key;</span><br><span class="line">LIST_ENTRY   CallbackList;</span><br><span class="line">&#125; OBJECT_TYPE, *POBJECT_TYPE;</span><br><span class="line"><span class="function">HANDLE <span class="title">KernelCreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IN PUNICODE_STRING pstrFile, <span class="comment">// 文件路径符号链接</span></span></span></span><br><span class="line"><span class="function"><span class="params">IN BOOLEAN         bIsDir)</span>   <span class="comment">// 是否为文件夹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE          hFile = <span class="literal">NULL</span>;</span><br><span class="line">NTSTATUS        Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">IO_STATUS_BLOCK StatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ULONG           ulShareAccess =</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;</span><br><span class="line">ULONG           ulCreateOpt =</span><br><span class="line">FILE_SYNCHRONOUS_IO_NONALERT;</span><br><span class="line"><span class="comment">// 1. 初始化OBJECT_ATTRIBUTES的内容</span></span><br><span class="line">OBJECT_ATTRIBUTES objAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ULONG             ulAttributes =</span><br><span class="line">OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;</span><br><span class="line">InitializeObjectAttributes(</span><br><span class="line">&amp;objAttrib,    <span class="comment">// 返回初始化完毕的结构体</span></span><br><span class="line">pstrFile,      <span class="comment">// 文件对象名称</span></span><br><span class="line">ulAttributes,  <span class="comment">// 对象属性</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>);   <span class="comment">// 一般为NULL</span></span><br><span class="line"><span class="comment">// 2. 创建文件对象</span></span><br><span class="line">ulCreateOpt |= bIsDir;</span><br><span class="line">FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE;</span><br><span class="line">Status = ZwCreateFile(</span><br><span class="line">&amp;hFile,                <span class="comment">// 返回文件句柄</span></span><br><span class="line">GENERIC_ALL,           <span class="comment">// 文件操作描述</span></span><br><span class="line">&amp;objAttrib,            <span class="comment">// OBJECT_ATTRIBUTES</span></span><br><span class="line">&amp;StatusBlock,          <span class="comment">// 接受函数的操作结果</span></span><br><span class="line"><span class="number">0</span>,                     <span class="comment">// 初始文件大小</span></span><br><span class="line">FILE_ATTRIBUTE_NORMAL, <span class="comment">// 新建文件的属性</span></span><br><span class="line">ulShareAccess,         <span class="comment">// 文件共享方式</span></span><br><span class="line">FILE_OPEN_IF,          <span class="comment">// 文件存在则打开不存在则创建</span></span><br><span class="line">ulCreateOpt,           <span class="comment">// 打开操作的附加标志位</span></span><br><span class="line"><span class="literal">NULL</span>,                  <span class="comment">// 扩展属性区</span></span><br><span class="line"><span class="number">0</span>);                   <span class="comment">// 扩展属性区长度</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line"><span class="keyword">return</span> (HANDLE)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> hFile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 随便打开一个文件，得到一个文件对象</span></span><br><span class="line">UNICODE_STRING ustrFilePath;</span><br><span class="line">RtlInitUnicodeString(&amp;ustrFilePath,</span><br><span class="line"><span class="string">L"\\??\\D:\\123.txt"</span>);</span><br><span class="line">HANDLE hFile = KernelCreateFile(&amp;ustrFilePath, FALSE);</span><br><span class="line">PVOID pObject;</span><br><span class="line">ObReferenceObjectByHandle(hFile, GENERIC_ALL, <span class="literal">NULL</span>, KernelMode, &amp;pObject, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 通过这个文件对象得到OBJECT_TYPE这个结构体</span></span><br><span class="line">OBJECT_TYPE * FileType = <span class="literal">NULL</span>;</span><br><span class="line">FileType = (OBJECT_TYPE *)g_OBGetObjectType(pObject);</span><br><span class="line"><span class="comment">//3 把这个函数地址保存起来</span></span><br><span class="line">g_OldFun = (PARSEPRODECEDURE)FileType-&gt;TypeInfo.ParseProcedure;</span><br><span class="line"><span class="comment">//4 把这个函数地址替换为自己的函数。</span></span><br><span class="line">FileType-&gt;TypeInfo.ParseProcedure = (ULONG)NewParseProcedure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OffHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PDRIVER_OBJECT  pDriver,</span></span></span><br><span class="line"><span class="function"><span class="params">PUNICODE_STRING strRegPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 避免编译器报未引用参数的警告</span></span><br><span class="line">UNREFERENCED_PARAMETER(strRegPath);</span><br><span class="line"><span class="comment">// 打印一行字符串，并注册驱动卸载函数，以便于驱动卸载</span></span><br><span class="line">DbgBreakPoint();<span class="comment">//_asm int 3</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">GetObjectTypeAddress();</span><br><span class="line">OnHook();</span><br><span class="line">&#125;</span><br><span class="line">except(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">"掠过一个异常\n"</span>));</span><br><span class="line">&#125;</span><br><span class="line">KdPrint((<span class="string">"My First Dirver!"</span>));</span><br><span class="line">pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT objDriver)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 避免编译器报未引用参数的警告</span></span><br><span class="line">UNREFERENCED_PARAMETER(objDriver);</span><br><span class="line"><span class="comment">// 什么也不做，只打印一行字符串</span></span><br><span class="line">KdPrint((<span class="string">"My Dirver is unloading..."</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：毛德操，《Windows内核情景分析》<br>[2]: 一大堆的别人的博客  </p>]]></content>
      
      <categories>
          
          <category> 笔记 - Hook笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object—Hook </tag>
            
            <tag> 内核学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>保护模式之页相关的笔记</title>
      <link href="/2018/06/25/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/25/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>如下指令：<br>MOV eax,dword ptr ds:[0x12345678]<br>其中,0x12345678 是有效地址<br>ds.Base + 0x12345678 是线性地址  </p><h3 id="物理地址在哪里？"><a href="#物理地址在哪里？" class="headerlink" title="物理地址在哪里？"></a>物理地址在哪里？</h3><p>CR3寄存器是所有寄存器里面，唯一一个存储物理地址的寄存器，其他都是线性地址。<br>每个进程都有一个CR3,(准确的说是都一个CR3的值，CR3本身是个寄存器，一个核，只有一套寄存器)，CR3指向一个物理页，一共4096字节（4KB）,如图：</p><h3 id="10-10-12分页"><a href="#10-10-12分页" class="headerlink" title="10-10-12分页"></a>10-10-12分页</h3><table><thead><tr><th>31到22</th><th>21到12</th><th>11到0</th></tr></thead><tbody><tr><td>10</td><td>10</td><td>12</td></tr><tr><td>目录</td><td>目录</td><td>当前这个物理页的哪个位置</td></tr></tbody></table><p>设置分页方式<br>boot里的noexecute 改成 execute   </p><h2 id="PDE与PTE"><a href="#PDE与PTE" class="headerlink" title="PDE与PTE"></a>PDE与PTE</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/11.png" alt="分页机制"></p><h2 id="分析为什么是10-10-12"><a href="#分析为什么是10-10-12" class="headerlink" title="分析为什么是10-10-12"></a>分析为什么是10-10-12</h2><p>因为每个单元4字节，后3位是属性，倒着来看，比如12的原因，2的12次方是4K，所以12才能寻找所有的物理页，第二个10，每个PTE成员4字节，整个表4kB，所以有2的10次方个单元，所以有10位，第一个10位也是相同原因。   </p><h2 id="PTE特征"><a href="#PTE特征" class="headerlink" title="PTE特征"></a>PTE特征</h2><ul><li>PTE既可以指向物理页，也可以没有物理页。   </li><li>多个PTE可以指向同一个物理页。   </li><li>一个PTE只能指向一个物理页。   </li></ul><h2 id="物理页的属性"><a href="#物理页的属性" class="headerlink" title="物理页的属性"></a>物理页的属性</h2><p>物理页的属性 = PDE属性 &amp; PTE属性   </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/12.png" alt="物理页属性"></p><h3 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h3><p>线性地址0 为什么不能访问呢？<br>没有指定物理页，指定物理页就一定能访问吗？<br>先看PDE与PTE的P位  P=1 才是有效的物理页   </p><h3 id="R-W-位"><a href="#R-W-位" class="headerlink" title="R/W 位"></a>R/W 位</h3><p>R/W = 0 只读<br>R/W = 1 可读可写</p><h3 id="U-S-位"><a href="#U-S-位" class="headerlink" title="U/S 位"></a>U/S 位</h3><p>U/S = 0 特权用户<br>U/S = 1 普通用户</p><h3 id="P-S位（PageSize）"><a href="#P-S位（PageSize）" class="headerlink" title="P/S位（PageSize）"></a>P/S位（PageSize）</h3><p>对PDE有意义，PS == PageSize的意思  当PS==1的时候 PDE直接指向物理页无PTE,低22位全是页内偏移。因为后面的偏移，线性地址只能拆成2段：大小为4MB，俗称“大页”</p><h3 id="A-位"><a href="#A-位" class="headerlink" title="A 位"></a>A 位</h3><p>是否被访问（读或者写）过访问过置1，即使只访问一个字节也会导致PDE PTE置1  </p><h3 id="D-位"><a href="#D-位" class="headerlink" title="D 位"></a>D 位</h3><p>脏位，是否被写过，0没有被写过，1被写过   </p><p>在上一节课课后题中我们提到过，如果系统要保证某个线性地址是有效的，那么必须为其填充正确的PDE与PTE，如果我们想填充PDE与PTE那么必须能够访问PDT与PTT，那么存在2个问题：<br>1、一定已经有“人”为我们访问PDT与PTT挂好了PDE与PTE,我们只有找到这个线性地址就可以了。<br>2、这个为我们挂好PDE与PTE的“人”是谁？</p><p>拆分C0300000<br>结论：C0300000存储的值就是PDT<br>如果我们要访问第N个PDE，那么有如下公式：<br>0xC0300000 + N*4   </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/13.png" alt="段页"></p><p>PDT总结：<br>1、通过0xC0300000找到的物理页就是页目录表</p><p>2、这个物理页即是页目录表本身也是页表</p><p>3、页目录表是一张特殊的页表，每一项PTE指向的不是普通的物理页，而是指向其他的页表.</p><p>4、如果我们要访问第N个PDE，那么有如下公式：<br>0xC0300000 + N*4 </p><p>PTT总结：<br>1、页表被映射到了从0xC0000000到0xC03FFFFF的4M地址空间（一个页表是4KB，一共1024）<br>2、在这1024个表中有一张特殊的表：页目录表<br>3、页目录被映射到了0xC0300000开始处的4K地址空间</p><p>有了0xC0300000和0xC0000000能做什么？</p><p>掌握了这两个地址，就掌握了一个进程所有的物理内存读写权限。</p><p>公式总结：<br>1、什么是PDI与PTI<br>10-10-12  <br>2、访问页目录表的公式：<br>0xC0300000 + PDI<em>4<br>3、访问页表的公式<br>0xC0000000 + PDI</em>4096 + PTI*4</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/20.png" alt="image"></p><h1 id="首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。"><a href="#首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。" class="headerlink" title="首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。"></a>首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。</h1><h1 id="2-9-9-12分页"><a href="#2-9-9-12分页" class="headerlink" title="2-9-9-12分页"></a>2-9-9-12分页</h1><p>10-10-12分页方式，在这种分页方式下物理地址最多可达4GB。但随着硬件发展，4GB的物理地址范围已经无法满足要求，Intel在1996年就已经意识到这个问题了，所以设计了新的分页方式.也就是我们本节课要讲的2-9-9-12分页,又称为PAE（物理地址扩展）分页.   </p><h2 id="为什么是10-10-12"><a href="#为什么是10-10-12" class="headerlink" title="为什么是10-10-12"></a>为什么是10-10-12</h2><ul><li>先确定了页的大小4K，所以后面的12位的功能就确定了，（一个页4K是4096个字节，所以想让每个页内偏移的字节都能寻址到，就需要4096个地址，即2的12次方个，即12位）   </li><li>当初的物理内存比较小，所以4个字节的PTE就够了，加上页的尺寸是4K，所以一个页能存储1024个PTE， 也就是2的10次方，第二个10也就确定了.   </li><li>剩下的10为PDI  10+10+12刚好32位    </li></ul><h2 id="为什么是2-9-9-12"><a href="#为什么是2-9-9-12" class="headerlink" title="为什么是2-9-9-12"></a>为什么是2-9-9-12</h2><ul><li>页的大小是确定的，4KB不能随便改，所以12确定了。   </li><li>如果想增大物理内存的访问范围，就需要增大PTE,增大多少了呢？考虑对齐的因素，增加到8个字节，所以4K/8=512,一个页PTE就是512个，如下图。</li><li>同理PDI也是2的9次方 32 - 9 - 9 - 12 还差2位 所以就再做一级，叫PDPI  </li></ul><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/14.png" alt="PAE技术"></p><h2 id="2-9-9-12分页结构-PAE-物理地址扩展"><a href="#2-9-9-12分页结构-PAE-物理地址扩展" class="headerlink" title="2-9-9-12分页结构(PAE,物理地址扩展)"></a>2-9-9-12分页结构(PAE,物理地址扩展)</h2><p>CR3此时指向PDPTE</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/15.png" alt="2-9-9-12分页"></p><h2 id="如何开启PAE模式"><a href="#如何开启PAE模式" class="headerlink" title="如何开启PAE模式"></a>如何开启PAE模式</h2><p>将C:\boot.ini文件中的execute改为noexecute 重启   </p><h2 id="Page-Directory-Point-Table-Entry"><a href="#Page-Directory-Point-Table-Entry" class="headerlink" title="Page-Directory-Point-Table Entry"></a>Page-Directory-Point-Table Entry</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/16.png" alt="Page-Directory-Point-Table Entry"></p><ul><li>PDPTE共有四项(第一个2)。</li><li>35-12 存储的是页目录表的基址，低12位补0，共36位，即页目录基址。    </li></ul><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/17.png" alt="PAE的PDE结构"></p><p>特别说明：</p><ul><li>当PS=1时（第7位）是大页，35-21位是大页的物理地址，这样36位的物理地址的低21位为0，这就意味着页的大小为2MB，且都是2MB对齐。   </li><li>当PS=0时，35-12位是页表基址,低12位补0，共36位。   </li></ul><p>特别说明</p><ul><li>PTE中35-12是物理页基址，24位，低12位补0   </li><li>物理页基址+12位的页内偏移指向具体数据   </li></ul><h2 id="XD标志位（AMD中称为NX-即No-Excetion-）"><a href="#XD标志位（AMD中称为NX-即No-Excetion-）" class="headerlink" title="XD标志位（AMD中称为NX,即No Excetion ）"></a>XD标志位（AMD中称为NX,即No Excetion ）</h2><p>PDE/PTE结构</p><table><thead><tr><th>X</th><th>保留</th><th>35-12  物理地址</th><th>低12位（属性）</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>段的属性有可读、可写和可执行<br>页的属性有可读、可写<br>当RET执行返回的时候，如果我修改堆栈里面的数据指向一个我提前准备好的数据（把数据当作代码来执行，漏洞都是依赖这点，比如SQL注入也是）<br>所以，Intel就做了硬件保护，做了一个不可执行位，XD=1时。那么你的软件溢出了也没有关系，即使你的EIP蹦到了危险的“数据区”，也是不可以执行的！<br>在PAE分页模式下，PDE与PTE的最高位为XD/NX位.   </p><h1 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h1><h2 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h2><ol><li>通过一个线性地址访问一个物理页。比如：一个DWORD，其实未必真正读的是4个字节，我们先读的PDE再读PTE 最后才读的4个字节的页。   </li><li>在2-9-9-12会读24个字节 如果跨页可能更多。   </li></ol><p>为了提高效率，只能做记录。<br>CPU内部做了一个表，来记录这些东西，这个表格是CPU内部的，和寄存器一样快，这个表格：TLB（Translation Lookaside Buffer）。</p><h2 id="TLB结构"><a href="#TLB结构" class="headerlink" title="TLB结构"></a>TLB结构</h2><table><thead><tr><th>LA（线性地址）</th><th>PA（物理地址）</th><th>ATTR（属性）</th><th>LRU（统计）</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>说明：</p><ol><li>ATTR（属性）：属性是PDPE，PDE，PTE三个属性AND起来的. 如果是10-10-12，就是PDE and PTE   </li><li>不同的CPU 这个表的大小不一样.</li><li>只要Cr3变了，TLB立马刷新，一核一套TLB.</li></ol><p>操作系统的高2G映射基本不变，如果Cr3改了，TLB刷新 重建高2G以上很浪费。所以PDE和PTE中有个G标志位（PDE是大页时有效），如果G位为1刷新TLB时将不会刷新PDE/PTE的G位为1的页，当TLB满了，根据统计信息将不常用的地址废弃，最近最常用的保留.   </p><h2 id="TLB种类"><a href="#TLB种类" class="headerlink" title="TLB种类"></a>TLB种类</h2><p>TLB在X86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在X86体系的CPU里边，一般都设有如下4组TLB:<br>第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）；<br>第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）；<br>第三组：缓存大尺寸页表（2M/4M字节页面）的指令页表缓存（Instruction-TLB）；<br>第四组：缓存大尺寸页表（2M/4M字节页面）的数据页表缓存（Data-TLB）   </p><h1 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h1><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><ol><li>中断通常是由CPU外部的输入输出设备(硬件)所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫中断请求(Interrupt Request).   </li><li>中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程(中断处理程序在哪有IDT表决定)    </li><li>80x86有两条中断请求线：<br> 非屏蔽中断线，称为NMI（NonMaskable Interrupt）<br> 可屏蔽中断线，称为INTR（Interrupt Require</li></ol><h2 id="非可屏蔽中断如何处理"><a href="#非可屏蔽中断如何处理" class="headerlink" title="非可屏蔽中断如何处理"></a>非可屏蔽中断如何处理</h2><p>（固定IDT第二个门）</p><table><thead><tr><th>(IDT表)中断号</th><th>NMI</th><th>说明</th></tr></thead><tbody><tr><td>0x2</td><td>不可屏蔽中断</td><td>80x86中固定为0x2</td></tr></tbody></table><p>特别说明：<br>当非可屏蔽中断产生时，CPU在执行完当前指令后会里面进入中断处理程序<br>非可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须处理<br>非可屏蔽中断处理程序位于IDT表中的2号位置    </p><h2 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h2><p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器.它负责分配中断资源和管理各个中断源发出的中断请求.为了便于标识各个中断请求，中断管理器通常用IRQ(Interrupt Request)后面加上数字来表示不同的中断.</p><p>比如：在Windows中时钟中断的IRQ编号为0，也就是：IRQ0    </p><p>中断的实质是改变程序执行流程   </p><h2 id="可屏蔽中断如何处理？"><a href="#可屏蔽中断如何处理？" class="headerlink" title="可屏蔽中断如何处理？"></a>可屏蔽中断如何处理？</h2><table><thead><tr><th>（IDT表）中断号</th><th>IRQ</th><th>说明</th></tr></thead><tbody><tr><td>0x30</td><td>IRQ0</td><td>时钟中断</td></tr><tr><td>0x31-0x3F</td><td>IRQ1-IRQ15</td><td>其他硬件设备的中断</td></tr></tbody></table><p>特别说明：</p><ol><li>如果自己的程序执行时不希望CPU去处理这些中断，可以<br>用CLI指令清空EFLAG寄存器中的IF位<br>用STI指令设置EFLAG寄存器中的IF位   </li><li>硬件中断与IDT表中的对应关系并非固定不变的，<br>参见：APIC（高级可编程中断控制器）   </li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常通常是CPU在执行指令时检测到的某些错误，比如除0、访问无效页面等。</p><h3 id="中断与异常的区别："><a href="#中断与异常的区别：" class="headerlink" title="中断与异常的区别："></a>中断与异常的区别：</h3><ol><li>中断来自于外部设备，是中断源（比如键盘）发起的，CPU是被动的.</li><li>异常来自于CPU本身，是CPU主动产生的.</li><li>INT N虽然被称为“软件中断”，但其本质是异常。EFLAG的IF位对INT N无效。   </li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>无论是由硬件设备触发的中断请求还是由CPU产生的异常，处理程序都在IDT表。   </p><table><thead><tr><th>错误类型</th><th>（IDT表）中断号</th></tr></thead><tbody><tr><td>页错误</td><td>0xE</td></tr><tr><td>段错误</td><td>0xD</td></tr><tr><td>除0错误</td><td>0x0</td></tr><tr><td>双重</td><td>0x8</td></tr></tbody></table><h2 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h2><p>缺页异常的产生：<br>1、当PDE/PTE的P=0时<br>2、当PDE/PTE的属性为只读但程序试图写入的时<br>一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统来接管。   </p><h1 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h1><p>控制寄存器用于控制和确定CPU的操作模式。<br>Cr0 Cr1 Cr2 Cr3 Cr4<br>Cr1 保留<br>Cr3 页目录表基址   </p><h2 id="Cr0寄存器"><a href="#Cr0寄存器" class="headerlink" title="Cr0寄存器"></a>Cr0寄存器</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/18.png" alt="CR0寄存器"></p><p>说明：<br>PE：CR0的位0是启用保护（Protection Enable）标志。<br>PE=1保护模式，PE=0实地址模式，这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。<br>PG：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或者同时开启PE标志。<br>PG=0且PE=0，处理器工作在实地址模式下<br>PG=0且PE=1，处理器工作在没有开启分页机制的保护模式下<br>PG=1且PE=0，在PE没有开启的情况下，无法开启PG<br>PG=1且PE=1，处理器工作在开启了分页机制的保护模式下  </p><p>WP：对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页<br>面执行写操作；<br>当CPL&lt;3的时候：<br>如果 WP=0 可以读写任意用户级物理页，只要线性地址有效.<br>如果 WP=1 可以读取任意用户级物理页，但对于只读的物理页，则不能写.   </p><h2 id="Cr2寄存器"><a href="#Cr2寄存器" class="headerlink" title="Cr2寄存器"></a>Cr2寄存器</h2><p>当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。   </p><h2 id="Cr4寄存器"><a href="#Cr4寄存器" class="headerlink" title="Cr4寄存器"></a>Cr4寄存器</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/19.png" alt="Cr4寄存器"></p><h1 id="PWT-PCD"><a href="#PWT-PCD" class="headerlink" title="PWT/PCD"></a>PWT/PCD</h1><h2 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h2><p>1) CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。<br>2) CPU缓存可以做的很大，有几K、几十K、几百K甚至上M的也有。<br>CPU缓存与TLB的区别：<br>TLB：<br>    线性地址  <----->  物理地址<br>CPU缓存：<br>    物理地址  <----->  内容   </-----></-----></p><h2 id="关于PWT-PCD属性"><a href="#关于PWT-PCD属性" class="headerlink" title="关于PWT/PCD属性"></a>关于PWT/PCD属性</h2><p>PWT：Page Write Through</p><pre><code>PWT =  1 时 写Cache的时候也要将数据写入内存中。</code></pre><p>PCD：Page Cache Disable</p><pre><code>PCD = 1时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式页 </tag>
            
            <tag> 保护模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>保护模式之段相关的笔记</title>
      <link href="/2018/06/23/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%AE%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/23/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%AE%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="段寄存器简介"><a href="#段寄存器简介" class="headerlink" title="段寄存器简介"></a>段寄存器简介</h1><table><thead><tr><th>段寄存器</th><th>Selector</th><th>Attribute</th><th>Base</th><th>Limit</th></tr></thead><tbody><tr><td>ES</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>CS</td><td>++001B++</td><td>可读可执行</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>SS</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>DS</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>FS</td><td>++003B++</td><td>可读可写</td><td>++ 0x7FFDE000++</td><td>0xFFF</td></tr><tr><td>GS</td><td>windows没有使用</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h3 id="注释：加了下划线可能会变"><a href="#注释：加了下划线可能会变" class="headerlink" title="注释：加了下划线可能会变!"></a>注释：加了下划线可能会变!</h3><h2 id="探测Attribute存在"><a href="#探测Attribute存在" class="headerlink" title="探测Attribute存在"></a>探测Attribute存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> int <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">char</span>* argu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov ax,ss;<span class="comment">//cs不行，cs是不可写的</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov dword ptr ds:[var],eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="探测Base存在"><a href="#探测Base存在" class="headerlink" title="探测Base存在"></a>探测Base存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov ax,fs</span><br><span class="line">mov gs,ax</span><br><span class="line">mov eax,gs:[<span class="number">0x1000</span>]<span class="comment">//读取不成功，因为fs大小是FFF//不要用DS 否则编译不过，这个不是真正0地址，而是关于基址的偏移</span></span><br><span class="line">mov dword ptr ds:[var],eax</span><br><span class="line"></span><br><span class="line"><span class="comment">//mov edx,dword ptr ds:[0x7FFDF000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="探测Limit存在"><a href="#探测Limit存在" class="headerlink" title="探测Limit存在"></a>探测Limit存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov ax,fs</span><br><span class="line">mov gs,ax</span><br><span class="line">mov eax,gs:[<span class="number">0</span>]<span class="comment">//不要用DS 否则编译不过去</span></span><br><span class="line">mov dword ptr ds:[var],eax</span><br><span class="line"></span><br><span class="line"><span class="comment">//mov edx,dword ptr ds:[0x7FFDF000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GDT-全局描述符表-LDT-局部描述符表"><a href="#GDT-全局描述符表-LDT-局部描述符表" class="headerlink" title="GDT(全局描述符表)LDT(局部描述符表)"></a>GDT(全局描述符表)LDT(局部描述符表)</h1><p>当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定<br>查找GDT还是LDT,查找表的什么位置，查出多少数据.GDT是一张表，GDTR是个寄存器，存了GDT起始位置和有多少个元素。</p><h1 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h1><h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/1.png" alt="段描述符"></p><h2 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h2><p>段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符.<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/2.png" alt="段选择子"></p><p>RPL：请求特权级别</p><p>TI：<br>TI=0  查GDT表<br>TI=1  查LDT表</p><p>Index：<br>处理器将索引值乘以8<br>在加上GDT或者LDT的<br>基地址，就是要加载的<br>段描述符</p><h2 id="加载段描述符至段寄存器"><a href="#加载段描述符至段寄存器" class="headerlink" title="加载段描述符至段寄存器"></a>加载段描述符至段寄存器</h2><p>除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器.<br>CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，后面会讲.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">6</span>];</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">les ecx,fword ptr ds:[buffer] <span class="comment">//高2个字节给es，低四个字节给ecx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：RPL&lt;=DPL(在数值上)    </p><h1 id="段描述符属性"><a href="#段描述符属性" class="headerlink" title="段描述符属性"></a>段描述符属性</h1><h2 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h2><p>P = 1 段描述符有效<br>P = 0 段描述符无效<br>3、段描述符与段寄存器的对应关系    </p><p>WORD  Selector;//16位<br>WORD  Atrribute;//16位<br>DWORD Base;//32位<br>DWORD Limit;//32位      FFFFFFFF</p><h2 id="S位"><a href="#S位" class="headerlink" title="S位"></a>S位</h2><p>S = 1 代码段或者数据段描述符<br>S = 0 系统段描述符</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/3.png" alt="Tpye域"></p><p>因为P，DPL，S位，Type要么是1001（访问本段权限0），要么是1111（访问本段权限3），所以GDT表里第五5要是9或者F才是代码段或者数据段。又因为Type与第一位为1是代码段，所以第六位要是大于8就是代码段。<br>E 向上就是LImit里有效，扩展方向向下是Limit取反才是有效的。  </p><h2 id="系统段描述符"><a href="#系统段描述符" class="headerlink" title="系统段描述符"></a>系统段描述符</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/4.png" alt="系统段Type域"></p><h2 id="DB位"><a href="#DB位" class="headerlink" title="DB位"></a>DB位</h2><p>情况一：对CS段的影响<br>D = 1 采用32位寻址方式<br>D = 0 采用16位寻址方式<br>前缀67 改变寻址方式</p><p>情况二：对SS段的影响<br>D = 1 隐式堆栈访问指令（如：PUSH POP CALL）使用32位堆栈指针寄存器ESP<br>D = 0 隐式堆栈访问指令（如：PUSH POP CALL） 使用16位堆栈指针寄存器SP   </p><p>情况三：向下拓展的数据段   </p><p>D = 1 段上线为4GB<br>D = 0 段上线为64KB<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/5.png" alt="向上与向下扩展"></p><h1 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h1><table><thead><tr><th></th><th></th><th>位置</th><th>用途</th></tr></thead><tbody><tr><td> CPL</td><td>存放在CS和SS段选择子的最后两位更其他无关</td><td>当前程序特权级 ，CPU处于哪一环</td><td></td></tr><tr><td> DPL</td><td>存放在段描述符中</td><td>要访问该段需要什么权限才能访问</td><td></td></tr><tr><td>RPL</td><td>存放在段选择子的最后两位</td><td></td><td></td></tr></tbody></table><p>如何查看程序处于几环?</p><p>CPL(Current Privilege Level) ：当前特权级<br>CS和SS中存储的段选择子后2位，要一致，另外跟这两个有关，跟其他的东西无关<br>DPL(Descriptor Privilege Level)  描述符特权级别</p><p>DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么.<br>通俗的理解：<br>如果你想访问我，那么你应该具备什么特权.<br>举例说明：<br>mov DS,AX  如果AX指向的段DPL = 0  但当前程序的CPL = 3 这行指令是不会成功的！<br>RPL(Request Privilege Level)  请求特权级别<br>RPL是针对段选择子而言的，每个段的选择子都有自己的RPL</p><p>举例说明：</p><p>Mov ax,0008    与    Mov ax,000B//段选择子<br>Mov ds,ax        Mov ds,ax//将段描述<br>指向的是同一个段描述符,但RPL是不一样的.   </p><h2 id="数据段的权限检查"><a href="#数据段的权限检查" class="headerlink" title="数据段的权限检查"></a>数据段的权限检查</h2><p>参考如下代码：<br>比如当前程序处于0环，也就是说CPL=0<br>Mov ax,000B    //1011   RPL = 3<br>Mov ds,ax    //ax指向的段描述符的DPL = 0<br>数据段的权限检查：<br>CPL &lt;= DPL  并且 RPL &lt;= DPL (数值上的比较)<br>注意：<br>代码段和系统段描述符中的检查方式并不一样,具体参加后面课程.</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>CPL  CPU当前的权限级别<br>DPL  如果你想访问我，你应该具备什么样的权限<br>RPL  用什么权限去访问一个段  </p><h4 id="为啥要有RPL"><a href="#为啥要有RPL" class="headerlink" title="为啥要有RPL?"></a>为啥要有RPL?</h4><p>我们本可以用“读写”的权限去打开一个文件，但为了避免出错，有些时候我们使用“只读”的权限去打开。  </p><h1 id="跨段跳转"><a href="#跨段跳转" class="headerlink" title="跨段跳转"></a>跨段跳转</h1><h2 id="代码间的跳转-段间跳转-非调用门之类的"><a href="#代码间的跳转-段间跳转-非调用门之类的" class="headerlink" title="代码间的跳转(段间跳转  非调用门之类的)"></a>代码间的跳转(段间跳转  非调用门之类的)</h2><p>段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段<br>同时修改CS与EIP的指令<br>JMP FAR / CALL FAR / RETF / INT /IRETED<br><strong>注意：</strong><br>只改变EIP的指令<br>JMP / CALL / JCC / RET    </p><p>JMP 0x20:0x004183D7 CPU如何执行这行代码?</p><p>(1) 段选择子拆分</p><pre><code>0x20 对应二进制形式 0000 0000 0010 0000RPL = 00   TI = 0Index = 4</code></pre><p>(2) 查表得到段描述符</p><pre><code>TI = 0 所以查GDT表Index = 4 找到对应的段描述符四种情况可以跳转：代码段、调用门、TSS任务段、任务门</code></pre><p>(3) 权限检查</p><pre><code>如果是非一致代码段，要求:CPL == DPL 并且 RPL &lt;= DPL如果是一致代码段，要求:CPL &gt;= DPL</code></pre><p>(4) 加载段描述符</p><pre><code>通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中.</code></pre><p>(5) 代码执行</p><pre><code>CPU将 CS.Base + Offset 的值写入EIP 然后执行CS:EIP处的代码，段间跳转结束.</code></pre><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><ol><li><p>对于一致代码段:也就是共享的段</p><ol><li>特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据</li><li>特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态</li></ol></li><li>对于普通代码段：也就是非一致代码段<ol><li>只允许同级访问</li><li>绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态.</li></ol></li></ol><p>直接对代码段进行JMP 或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变.如果要提升CPL的权限，只能通过调用门.</p><h1 id="长调用与短调用"><a href="#长调用与短调用" class="headerlink" title="长调用与短调用"></a>长调用与短调用</h1><p>短调用<br>指令格式：CALL  立即数/寄存器/内存  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/6.png" alt="三种调用图"></p><h1 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h1><p>调用门执行流程</p><p>指令格式：CALL  CS:EIP(EIP是废弃的)<br>执行步骤：    </p><ol><li>根据CS的值 查GDT表，找到对应的段描述符，这个描述符是一个调用门.  </li><li>在调用门描述符中存储另一个代码段段的选择子.  </li><li>这个调用门的选择子指向的段  段.Base +这个调用门的 偏移地址，就是真正要执行的地址.  </li></ol><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/7.png" alt="门描述符"></p><p>构造一个调用门（无参，提权，不提权8的位置是1B）</p><p>0040EC00 000810D0放入gdt里没用到的位置。</p><p>构造一个带参数的调用门   </p><p>调用门描述符：0040EC03 00081030</p><blockquote><p>eq 8003f048 0040EC03`00081030</p></blockquote><p>调用门总结：</p><p>1) 当通过门，权限不变的时候，只会PUSH两个值：CS  返回地址<br>新的CS的值由调用门决定</p><p>2) 当通过门，权限改变的时候，会PUSH四个值：SS ESP CS  返回地址   新的CS的值由调用门决定  新的SS和ESP由TSS提供</p><p>3) 通过门调用时，要执行哪行代码有调用门决定，但使用RETF返回时，由堆栈中压人的值决定，这就是说，进门时只能按指定路线走，出门时可以翻墙(只要改变堆栈里面的值就可以想去哪去哪)<br>4) 可不可以再建个门出去呢?也就是用Call  当然可以了 前门进 后门出    </p><h1 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h1><p>Windows没有使用调用门，但是使用了中断门：</p><pre><code>&lt;1&gt; 系统调用&lt;2&gt; 调试</code></pre><p>IDT</p><pre><code>IDT即中断描述符表,同GDT一样，IDT也是由一系列描述符组成的，每个描述符占8个字节。但要注意的是，IDT表中的第一个元素不是NULL。在windbg中查看IDT表的基址和长度:</code></pre><p>老的CPU用的中断门，新的用的快速调用</p><p>IDT表都是系统段描述符，都不是空（调用门就有可能是代码数据段，和有空了）</p><p>中断门Type是1110，陷阱门是1111</p><h2 id="陷阱门与中断门的区别"><a href="#陷阱门与中断门的区别" class="headerlink" title="陷阱门与中断门的区别"></a>陷阱门与中断门的区别</h2><p>中断门执行时，将IF位清零,但陷阱门不会。</p><p>在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。</p><pre><code>切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)这2个值从哪里来的呢？答案：TSS (Task-state segment )，任务状态段.</code></pre><h2 id="TSS的结构"><a href="#TSS的结构" class="headerlink" title="TSS的结构"></a>TSS的结构</h2><p>TSS是一块内存，不是寄存器不在CPU中，内存结构如下图，大小104字节  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/8.png" alt="TSS的结构"></p><p>TSS的作用</p><pre><code>Intel的设计思想操作系统的设计思想本质：    不要把TSS与“任务切换”联系到一起    TSS的意义就在于可以同时换掉”一堆”寄存器</code></pre><p>CPU如何找到TSS呢?  TR段寄存器  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/9.png" alt="TR寄存器"></p><p>CPU找TSS直接在TR寄存器，TR的Base指向TSS，Limit是Tss有多大，TSS是操作系统启动时从GDT加载的。TSS是系统段的一种。所以S为是0，Type是1001，说明没有加载到TR寄存器中，1011时是已经加载到TR寄存器。  </p><h2 id="TR寄存器读写"><a href="#TR寄存器读写" class="headerlink" title="TR寄存器读写"></a>TR寄存器读写</h2><ol><li>将TSS段描述符加载到TR寄存器  <pre><code>指令：LTR  说明：用LTR指令去装载的话 仅仅是改变TR寄存器的值(96位) 并没有真正改变TSS  LTR指令只能在系统层使用加载后TSS段描述符会状态位会发生改变就是上面9变B</code></pre></li><li><p>读TR寄存器  </p><pre><code>1. 指令：STR  说明：如果用STR去读的话，只读了TR的16位 也就是选择子  </code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p> TSS是一块内存，大小104字节.通过TSS可以同时替换“一堆”寄存器，包括通用寄存器和段寄存器等.</p><p> CPU通过TR段寄存器来找到TSS.如果我们想用自己的TSS段来替换原来的寄存器，就要修改TR寄存器，TR寄存器的值又是来自TSS段描述符，那么我们接下来先构造一个段描述符。</p></li></ol><p>修改TR寄存器</p><pre><code>1) 在Ring0 我们可以通过LTR指令去修改TR寄存器2) 在Ring3 我们可以通过CALL FAR 或者 JMP FAR指令来修改</code></pre><p>用JMP去访问一个代码段的时候，改变的是CS和EIP ：</p><pre><code>JMP 0x48:0x123456  如果0x48是代码段  执行后：CS--&gt;0x48  EIP--&gt;0x123456</code></pre><p>用JMP去访问一个任务段的时候：</p><pre><code>如果0x48是TSS段描述符，先修改TR寄存器，在用TR.Base指向的TSS中的值修改当前的寄存器</code></pre><h1 id="任务门描述符"><a href="#任务门描述符" class="headerlink" title="任务门描述符"></a>任务门描述符</h1><p>Type为0101即5.<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/10.png" alt="任务门"> </p><p>这是TSS段的描述符（在GDT表），任务门本身在IDT表</p><p>任务门执行过程：</p><p>INT N</p><p>查IDT表，找到中断门描述符</p><p>通过中断门描述符，查GDT表，找到任务段描述符</p><p>使用TSS段中的值修改寄存器</p><p>IRETD返回</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 保护模式段 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>段使用时相关的检查与调用门实验</title>
      <link href="/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/"/>
      <url>/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="段类型检查"><a href="#段类型检查" class="headerlink" title="段类型检查"></a>段类型检查</h1><p>加载段选择符进入段寄存器时候</p><ul><li>CS只能存放可执行的选择符</li><li>不可读可执行不能被加载到数据段寄存器</li><li>只有可写的数据段才能加载到SS</li></ul><h1 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h1><p>当给段寄存器赋值，实际是从GDT中获取相应的段描述符加载到段寄存器的不可见部分。这个时候有个权限检查，有三个概念：</p><ul><li>CPL：当前代码执行权限</li><li>DPL：存在段描述符中，描述访问本段内存需要的权限</li><li>RPL：存在于段寄存器加载时的段选择子中，描述了使用什么样的权限对目标进行访问</li></ul><p>从数值上MAX（CPL，RPL）&lt;DPL.  </p><p>段内跳转不会产生权限检查（JMP，CALL，RET），段间会。 </p><p>当S为0时：</p><ul><li>调用门：Type=12。</li><li>中断门：Type=14。</li><li>陷阱门：Type=15。</li><li>任务门：Type=5。</li></ul><h1 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/duanshiyongjiancha/1.png" alt="调用门图片"><br>调用门描述符中存储了一个代码段的段选择子。<br>指令格式：CALL CS：EIP（EIP废弃的）</p><ul><li>根据CS的值查GDT表，找到对应段描述符，之歌描述符是一个调用门。</li><li>在调用门描述符中存储着另一个代码段的段选择子。</li><li>选择子指向的段，段Base+偏移地址，就是真正要执行的地址。<br>通过调用门可以原图，不过Windows并没有用调用门。 </li></ul><p>段寄存器一共有 96 位，其中16可见部分来源于段选择子的索引部分。剩下80位来源于 GDT表。++<strong>那GDT表64位是怎么表示80位的段描述符呢？</strong>++ 是有一部分是G位为零代表粒度是1字节，在段限长前面补12位000，如果G为1在段限长前面补FFF，FFF刚好4KB。（段限长就是FFFFF）,所以当G=0，即粒度是1B时候，范围就是<br>2^00000000^到2^000FFFFF^即1B到4MB,当G=1，即粒度是1B时候，范围就是2^FFF00000^到2^FFFFFFFF^，即4KB到4GB。</p><h1 id="中断门和陷阱门"><a href="#中断门和陷阱门" class="headerlink" title="中断门和陷阱门"></a>中断门和陷阱门</h1><p>除了GDT外，还有一个地方也存着门描述符，被称为IDT（中断描述符表）。<br>IDT中存着3种门描述符： </p><ul><li>中断门描述符 </li><li>陷阱门描述符</li><li>任务门描述符 </li></ul><p>当S为0，type为1110是个中断门<br>中断门描述符存储着一个断码段选择子。<br>当S为0，type为1111是陷阱门 </p><ul><li>陷阱门用于存放异常处理函数</li><li>中断门用于存放中断处理函数地址</li><li>中断门执行时候IF位会清零，屏蔽可屏蔽中断，陷阱门不会。 </li></ul><h1 id="调用门提权实验"><a href="#调用门提权实验" class="headerlink" title="调用门提权实验"></a>调用门提权实验</h1><p>先确定一个事情，怎么提权？是要构造一个调用门描述符，然后CALL这个段的一个地址所以这个段的DPL得是3环的，所以，在构造的调用门描述符里，DPL位是3即11b，即3环就能访问本段的程序。然后这个调用门里的段选择子（就是13位可见的那部分个）是要执行的段，所以他的段选择子的RPL要是高权限，所以他的RPL应该是00，Ti也0，查GDT第二个就行所以索引是1，所以合起来是1000b，所以段选择子是8，所以要构造的调用门描述符里8，的作用是让其RPL是00为0，环以0环权限去访问，Ti为是0找GDT表，其他位置弄成如下<br>XXXXEC000008XXXX<br>下面的代码相关信息如下</p><ul><li>前后XXXX为偏移，比如你要执行的代码的偏移，即下文函数的入口，构造下面代码</li><li>0x80b95500为任意一个内核空间（高地址空间），为了验证能不能提权，得到内核的信息。</li><li>retf为不仅像ret一样pop ip，还pop cs</li><li>0x00,0x00,0x00,0x00,0x63,0x00 为CS：IP，因为内存以小端寸断存储。所以是这样，IP可以任意</li><li>fword为远跳，6字节的，用于段间跳转。</li><li>CS为0x63，即下面代码要CALL的段选择是0x63，是因为我们找了一个GDT里的空位为第12个位置，所以是1100,然后找GDT，权限是3环，所以段选择子是1100011b，所以这个是63</li><li>注意vs要关闭随机基址，虚拟机要单核，比较好做这个实验</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_num = <span class="number">0</span>;</span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里如果用了 int 3 那么回到3环的时候，会造成程序崩溃，因为回去的时候，FS会被置0；</span></span><br><span class="line">_asm &#123;</span><br><span class="line">push eax;</span><br><span class="line">mov eax, DWORD ptr ds : [<span class="number">0x80b95500</span>];</span><br><span class="line">mov g_num, eax;</span><br><span class="line">pop eax;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">6</span>] = &#123; <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x63</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">_asm &#123;</span><br><span class="line">call fword ptr ds : [buf];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, g_num);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节<br>[2]:<code>https://blog.csdn.net/q1007729991/article/details/52538080</code><br>[3]：李忠，《x86汇编语言:从实模式到保护模式》，电子工业出版社</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 调用门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>段描述符浅谈</title>
      <link href="/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/"/>
      <url>/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/</url>
      <content type="html"><![CDATA[<h1 id="描述符表中存放的是段描述符，如下图所示"><a href="#描述符表中存放的是段描述符，如下图所示" class="headerlink" title="描述符表中存放的是段描述符，如下图所示"></a>描述符表中存放的是段描述符，如下图所示</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/2.PNG" alt="图1-1 段描述符通用格式"></p><h1 id="段描述符基本属性"><a href="#段描述符基本属性" class="headerlink" title="段描述符基本属性"></a>段描述符基本属性</h1><p>段描述符是GDT和LDT中的一个数据结构项，用于向处理器提供有关一个段的位置大小访问控制的信息状态信息，每个段描述符的长度是8个字节，含有3个主要字段</p><ul><li>段基地址</li><li>段限长</li><li>段属性 </li></ul><h2 id="基地址字段Base"><a href="#基地址字段Base" class="headerlink" title="基地址字段Base"></a>基地址字段Base</h2><p>描述了一个短的起始位置，由三个部分组成一共32位，段基地址可以是0~4GB范围内的任意地址(这同实模式不同，实模式下段基地址要求16字节对齐)，但是为了让程序具有最佳性能，还是建议16字节对齐。</p><h2 id="粒度G位"><a href="#粒度G位" class="headerlink" title="粒度G位"></a>粒度G位</h2><p>为0，Limit单位是字节。为1，Limit单位是4KB。</p><h2 id="B-D位-数据段时是B，代码段时是D"><a href="#B-D位-数据段时是B，代码段时是D" class="headerlink" title="B/D位 (数据段时是B，代码段时是D)"></a>B/D位 (数据段时是B，代码段时是D)</h2><ul><li>为B时<ul><li>为0，内存寻址是16位，堆栈使用SP，段的最大大小是64KB。</li><li>为1，内存寻址是32位，堆栈使用ESP，段的最大大小是4GB。</li></ul></li><li>为D时<ul><li>为0，默认值是16位的地址和16位或者8为操作数。</li><li>为1，默认值是32位的地址和32位或者8为操作数。<h2 id="L位（21）"><a href="#L位（21）" class="headerlink" title="L位（21）"></a>L位（21）</h2>是64位代码段标志，保留给64位处理器使用，目前在分析32位时置零即可<h2 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h2>是软件可以使用的位，通常由操作系统使用，处理器不使用它<h2 id="段限长Limit"><a href="#段限长Limit" class="headerlink" title="段限长Limit"></a>段限长Limit</h2>处理器会把段描述符中两个段限长字段组合成一个20位的值，并根据颗粒度标志G来知道段限长Limit值的实际含义。<h2 id="描述符有效位P位"><a href="#描述符有效位P位" class="headerlink" title="描述符有效位P位"></a>描述符有效位P位</h2>为1则段描述符有效，为0则段描述符无效<h2 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h2>存在于段描述符中，描述了访问本地内存需要的权限。<h2 id="S与TYPE"><a href="#S与TYPE" class="headerlink" title="S与TYPE"></a>S与TYPE</h2>应用程序有数据段和代码段，cpu还有系统段和门描述符，用来管理任务，异常，中断。并非所有的描述符都定义一个段，门描述符中存放着一个指向过程入口点的指针，S和Type字段表明了描述符的类型信息。</li></ul></li></ul><table><thead><tr><th>S位</th><th>Type域</th></tr></thead><tbody><tr><td>为1代码是一个代码段或者数据段，0是一个系统段</td><td>一共4位，在S位不同时，含义不同</td><td></td></tr></tbody></table><p>当S为1时，Tpye的四位，11位为0时是数据段，1时是代码段。</p><ul><li><p>当时数据段时，后面10,9,8位为EWA</p><ul><li>10号位为E扩展位，0向上扩展，1向下扩展，向上扩展就是正常的扩展，向上扩展一段空间，扩展的空间可用，向下扩展就是向上扩展一下，除了这段，其他的都在段内，如图<img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/1.png" alt="图1-2 向上扩展和向下扩展"></li><li>9号位为W，为是否可写（代码段可定都是可读的所以不需要这样的属性标志）</li><li>8号位为A，为是否已被访问</li></ul></li><li><p>当时代码段时，后面10,9,8位为CRA  </p><ul><li>10号位为一致性段位，0是非一致性段，1是一致性段  <ul><li><strong>非一致代码段：</strong>  受到隔离的代码，只能在同一级别间互相访问。</li><li><strong>一致性代码段：</strong>  不受隔离，允许被同等级货低等级代码调用。</li></ul></li><li>9号位为R，为是否可读（代码段都是可执行的）</li><li>8号位为A，为是否已被访问</li></ul></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown用法之表格单元格合并</title>
      <link href="/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/"/>
      <url>/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p>Markdown语法本身不包含复杂表格的插入，但是可以使用html语法来实现。</p><p>水平单元格的合并：基于colspan属性，即使一个单元格占多列的空间<br>纵向单元格的合并：基于rowspan属性，即使一个单元格占多行的空间<br>要想MarkDown中插入复杂表格时，可以先在word或excel中把表格写好，然后在如下网站进行转化为标记对形式：</p><p><a href="http://pressbin.com/tools/excel_to_html_table/index.html" target="_blank" rel="noopener">http://pressbin.com/tools/excel_to_html_table/index.html</a></p><p>然后删除空标记对，并设置colspan和rowspan属性即可。<br>比如  <code>&lt;td colspan=&quot;8&quot;&gt;基地址Base31到24&lt;/td&gt;</code>就是合并8列单元格</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> 文本编辑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序二进制特征</title>
      <link href="/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/"/>
      <url>/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/</url>
      <content type="html"><![CDATA[<h1 id="常用程序的特征"><a href="#常用程序的特征" class="headerlink" title="常用程序的特征"></a>常用程序的特征</h1><h2 id="1-BC"><a href="#1-BC" class="headerlink" title="1.BC++"></a>1.BC++</h2><h2 id="2Delphi"><a href="#2Delphi" class="headerlink" title="2Delphi"></a>2Delphi</h2><h2 id="3易语言"><a href="#3易语言" class="headerlink" title="3易语言"></a>3易语言</h2><h2 id="4VB"><a href="#4VB" class="headerlink" title="4VB"></a>4VB</h2><h2 id="3VC"><a href="#3VC" class="headerlink" title="3VC++"></a>3VC++</h2><h1 id="分析BC-程序特征"><a href="#分析BC-程序特征" class="headerlink" title="分析BC++程序特征"></a>分析BC++程序特征</h1><p>OPE特征    EB 10  Fb c++hook<br>二进制特征：EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90</p><p>第一个CALL内有API调用 GetMouduleHandleA</p><h1 id="分析Delphi程序特征"><a href="#分析Delphi程序特征" class="headerlink" title="分析Delphi程序特征"></a>分析Delphi程序特征</h1><p>OPE特征  5个Call ，上面全是地址，后面全是0，第一个CALL内有API调用 GetMouduleHandleA</p><p>调用函数时，跳转IAT时OPCODE跳转是FF25，VC是FF15</p><p>区段名比较细致</p><p>CODE，DATA，BSS（），idata，tls，rdata，reloc，rsrc</p><p>链接器版本<br>2.25</p><h1 id="分析VS程序"><a href="#分析VS程序" class="headerlink" title="分析VS程序"></a>分析VS程序</h1><p>VC6.0  6.0<br>VC2003 7.0 7.1<br>VC2005 8.0<br>VC2008   9.0<br>VS2010   10<br>VS2012   11<br>VS2015   14.0<br>VS2017  14.1  </p><h1 id="分析VC6-0和易语言程序特征"><a href="#分析VC6-0和易语言程序特征" class="headerlink" title="分析VC6.0和易语言程序特征"></a>分析VC6.0和易语言程序特征</h1><p>这两个编译器一样，链接器都是6.0版本，第一个api调用getversion，<br>Sub esp，0x58</p><h1 id="逆向步骤"><a href="#逆向步骤" class="headerlink" title="逆向步骤"></a>逆向步骤</h1><p>拿到程序  </p><h2 id="1-确定格式和加密"><a href="#1-确定格式和加密" class="headerlink" title="1.确定格式和加密"></a>1.确定格式和加密</h2><h2 id="2-根据分析，选择工具全面静态分析"><a href="#2-根据分析，选择工具全面静态分析" class="headerlink" title="2.根据分析，选择工具全面静态分析"></a>2.根据分析，选择工具全面静态分析</h2><p>1.查看链接器版本（4.20-VB5，2.25-Delphi7）<br>2.查看OEP代码，是否加壳，未加壳的编译器环境（代码是否正常，pushad这类不正常）<br>3.查看区段（.text 微软 CODE 宝蓝）<br>4.查看导入导出 表（函数名）<br>5.查看资源信息（有无自定义资源）<br>6.查看TLS信息息（有无设置TLS回调函数）<br>7.文件大小，图标  </p><h2 id="3-使用完PE工具，在使用其他工具进行分析"><a href="#3-使用完PE工具，在使用其他工具进行分析" class="headerlink" title="3.使用完PE工具，在使用其他工具进行分析"></a>3.使用完PE工具，在使用其他工具进行分析</h2><p>1.如果加壳，就脱壳，如果是强壳还是需要脱壳才能分析，那就先找OEP再转存到文件，结合IDA进行分析。<br>2.若果程序为保护，看引用了API之类的，根据API确定实现的功能，比如文件操作，网络操作，注册表操作。用监控类工具分析，分析日志，，再进行下一步分析，如果需要分析网络数据可以使用抓包工具。<br>3.如果其他的文件，如资源文件，分析字符串推测功能<br>4.如果程序有安装目录，目录每个文件子目录都要查看  </p><h2 id="4-根据静态分析情况，再动态分析"><a href="#4-根据静态分析情况，再动态分析" class="headerlink" title="4.根据静态分析情况，再动态分析"></a>4.根据静态分析情况，再动态分析</h2><p>第一种，单步跟踪调试，就是从程序加载开始跟踪，一直到找到需要的信息。<br>第二种，附加调试程序，这是在程序运行的状态下，附加进程，进行分析，一般在API下断，然后栈回溯进行分析，还有一种就是如果是窗口程序，我们可以通过窗口回调函数然后进行分析。  </p><h2 id="5-动静结合"><a href="#5-动静结合" class="headerlink" title="5.动静结合"></a>5.动静结合</h2><p>OD，IDA<br>如果分析中还是有很多困难，那么就需要使用IDA/OD等工具进行进一步的分析，尤其是字符串。<br>根据字符串，下断栈回溯分析。  </p><h2 id="6-使用源码对比法，辅助逆向"><a href="#6-使用源码对比法，辅助逆向" class="headerlink" title="6.使用源码对比法，辅助逆向"></a>6.使用源码对比法，辅助逆向</h2><p>分析程序，用了什么库，写代码demo反汇编我们的程序进行对比，提高逆向效率  </p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 反汇编 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/20/hello-world/"/>
      <url>/2018/06/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
