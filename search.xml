<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>保护模式之段相关的笔记</title>
      <link href="/2018/06/23/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%AE%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/23/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%AE%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="段寄存器简介"><a href="#段寄存器简介" class="headerlink" title="段寄存器简介"></a>段寄存器简介</h1><table><thead><tr><th>段寄存器</th><th>Selector</th><th>Attribute</th><th>Base</th><th>Limit</th></tr></thead><tbody><tr><td>ES</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>CS</td><td>++001B++</td><td>可读可执行</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>SS</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>DS</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>FS</td><td>++003B++</td><td>可读可写</td><td>++ 0x7FFDE000++</td><td>0xFFF</td></tr><tr><td>GS</td><td>windows没有使用</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h3 id="注释：加了下划线可能会变"><a href="#注释：加了下划线可能会变" class="headerlink" title="注释：加了下划线可能会变!"></a>注释：加了下划线可能会变!</h3><h2 id="探测Attribute存在"><a href="#探测Attribute存在" class="headerlink" title="探测Attribute存在"></a>探测Attribute存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> int <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">char</span>* argu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov ax,ss;<span class="comment">//cs不行，cs是不可写的</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov dword ptr ds:[var],eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="探测Base存在"><a href="#探测Base存在" class="headerlink" title="探测Base存在"></a>探测Base存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov ax,fs</span><br><span class="line">mov gs,ax</span><br><span class="line">mov eax,gs:[<span class="number">0x1000</span>]<span class="comment">//读取不成功，因为fs大小是FFF//不要用DS 否则编译不过，这个不是真正0地址，而是关于基址的偏移</span></span><br><span class="line">mov dword ptr ds:[var],eax</span><br><span class="line"></span><br><span class="line"><span class="comment">//mov edx,dword ptr ds:[0x7FFDF000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="探测Limit存在"><a href="#探测Limit存在" class="headerlink" title="探测Limit存在"></a>探测Limit存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov ax,fs</span><br><span class="line">mov gs,ax</span><br><span class="line">mov eax,gs:[<span class="number">0</span>]<span class="comment">//不要用DS 否则编译不过去</span></span><br><span class="line">mov dword ptr ds:[var],eax</span><br><span class="line"></span><br><span class="line"><span class="comment">//mov edx,dword ptr ds:[0x7FFDF000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GDT-全局描述符表-LDT-局部描述符表"><a href="#GDT-全局描述符表-LDT-局部描述符表" class="headerlink" title="GDT(全局描述符表)LDT(局部描述符表)"></a>GDT(全局描述符表)LDT(局部描述符表)</h1><p>当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定<br>查找GDT还是LDT,查找表的什么位置，查出多少数据.GDT是一张表，GDTR是个寄存器，存了GDT起始位置和有多少个元素。</p><h1 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h1><h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/1.png" alt="段描述符"></p><h2 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h2><p>段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符.<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/2.png" alt="段选择子"></p><p>RPL：请求特权级别</p><p>TI：<br>TI=0  查GDT表<br>TI=1  查LDT表</p><p>Index：<br>处理器将索引值乘以8<br>在加上GDT或者LDT的<br>基地址，就是要加载的<br>段描述符</p><h2 id="加载段描述符至段寄存器"><a href="#加载段描述符至段寄存器" class="headerlink" title="加载段描述符至段寄存器"></a>加载段描述符至段寄存器</h2><p>除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器.<br>CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，后面会讲.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">6</span>];</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">les ecx,fword ptr ds:[buffer] <span class="comment">//高2个字节给es，低四个字节给ecx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：RPL&lt;=DPL(在数值上)    </p><h1 id="段描述符属性"><a href="#段描述符属性" class="headerlink" title="段描述符属性"></a>段描述符属性</h1><h2 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h2><p>P = 1 段描述符有效<br>P = 0 段描述符无效<br>3、段描述符与段寄存器的对应关系    </p><p>WORD  Selector;//16位<br>WORD  Atrribute;//16位<br>DWORD Base;//32位<br>DWORD Limit;//32位      FFFFFFFF</p><h2 id="S位"><a href="#S位" class="headerlink" title="S位"></a>S位</h2><p>S = 1 代码段或者数据段描述符<br>S = 0 系统段描述符</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/3.png" alt="Tpye域"></p><p>因为P，DPL，S位，Type要么是1001（访问本段权限0），要么是1111（访问本段权限3），所以GDT表里第五5要是9或者F才是代码段或者数据段。又因为Type与第一位为1是代码段，所以第六位要是大于8就是代码段。<br>E 向上就是LImit里有效，扩展方向向下是Limit取反才是有效的。  </p><h2 id="系统段描述符"><a href="#系统段描述符" class="headerlink" title="系统段描述符"></a>系统段描述符</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/4.png" alt="系统段Type域"></p><h2 id="DB位"><a href="#DB位" class="headerlink" title="DB位"></a>DB位</h2><p>情况一：对CS段的影响<br>D = 1 采用32位寻址方式<br>D = 0 采用16位寻址方式<br>前缀67 改变寻址方式</p><p>情况二：对SS段的影响<br>D = 1 隐式堆栈访问指令（如：PUSH POP CALL）使用32位堆栈指针寄存器ESP<br>D = 0 隐式堆栈访问指令（如：PUSH POP CALL） 使用16位堆栈指针寄存器SP   </p><p>情况三：向下拓展的数据段   </p><p>D = 1 段上线为4GB<br>D = 0 段上线为64KB<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/5.png" alt="向上与向下扩展"></p><h1 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h1><table><thead><tr><th></th><th></th><th>位置</th><th>用途</th></tr></thead><tbody><tr><td> CPL</td><td>存放在CS和SS段选择子的最后两位更其他无关</td><td>当前程序特权级 ，CPU处于哪一环</td><td></td></tr><tr><td> DPL</td><td>存放在段描述符中</td><td>要访问该段需要什么权限才能访问</td><td></td></tr><tr><td>RPL</td><td>存放在段选择子的最后两位</td><td></td><td></td></tr></tbody></table><p>如何查看程序处于几环?</p><p>CPL(Current Privilege Level) ：当前特权级<br>CS和SS中存储的段选择子后2位，要一致，另外跟这两个有关，跟其他的东西无关<br>DPL(Descriptor Privilege Level)  描述符特权级别</p><p>DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么.<br>通俗的理解：<br>如果你想访问我，那么你应该具备什么特权.<br>举例说明：<br>mov DS,AX  如果AX指向的段DPL = 0  但当前程序的CPL = 3 这行指令是不会成功的！<br>RPL(Request Privilege Level)  请求特权级别<br>RPL是针对段选择子而言的，每个段的选择子都有自己的RPL</p><p>举例说明：</p><p>Mov ax,0008    与    Mov ax,000B//段选择子<br>Mov ds,ax        Mov ds,ax//将段描述<br>指向的是同一个段描述符,但RPL是不一样的.   </p><h2 id="数据段的权限检查"><a href="#数据段的权限检查" class="headerlink" title="数据段的权限检查"></a>数据段的权限检查</h2><p>参考如下代码：<br>比如当前程序处于0环，也就是说CPL=0<br>Mov ax,000B    //1011   RPL = 3<br>Mov ds,ax    //ax指向的段描述符的DPL = 0<br>数据段的权限检查：<br>CPL &lt;= DPL  并且 RPL &lt;= DPL (数值上的比较)<br>注意：<br>代码段和系统段描述符中的检查方式并不一样,具体参加后面课程.</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>CPL  CPU当前的权限级别<br>DPL  如果你想访问我，你应该具备什么样的权限<br>RPL  用什么权限去访问一个段  </p><h4 id="为啥要有RPL"><a href="#为啥要有RPL" class="headerlink" title="为啥要有RPL?"></a>为啥要有RPL?</h4><p>我们本可以用“读写”的权限去打开一个文件，但为了避免出错，有些时候我们使用“只读”的权限去打开。  </p><h1 id="跨段跳转"><a href="#跨段跳转" class="headerlink" title="跨段跳转"></a>跨段跳转</h1><h2 id="代码间的跳转-段间跳转-非调用门之类的"><a href="#代码间的跳转-段间跳转-非调用门之类的" class="headerlink" title="代码间的跳转(段间跳转  非调用门之类的)"></a>代码间的跳转(段间跳转  非调用门之类的)</h2><p>段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段<br>同时修改CS与EIP的指令<br>JMP FAR / CALL FAR / RETF / INT /IRETED<br><strong>注意：</strong><br>只改变EIP的指令<br>JMP / CALL / JCC / RET    </p><p>JMP 0x20:0x004183D7 CPU如何执行这行代码?</p><p>(1) 段选择子拆分</p><pre><code>0x20 对应二进制形式 0000 0000 0010 0000RPL = 00   TI = 0Index = 4</code></pre><p>(2) 查表得到段描述符</p><pre><code>TI = 0 所以查GDT表Index = 4 找到对应的段描述符四种情况可以跳转：代码段、调用门、TSS任务段、任务门</code></pre><p>(3) 权限检查</p><pre><code>如果是非一致代码段，要求:CPL == DPL 并且 RPL &lt;= DPL如果是一致代码段，要求:CPL &gt;= DPL</code></pre><p>(4) 加载段描述符</p><pre><code>通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中.</code></pre><p>(5) 代码执行</p><pre><code>CPU将 CS.Base + Offset 的值写入EIP 然后执行CS:EIP处的代码，段间跳转结束.</code></pre><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><ol><li><p>对于一致代码段:也就是共享的段</p><ol><li>特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据</li><li>特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态</li></ol></li><li>对于普通代码段：也就是非一致代码段<ol><li>只允许同级访问</li><li>绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态.</li></ol></li></ol><p>直接对代码段进行JMP 或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变.如果要提升CPL的权限，只能通过调用门.</p><h1 id="长调用与短调用"><a href="#长调用与短调用" class="headerlink" title="长调用与短调用"></a>长调用与短调用</h1><p>短调用<br>指令格式：CALL  立即数/寄存器/内存  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/6.png" alt="三种调用图"></p><h1 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h1><p>调用门执行流程</p><p>指令格式：CALL  CS:EIP(EIP是废弃的)<br>执行步骤：    </p><ol><li>根据CS的值 查GDT表，找到对应的段描述符，这个描述符是一个调用门.  </li><li>在调用门描述符中存储另一个代码段段的选择子.  </li><li>这个调用门的选择子指向的段  段.Base +这个调用门的 偏移地址，就是真正要执行的地址.  </li></ol><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/7.png" alt="门描述符"></p><p>构造一个调用门（无参，提权，不提权8的位置是1B）</p><p>0040EC00 000810D0放入gdt里没用到的位置。</p><p>构造一个带参数的调用门   </p><p>调用门描述符：0040EC03 00081030</p><blockquote><p>eq 8003f048 0040EC03`00081030</p></blockquote><p>调用门总结：</p><p>1) 当通过门，权限不变的时候，只会PUSH两个值：CS  返回地址<br>新的CS的值由调用门决定</p><p>2) 当通过门，权限改变的时候，会PUSH四个值：SS ESP CS  返回地址   新的CS的值由调用门决定  新的SS和ESP由TSS提供</p><p>3) 通过门调用时，要执行哪行代码有调用门决定，但使用RETF返回时，由堆栈中压人的值决定，这就是说，进门时只能按指定路线走，出门时可以翻墙(只要改变堆栈里面的值就可以想去哪去哪)<br>4) 可不可以再建个门出去呢?也就是用Call  当然可以了 前门进 后门出    </p><h1 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h1><p>Windows没有使用调用门，但是使用了中断门：</p><pre><code>&lt;1&gt; 系统调用&lt;2&gt; 调试</code></pre><p>IDT</p><pre><code>IDT即中断描述符表,同GDT一样，IDT也是由一系列描述符组成的，每个描述符占8个字节。但要注意的是，IDT表中的第一个元素不是NULL。在windbg中查看IDT表的基址和长度:</code></pre><p>老的CPU用的中断门，新的用的快速调用</p><p>IDT表都是系统段描述符，都不是空（调用门就有可能是代码数据段，和有空了）</p><p>中断门Type是1110，陷阱门是1111</p><h2 id="陷阱门与中断门的区别"><a href="#陷阱门与中断门的区别" class="headerlink" title="陷阱门与中断门的区别"></a>陷阱门与中断门的区别</h2><p>中断门执行时，将IF位清零,但陷阱门不会。</p><p>在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。</p><pre><code>切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)这2个值从哪里来的呢？答案：TSS (Task-state segment )，任务状态段.</code></pre><h2 id="TSS的结构"><a href="#TSS的结构" class="headerlink" title="TSS的结构"></a>TSS的结构</h2><p>TSS是一块内存，不是寄存器不在CPU中，内存结构如下图，大小104字节  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/8.png" alt="TSS的结构"></p><p>TSS的作用</p><pre><code>Intel的设计思想操作系统的设计思想本质：    不要把TSS与“任务切换”联系到一起    TSS的意义就在于可以同时换掉”一堆”寄存器</code></pre><p>CPU如何找到TSS呢?  TR段寄存器  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/9.png" alt="TR寄存器"></p><p>CPU找TSS直接在TR寄存器，TR的Base指向TSS，Limit是Tss有多大，TSS是操作系统启动时从GDT加载的。TSS是系统段的一种。所以S为是0，Type是1001，说明没有加载到TR寄存器中，1011时是已经加载到TR寄存器。  </p><h2 id="TR寄存器读写"><a href="#TR寄存器读写" class="headerlink" title="TR寄存器读写"></a>TR寄存器读写</h2><ol><li>将TSS段描述符加载到TR寄存器  <pre><code>指令：LTR  说明：用LTR指令去装载的话 仅仅是改变TR寄存器的值(96位) 并没有真正改变TSS  LTR指令只能在系统层使用加载后TSS段描述符会状态位会发生改变就是上面9变B</code></pre></li><li><p>读TR寄存器  </p><pre><code>1. 指令：STR  说明：如果用STR去读的话，只读了TR的16位 也就是选择子  </code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p> TSS是一块内存，大小104字节.通过TSS可以同时替换“一堆”寄存器，包括通用寄存器和段寄存器等.</p><p> CPU通过TR段寄存器来找到TSS.如果我们想用自己的TSS段来替换原来的寄存器，就要修改TR寄存器，TR寄存器的值又是来自TSS段描述符，那么我们接下来先构造一个段描述符。</p></li></ol><p>修改TR寄存器</p><pre><code>1) 在Ring0 我们可以通过LTR指令去修改TR寄存器2) 在Ring3 我们可以通过CALL FAR 或者 JMP FAR指令来修改</code></pre><p>用JMP去访问一个代码段的时候，改变的是CS和EIP ：</p><pre><code>JMP 0x48:0x123456  如果0x48是代码段  执行后：CS--&gt;0x48  EIP--&gt;0x123456</code></pre><p>用JMP去访问一个任务段的时候：</p><pre><code>如果0x48是TSS段描述符，先修改TR寄存器，在用TR.Base指向的TSS中的值修改当前的寄存器</code></pre><h1 id="任务门描述符"><a href="#任务门描述符" class="headerlink" title="任务门描述符"></a>任务门描述符</h1><p>Type为0101即5.<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/10.png" alt="任务门"> </p><p>这是TSS段的描述符（在GDT表），任务门本身在IDT表</p><p>任务门执行过程：</p><p>INT N</p><p>查IDT表，找到中断门描述符</p><p>通过中断门描述符，查GDT表，找到任务段描述符</p><p>使用TSS段中的值修改寄存器</p><p>IRETD返回</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 保护模式段 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>段使用时相关的检查与调用门实验</title>
      <link href="/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/"/>
      <url>/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="段类型检查"><a href="#段类型检查" class="headerlink" title="段类型检查"></a>段类型检查</h1><p>加载段选择符进入段寄存器时候</p><ul><li>CS只能存放可执行的选择符</li><li>不可读可执行不能被加载到数据段寄存器</li><li>只有可写的数据段才能加载到SS</li></ul><h1 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h1><p>当给段寄存器赋值，实际是从GDT中获取相应的段描述符加载到段寄存器的不可见部分。这个时候有个权限检查，有三个概念：</p><ul><li>CPL：当前代码执行权限</li><li>DPL：存在段描述符中，描述访问本段内存需要的权限</li><li>RPL：存在于段寄存器加载时的段选择子中，描述了使用什么样的权限对目标进行访问</li></ul><p>从数值上MAX（CPL，RPL）&lt;DPL.  </p><p>段内跳转不会产生权限检查（JMP，CALL，RET），段间会。 </p><p>当S为0时：</p><ul><li>调用门：Type=12。</li><li>中断门：Type=14。</li><li>陷阱门：Type=15。</li><li>任务门：Type=5。</li></ul><h1 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/duanshiyongjiancha/1.png" alt="调用门图片"><br>调用门描述符中存储了一个代码段的段选择子。<br>指令格式：CALL CS：EIP（EIP废弃的）</p><ul><li>根据CS的值查GDT表，找到对应段描述符，之歌描述符是一个调用门。</li><li>在调用门描述符中存储着另一个代码段的段选择子。</li><li>选择子指向的段，段Base+偏移地址，就是真正要执行的地址。<br>通过调用门可以原图，不过Windows并没有用调用门。 </li></ul><p>段寄存器一共有 96 位，其中16可见部分来源于段选择子的索引部分。剩下80位来源于 GDT表。++<strong>那GDT表64位是怎么表示80位的段描述符呢？</strong>++ 是有一部分是G位为零代表粒度是1字节，在段限长前面补12位000，如果G为1在段限长前面补FFF，FFF刚好4KB。（段限长就是FFFFF）,所以当G=0，即粒度是1B时候，范围就是<br>2^00000000^到2^000FFFFF^即1B到4MB,当G=1，即粒度是1B时候，范围就是2^FFF00000^到2^FFFFFFFF^，即4KB到4GB。</p><h1 id="中断门和陷阱门"><a href="#中断门和陷阱门" class="headerlink" title="中断门和陷阱门"></a>中断门和陷阱门</h1><p>除了GDT外，还有一个地方也存着门描述符，被称为IDT（中断描述符表）。<br>IDT中存着3种门描述符： </p><ul><li>中断门描述符 </li><li>陷阱门描述符</li><li>任务门描述符 </li></ul><p>当S为0，type为1110是个中断门<br>中断门描述符存储着一个断码段选择子。<br>当S为0，type为1111是陷阱门 </p><ul><li>陷阱门用于存放异常处理函数</li><li>中断门用于存放中断处理函数地址</li><li>中断门执行时候IF位会清零，屏蔽可屏蔽中断，陷阱门不会。 </li></ul><h1 id="调用门提权实验"><a href="#调用门提权实验" class="headerlink" title="调用门提权实验"></a>调用门提权实验</h1><p>先确定一个事情，怎么提权？是要构造一个调用门描述符，然后CALL这个段的一个地址所以这个段的DPL得是3环的，所以，在构造的调用门描述符里，DPL位是3即11b，即3环就能访问本段的程序。然后这个调用门里的段选择子（就是13位可见的那部分个）是要执行的段，所以他的段选择子的RPL要是高权限，所以他的RPL应该是00，Ti也0，查GDT第二个就行所以索引是1，所以合起来是1000b，所以段选择子是8，所以要构造的调用门描述符里8，的作用是让其RPL是00为0，环以0环权限去访问，Ti为是0找GDT表，其他位置弄成如下<br>XXXXEC000008XXXX<br>下面的代码相关信息如下</p><ul><li>前后XXXX为偏移，比如你要执行的代码的偏移，即下文函数的入口，构造下面代码</li><li>0x80b95500为任意一个内核空间（高地址空间），为了验证能不能提权，得到内核的信息。</li><li>retf为不仅像ret一样pop ip，还pop cs</li><li>0x00,0x00,0x00,0x00,0x63,0x00 为CS：IP，因为内存以小端寸断存储。所以是这样，IP可以任意</li><li>fword为远跳，6字节的，用于段间跳转。</li><li>CS为0x63，即下面代码要CALL的段选择是0x63，是因为我们找了一个GDT里的空位为第12个位置，所以是1100,然后找GDT，权限是3环，所以段选择子是1100011b，所以这个是63</li><li>注意vs要关闭随机基址，虚拟机要单核，比较好做这个实验</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_num = <span class="number">0</span>;</span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里如果用了 int 3 那么回到3环的时候，会造成程序崩溃，因为回去的时候，FS会被置0；</span></span><br><span class="line">_asm &#123;</span><br><span class="line">push eax;</span><br><span class="line">mov eax, DWORD ptr ds : [<span class="number">0x80b95500</span>];</span><br><span class="line">mov g_num, eax;</span><br><span class="line">pop eax;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">6</span>] = &#123; <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x63</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">_asm &#123;</span><br><span class="line">call fword ptr ds : [buf];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, g_num);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节<br>[2]:<code>https://blog.csdn.net/q1007729991/article/details/52538080</code><br>[3]：李忠，《x86汇编语言:从实模式到保护模式》，电子工业出版社</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 调用门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>段描述符浅谈</title>
      <link href="/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/"/>
      <url>/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/</url>
      <content type="html"><![CDATA[<h1 id="描述符表中存放的是段描述符，如下图所示"><a href="#描述符表中存放的是段描述符，如下图所示" class="headerlink" title="描述符表中存放的是段描述符，如下图所示"></a>描述符表中存放的是段描述符，如下图所示</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/2.PNG" alt="图1-1 段描述符通用格式"></p><h1 id="段描述符基本属性"><a href="#段描述符基本属性" class="headerlink" title="段描述符基本属性"></a>段描述符基本属性</h1><p>段描述符是GDT和LDT中的一个数据结构项，用于向处理器提供有关一个段的位置大小访问控制的信息状态信息，每个段描述符的长度是8个字节，含有3个主要字段</p><ul><li>段基地址</li><li>段限长</li><li>段属性 </li></ul><h2 id="基地址字段Base"><a href="#基地址字段Base" class="headerlink" title="基地址字段Base"></a>基地址字段Base</h2><p>描述了一个短的起始位置，由三个部分组成一共32位，段基地址可以是0~4GB范围内的任意地址(这同实模式不同，实模式下段基地址要求16字节对齐)，但是为了让程序具有最佳性能，还是建议16字节对齐。</p><h2 id="粒度G位"><a href="#粒度G位" class="headerlink" title="粒度G位"></a>粒度G位</h2><p>为0，Limit单位是字节。为1，Limit单位是4KB。</p><h2 id="B-D位-数据段时是B，代码段时是D"><a href="#B-D位-数据段时是B，代码段时是D" class="headerlink" title="B/D位 (数据段时是B，代码段时是D)"></a>B/D位 (数据段时是B，代码段时是D)</h2><ul><li>为B时<ul><li>为0，内存寻址是16位，堆栈使用SP，段的最大大小是64KB。</li><li>为1，内存寻址是32位，堆栈使用ESP，段的最大大小是4GB。</li></ul></li><li>为D时<ul><li>为0，默认值是16位的地址和16位或者8为操作数。</li><li>为1，默认值是32位的地址和32位或者8为操作数。<h2 id="L位（21）"><a href="#L位（21）" class="headerlink" title="L位（21）"></a>L位（21）</h2>是64位代码段标志，保留给64位处理器使用，目前在分析32位时置零即可<h2 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h2>是软件可以使用的位，通常由操作系统使用，处理器不使用它<h2 id="段限长Limit"><a href="#段限长Limit" class="headerlink" title="段限长Limit"></a>段限长Limit</h2>处理器会把段描述符中两个段限长字段组合成一个20位的值，并根据颗粒度标志G来知道段限长Limit值的实际含义。<h2 id="描述符有效位P位"><a href="#描述符有效位P位" class="headerlink" title="描述符有效位P位"></a>描述符有效位P位</h2>为1则段描述符有效，为0则段描述符无效<h2 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h2>存在于段描述符中，描述了访问本地内存需要的权限。<h2 id="S与TYPE"><a href="#S与TYPE" class="headerlink" title="S与TYPE"></a>S与TYPE</h2>应用程序有数据段和代码段，cpu还有系统段和门描述符，用来管理任务，异常，中断。并非所有的描述符都定义一个段，门描述符中存放着一个指向过程入口点的指针，S和Type字段表明了描述符的类型信息。</li></ul></li></ul><table><thead><tr><th>S位</th><th>Type域</th></tr></thead><tbody><tr><td>为1代码是一个代码段或者数据段，0是一个系统段</td><td>一共4位，在S位不同时，含义不同</td><td></td></tr></tbody></table><p>当S为1时，Tpye的四位，11位为0时是数据段，1时是代码段。</p><ul><li><p>当时数据段时，后面10,9,8位为EWA</p><ul><li>10号位为E扩展位，0向上扩展，1向下扩展，向上扩展就是正常的扩展，向上扩展一段空间，扩展的空间可用，向下扩展就是向上扩展一下，除了这段，其他的都在段内，如图<img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/1.png" alt="图1-2 向上扩展和向下扩展"></li><li>9号位为W，为是否可写（代码段可定都是可读的所以不需要这样的属性标志）</li><li>8号位为A，为是否已被访问</li></ul></li><li><p>当时代码段时，后面10,9,8位为CRA  </p><ul><li>10号位为一致性段位，0是非一致性段，1是一致性段  <ul><li><strong>非一致代码段：</strong>  受到隔离的代码，只能在同一级别间互相访问。</li><li><strong>一致性代码段：</strong>  不受隔离，允许被同等级货低等级代码调用。</li></ul></li><li>9号位为R，为是否可读（代码段都是可执行的）</li><li>8号位为A，为是否已被访问</li></ul></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 保护模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown用法之表格单元格合并</title>
      <link href="/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/"/>
      <url>/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p>Markdown语法本身不包含复杂表格的插入，但是可以使用html语法来实现。</p><p>水平单元格的合并：基于colspan属性，即使一个单元格占多列的空间<br>纵向单元格的合并：基于rowspan属性，即使一个单元格占多行的空间<br>要想MarkDown中插入复杂表格时，可以先在word或excel中把表格写好，然后在如下网站进行转化为标记对形式：</p><p><a href="http://pressbin.com/tools/excel_to_html_table/index.html" target="_blank" rel="noopener">http://pressbin.com/tools/excel_to_html_table/index.html</a></p><p>然后删除空标记对，并设置colspan和rowspan属性即可。<br>比如  <code>&lt;td colspan=&quot;8&quot;&gt;基地址Base31到24&lt;/td&gt;</code>就是合并8列单元格</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> 文本编辑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序二进制特征</title>
      <link href="/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/"/>
      <url>/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/</url>
      <content type="html"><![CDATA[<h1 id="常用程序的特征"><a href="#常用程序的特征" class="headerlink" title="常用程序的特征"></a>常用程序的特征</h1><h2 id="1-BC"><a href="#1-BC" class="headerlink" title="1.BC++"></a>1.BC++</h2><h2 id="2Delphi"><a href="#2Delphi" class="headerlink" title="2Delphi"></a>2Delphi</h2><h2 id="3易语言"><a href="#3易语言" class="headerlink" title="3易语言"></a>3易语言</h2><h2 id="4VB"><a href="#4VB" class="headerlink" title="4VB"></a>4VB</h2><h2 id="3VC"><a href="#3VC" class="headerlink" title="3VC++"></a>3VC++</h2><h1 id="分析BC-程序特征"><a href="#分析BC-程序特征" class="headerlink" title="分析BC++程序特征"></a>分析BC++程序特征</h1><p>OPE特征    EB 10  Fb c++hook<br>二进制特征：EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90</p><p>第一个CALL内有API调用 GetMouduleHandleA</p><h1 id="分析Delphi程序特征"><a href="#分析Delphi程序特征" class="headerlink" title="分析Delphi程序特征"></a>分析Delphi程序特征</h1><p>OPE特征  5个Call ，上面全是地址，后面全是0，第一个CALL内有API调用 GetMouduleHandleA</p><p>调用函数时，跳转IAT时OPCODE跳转是FF25，VC是FF15</p><p>区段名比较细致</p><p>CODE，DATA，BSS（），idata，tls，rdata，reloc，rsrc</p><p>链接器版本<br>2.25</p><h1 id="分析VS程序"><a href="#分析VS程序" class="headerlink" title="分析VS程序"></a>分析VS程序</h1><p>VC6.0  6.0<br>VC2003 7.0 7.1<br>VC2005 8.0<br>VC2008   9.0<br>VS2010   10<br>VS2012   11<br>VS2015   14.0<br>VS2017  14.1  </p><h1 id="分析VC6-0和易语言程序特征"><a href="#分析VC6-0和易语言程序特征" class="headerlink" title="分析VC6.0和易语言程序特征"></a>分析VC6.0和易语言程序特征</h1><p>这两个编译器一样，链接器都是6.0版本，第一个api调用getversion，<br>Sub esp，0x58</p><h1 id="逆向步骤"><a href="#逆向步骤" class="headerlink" title="逆向步骤"></a>逆向步骤</h1><p>拿到程序  </p><h2 id="1-确定格式和加密"><a href="#1-确定格式和加密" class="headerlink" title="1.确定格式和加密"></a>1.确定格式和加密</h2><h2 id="2-根据分析，选择工具全面静态分析"><a href="#2-根据分析，选择工具全面静态分析" class="headerlink" title="2.根据分析，选择工具全面静态分析"></a>2.根据分析，选择工具全面静态分析</h2><p>1.查看链接器版本（4.20-VB5，2.25-Delphi7）<br>2.查看OEP代码，是否加壳，未加壳的编译器环境（代码是否正常，pushad这类不正常）<br>3.查看区段（.text 微软 CODE 宝蓝）<br>4.查看导入导出 表（函数名）<br>5.查看资源信息（有无自定义资源）<br>6.查看TLS信息息（有无设置TLS回调函数）<br>7.文件大小，图标  </p><h2 id="3-使用完PE工具，在使用其他工具进行分析"><a href="#3-使用完PE工具，在使用其他工具进行分析" class="headerlink" title="3.使用完PE工具，在使用其他工具进行分析"></a>3.使用完PE工具，在使用其他工具进行分析</h2><p>1.如果加壳，就脱壳，如果是强壳还是需要脱壳才能分析，那就先找OEP再转存到文件，结合IDA进行分析。<br>2.若果程序为保护，看引用了API之类的，根据API确定实现的功能，比如文件操作，网络操作，注册表操作。用监控类工具分析，分析日志，，再进行下一步分析，如果需要分析网络数据可以使用抓包工具。<br>3.如果其他的文件，如资源文件，分析字符串推测功能<br>4.如果程序有安装目录，目录每个文件子目录都要查看  </p><h2 id="4-根据静态分析情况，再动态分析"><a href="#4-根据静态分析情况，再动态分析" class="headerlink" title="4.根据静态分析情况，再动态分析"></a>4.根据静态分析情况，再动态分析</h2><p>第一种，单步跟踪调试，就是从程序加载开始跟踪，一直到找到需要的信息。<br>第二种，附加调试程序，这是在程序运行的状态下，附加进程，进行分析，一般在API下断，然后栈回溯进行分析，还有一种就是如果是窗口程序，我们可以通过窗口回调函数然后进行分析。  </p><h2 id="5-动静结合"><a href="#5-动静结合" class="headerlink" title="5.动静结合"></a>5.动静结合</h2><p>OD，IDA<br>如果分析中还是有很多困难，那么就需要使用IDA/OD等工具进行进一步的分析，尤其是字符串。<br>根据字符串，下断栈回溯分析。  </p><h2 id="6-使用源码对比法，辅助逆向"><a href="#6-使用源码对比法，辅助逆向" class="headerlink" title="6.使用源码对比法，辅助逆向"></a>6.使用源码对比法，辅助逆向</h2><p>分析程序，用了什么库，写代码demo反汇编我们的程序进行对比，提高逆向效率  </p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 反汇编 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/20/hello-world/"/>
      <url>/2018/06/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
