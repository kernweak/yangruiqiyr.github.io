<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>段使用时相关的检查与调用门实验</title>
      <link href="/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/"/>
      <url>/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="段类型检查"><a href="#段类型检查" class="headerlink" title="段类型检查"></a>段类型检查</h1><p>加载段选择符进入段寄存器时候</p><ul><li>CS只能存放可执行的选择符</li><li>不可读可执行不能被加载到数据段寄存器</li><li>只有可写的数据段才能加载到SS</li></ul><h1 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h1><p>当给段寄存器赋值，实际是从GDT中获取相应的段描述符加载到段寄存器的不可见部分。这个时候有个权限检查，有三个概念：</p><ul><li>CPL：当前代码执行权限</li><li>DPL：存在段描述符中，描述访问本段内存需要的权限</li><li>RPL：存在于段寄存器加载时的段选择子中，描述了使用什么样的权限对目标进行访问</li></ul><p>从数值上MAX（CPL，RPL）&lt;DPL.  </p><p>段内跳转不会产生权限检查（JMP，CALL，RET），段间会。 </p><p>当S为0时：</p><ul><li>调用门：Type=12。</li><li>中断门：Type=14。</li><li>陷阱门：Type=15。</li><li>任务门：Type=5。</li></ul><h1 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/duanshiyongjiancha/1.png" alt="调用门图片"><br>调用门描述符中存储了一个代码段的段选择子。<br>指令格式：CALL CS：EIP（EIP废弃的）</p><ul><li>根据CS的值查GDT表，找到对应段描述符，之歌描述符是一个调用门。</li><li>在调用门描述符中存储着另一个代码段的段选择子。</li><li>选择子指向的段，段Base+偏移地址，就是真正要执行的地址。<br>通过调用门可以原图，不过Windows并没有用调用门。 </li></ul><p>段寄存器一共有 96 位，其中16可见部分来源于段选择子的索引部分。剩下80位来源于 GDT表。++<strong>那GDT表64位是怎么表示80位的段描述符呢？</strong>++ 是有一部分是G位为零代表粒度是1字节，在段限长前面补12位000，如果G为1在段限长前面补FFF，FFF刚好4KB。（段限长就是FFFFF）,所以当G=0，即粒度是1B时候，范围就是<br>2^00000000^到2^000FFFFF^即1B到4MB,当G=1，即粒度是1B时候，范围就是2^FFF00000^到2^FFFFFFFF^，即4KB到4GB。</p><h1 id="中断门和陷阱门"><a href="#中断门和陷阱门" class="headerlink" title="中断门和陷阱门"></a>中断门和陷阱门</h1><p>除了GDT外，还有一个地方也存着门描述符，被称为IDT（中断描述符表）。<br>IDT中存着3种门描述符： </p><ul><li>中断门描述符 </li><li>陷阱门描述符</li><li>任务门描述符 </li></ul><p>当S为0，type为1110是个中断门<br>中断门描述符存储着一个断码段选择子。<br>当S为0，type为1111是陷阱门 </p><ul><li>陷阱门用于存放异常处理函数</li><li>中断门用于存放中断处理函数地址</li><li>中断门执行时候IF位会清零，屏蔽可屏蔽中断，陷阱门不会。 </li></ul><h1 id="调用门提权实验"><a href="#调用门提权实验" class="headerlink" title="调用门提权实验"></a>调用门提权实验</h1><p>先确定一个事情，怎么提权？是要构造一个调用门描述符，然后CALL这个段的一个地址所以这个段的DPL得是3环的，所以，在构造的调用门描述符里，DPL位是3即11b，即3环就能访问本段的程序。然后这个调用门里的段选择子（就是13位可见的那部分个）是要执行的段，所以他的段选择子的RPL要是高权限，所以他的RPL应该是00，Ti也0，查GDT第二个就行所以索引是1，所以合起来是1000b，所以段选择子是8，所以要构造的调用门描述符里8，的作用是让其RPL是00为0，环以0环权限去访问，Ti为是0找GDT表，其他位置弄成如下<br>XXXXEC000008XXXX<br>下面的代码相关信息如下</p><ul><li>前后XXXX为偏移，比如你要执行的代码的偏移，即下文函数的入口，构造下面代码</li><li>0x80b95500为任意一个内核空间（高地址空间），为了验证能不能提权，得到内核的信息。</li><li>retf为不仅像ret一样pop ip，还pop cs</li><li>0x00,0x00,0x00,0x00,0x63,0x00 为CS：IP，因为内存以小端寸断存储。所以是这样，IP可以任意</li><li>fword为远跳，6字节的，用于段间跳转。</li><li>CS为0x63，即下面代码要CALL的段选择是0x63，是因为我们找了一个GDT里的空位为第12个位置，所以是1100,然后找GDT，权限是3环，所以段选择子是1100011b，所以这个是63</li><li>注意vs要关闭随机基址，虚拟机要单核，比较好做这个实验</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_num = <span class="number">0</span>;</span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里如果用了 int 3 那么回到3环的时候，会造成程序崩溃，因为回去的时候，FS会被置0；</span></span><br><span class="line">_asm &#123;</span><br><span class="line">push eax;</span><br><span class="line">mov eax, DWORD ptr ds : [<span class="number">0x80b95500</span>];</span><br><span class="line">mov g_num, eax;</span><br><span class="line">pop eax;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">6</span>] = &#123; <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x63</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">_asm &#123;</span><br><span class="line">call fword ptr ds : [buf];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, g_num);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节<br>[2]:<code>https://blog.csdn.net/q1007729991/article/details/52538080</code><br>[3]：李忠，《x86汇编语言:从实模式到保护模式》，电子工业出版社</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调用门 </tag>
            
            <tag> 保护模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>段描述符浅谈</title>
      <link href="/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/"/>
      <url>/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/</url>
      <content type="html"><![CDATA[<h1 id="描述符表中存放的是段描述符，如下图所示"><a href="#描述符表中存放的是段描述符，如下图所示" class="headerlink" title="描述符表中存放的是段描述符，如下图所示"></a>描述符表中存放的是段描述符，如下图所示</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/2.PNG" alt="图1-1 段描述符通用格式"></p><h1 id="段描述符基本属性"><a href="#段描述符基本属性" class="headerlink" title="段描述符基本属性"></a>段描述符基本属性</h1><p>段描述符是GDT和LDT中的一个数据结构项，用于向处理器提供有关一个段的位置大小访问控制的信息状态信息，每个段描述符的长度是8个字节，含有3个主要字段</p><ul><li>段基地址</li><li>段限长</li><li>段属性 </li></ul><h2 id="基地址字段Base"><a href="#基地址字段Base" class="headerlink" title="基地址字段Base"></a>基地址字段Base</h2><p>描述了一个短的起始位置，由三个部分组成一共32位，段基地址可以是0~4GB范围内的任意地址(这同实模式不同，实模式下段基地址要求16字节对齐)，但是为了让程序具有最佳性能，还是建议16字节对齐。</p><h2 id="粒度G位"><a href="#粒度G位" class="headerlink" title="粒度G位"></a>粒度G位</h2><p>为0，Limit单位是字节。为1，Limit单位是4KB。</p><h2 id="B-D位-数据段时是B，代码段时是D"><a href="#B-D位-数据段时是B，代码段时是D" class="headerlink" title="B/D位 (数据段时是B，代码段时是D)"></a>B/D位 (数据段时是B，代码段时是D)</h2><ul><li>为B时<ul><li>为0，内存寻址是16位，堆栈使用SP，段的最大大小是64KB。</li><li>为1，内存寻址是32位，堆栈使用ESP，段的最大大小是4GB。</li></ul></li><li>为D时<ul><li>为0，默认值是16位的地址和16位或者8为操作数。</li><li>为1，默认值是32位的地址和32位或者8为操作数。<h2 id="L位（21）"><a href="#L位（21）" class="headerlink" title="L位（21）"></a>L位（21）</h2>是64位代码段标志，保留给64位处理器使用，目前在分析32位时置零即可<h2 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h2>是软件可以使用的位，通常由操作系统使用，处理器不使用它<h2 id="段限长Limit"><a href="#段限长Limit" class="headerlink" title="段限长Limit"></a>段限长Limit</h2>处理器会把段描述符中两个段限长字段组合成一个20位的值，并根据颗粒度标志G来知道段限长Limit值的实际含义。<h2 id="描述符有效位P位"><a href="#描述符有效位P位" class="headerlink" title="描述符有效位P位"></a>描述符有效位P位</h2>为1则段描述符有效，为0则段描述符无效<h2 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h2>存在于段描述符中，描述了访问本地内存需要的权限。<h2 id="S与TYPE"><a href="#S与TYPE" class="headerlink" title="S与TYPE"></a>S与TYPE</h2>应用程序有数据段和代码段，cpu还有系统段和门描述符，用来管理任务，异常，中断。并非所有的描述符都定义一个段，门描述符中存放着一个指向过程入口点的指针，S和Type字段表明了描述符的类型信息。</li></ul></li></ul><table><thead><tr><th>S位</th><th>Type域</th></tr></thead><tbody><tr><td>为1代码是一个代码段或者数据段，0是一个系统段</td><td>一共4位，在S位不同时，含义不同</td><td></td></tr></tbody></table><p>当S为1时，Tpye的四位，11位为0时是数据段，1时是代码段。</p><ul><li><p>当时数据段时，后面10,9,8位为EWA</p><ul><li>10号位为E扩展位，0向上扩展，1向下扩展，向上扩展就是正常的扩展，向上扩展一段空间，扩展的空间可用，向下扩展就是向上扩展一下，除了这段，其他的都在段内，如图<img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/1.png" alt="图1-2 向上扩展和向下扩展"></li><li>9号位为W，为是否可写（代码段可定都是可读的所以不需要这样的属性标志）</li><li>8号位为A，为是否已被访问</li></ul></li><li><p>当时代码段时，后面10,9,8位为CRA  </p><ul><li>10号位为一致性段位，0是非一致性段，1是一致性段  <ul><li><strong>非一致代码段：</strong>  受到隔离的代码，只能在同一级别间互相访问。</li><li><strong>一致性代码段：</strong>  不受隔离，允许被同等级货低等级代码调用。</li></ul></li><li>9号位为R，为是否可读（代码段都是可执行的）</li><li>8号位为A，为是否已被访问</li></ul></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown用法之表格单元格合并</title>
      <link href="/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/"/>
      <url>/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p>Markdown语法本身不包含复杂表格的插入，但是可以使用html语法来实现。</p><p>水平单元格的合并：基于colspan属性，即使一个单元格占多列的空间<br>纵向单元格的合并：基于rowspan属性，即使一个单元格占多行的空间<br>要想MarkDown中插入复杂表格时，可以先在word或excel中把表格写好，然后在如下网站进行转化为标记对形式：</p><p><a href="http://pressbin.com/tools/excel_to_html_table/index.html" target="_blank" rel="noopener">http://pressbin.com/tools/excel_to_html_table/index.html</a></p><p>然后删除空标记对，并设置colspan和rowspan属性即可。<br>比如  <code>&lt;td colspan=&quot;8&quot;&gt;基地址Base31到24&lt;/td&gt;</code>就是合并8列单元格</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> 文本编辑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序二进制特征</title>
      <link href="/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/"/>
      <url>/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/</url>
      <content type="html"><![CDATA[<h1 id="常用程序的特征"><a href="#常用程序的特征" class="headerlink" title="常用程序的特征"></a>常用程序的特征</h1><h2 id="1-BC"><a href="#1-BC" class="headerlink" title="1.BC++"></a>1.BC++</h2><h2 id="2Delphi"><a href="#2Delphi" class="headerlink" title="2Delphi"></a>2Delphi</h2><h2 id="3易语言"><a href="#3易语言" class="headerlink" title="3易语言"></a>3易语言</h2><h2 id="4VB"><a href="#4VB" class="headerlink" title="4VB"></a>4VB</h2><h2 id="3VC"><a href="#3VC" class="headerlink" title="3VC++"></a>3VC++</h2><h1 id="分析BC-程序特征"><a href="#分析BC-程序特征" class="headerlink" title="分析BC++程序特征"></a>分析BC++程序特征</h1><p>OPE特征    EB 10  Fb c++hook<br>二进制特征：EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90</p><p>第一个CALL内有API调用 GetMouduleHandleA</p><h1 id="分析Delphi程序特征"><a href="#分析Delphi程序特征" class="headerlink" title="分析Delphi程序特征"></a>分析Delphi程序特征</h1><p>OPE特征  5个Call ，上面全是地址，后面全是0，第一个CALL内有API调用 GetMouduleHandleA</p><p>调用函数时，跳转IAT时OPCODE跳转是FF25，VC是FF15</p><p>区段名比较细致</p><p>CODE，DATA，BSS（），idata，tls，rdata，reloc，rsrc</p><p>链接器版本<br>2.25</p><h1 id="分析VS程序"><a href="#分析VS程序" class="headerlink" title="分析VS程序"></a>分析VS程序</h1><p>VC6.0  6.0<br>VC2003 7.0 7.1<br>VC2005 8.0<br>VC2008   9.0<br>VS2010   10<br>VS2012   11<br>VS2015   14.0<br>VS2017  14.1  </p><h1 id="分析VC6-0和易语言程序特征"><a href="#分析VC6-0和易语言程序特征" class="headerlink" title="分析VC6.0和易语言程序特征"></a>分析VC6.0和易语言程序特征</h1><p>这两个编译器一样，链接器都是6.0版本，第一个api调用getversion，<br>Sub esp，0x58</p><h1 id="逆向步骤"><a href="#逆向步骤" class="headerlink" title="逆向步骤"></a>逆向步骤</h1><p>拿到程序  </p><h2 id="1-确定格式和加密"><a href="#1-确定格式和加密" class="headerlink" title="1.确定格式和加密"></a>1.确定格式和加密</h2><h2 id="2-根据分析，选择工具全面静态分析"><a href="#2-根据分析，选择工具全面静态分析" class="headerlink" title="2.根据分析，选择工具全面静态分析"></a>2.根据分析，选择工具全面静态分析</h2><p>1.查看链接器版本（4.20-VB5，2.25-Delphi7）<br>2.查看OEP代码，是否加壳，未加壳的编译器环境（代码是否正常，pushad这类不正常）<br>3.查看区段（.text 微软 CODE 宝蓝）<br>4.查看导入导出 表（函数名）<br>5.查看资源信息（有无自定义资源）<br>6.查看TLS信息息（有无设置TLS回调函数）<br>7.文件大小，图标  </p><h2 id="3-使用完PE工具，在使用其他工具进行分析"><a href="#3-使用完PE工具，在使用其他工具进行分析" class="headerlink" title="3.使用完PE工具，在使用其他工具进行分析"></a>3.使用完PE工具，在使用其他工具进行分析</h2><p>1.如果加壳，就脱壳，如果是强壳还是需要脱壳才能分析，那就先找OEP再转存到文件，结合IDA进行分析。<br>2.若果程序为保护，看引用了API之类的，根据API确定实现的功能，比如文件操作，网络操作，注册表操作。用监控类工具分析，分析日志，，再进行下一步分析，如果需要分析网络数据可以使用抓包工具。<br>3.如果其他的文件，如资源文件，分析字符串推测功能<br>4.如果程序有安装目录，目录每个文件子目录都要查看  </p><h2 id="4-根据静态分析情况，再动态分析"><a href="#4-根据静态分析情况，再动态分析" class="headerlink" title="4.根据静态分析情况，再动态分析"></a>4.根据静态分析情况，再动态分析</h2><p>第一种，单步跟踪调试，就是从程序加载开始跟踪，一直到找到需要的信息。<br>第二种，附加调试程序，这是在程序运行的状态下，附加进程，进行分析，一般在API下断，然后栈回溯进行分析，还有一种就是如果是窗口程序，我们可以通过窗口回调函数然后进行分析。  </p><h2 id="5-动静结合"><a href="#5-动静结合" class="headerlink" title="5.动静结合"></a>5.动静结合</h2><p>OD，IDA<br>如果分析中还是有很多困难，那么就需要使用IDA/OD等工具进行进一步的分析，尤其是字符串。<br>根据字符串，下断栈回溯分析。  </p><h2 id="6-使用源码对比法，辅助逆向"><a href="#6-使用源码对比法，辅助逆向" class="headerlink" title="6.使用源码对比法，辅助逆向"></a>6.使用源码对比法，辅助逆向</h2><p>分析程序，用了什么库，写代码demo反汇编我们的程序进行对比，提高逆向效率  </p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 反汇编 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/20/hello-world/"/>
      <url>/2018/06/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
