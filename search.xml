<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>object_Hook相关知识</title>
      <link href="/2018/06/28/object-Hook%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/06/28/object-Hook%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h4 id="首先，分析OBJECT（内核对象）"><a href="#首先，分析OBJECT（内核对象）" class="headerlink" title="首先，分析OBJECT（内核对象）"></a>首先，分析OBJECT（内核对象）</h4><p>先找到一个进程内核对象的地址，使用!process 0 0查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROCESS 885de030  SessionId: 1  Cid: 0700    Peb: 7ffd9000  ParentCid: 0418</span><br><span class="line">    DirBase: 7f3602e0  ObjectTable: 98a8c548  HandleCount:  60.</span><br><span class="line">    Image: Commnuication_ring3.exe</span><br></pre></td></tr></table></figure><p>然后查看最后一个这个进程   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kd&gt; dt _OBJECT_HEADER 885de030-18</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : 0n41</span><br><span class="line">   +0x004 HandleCount      : 0n2</span><br><span class="line">   +0x004 NextToFree       : 0x00000002 Void</span><br><span class="line">   +0x008 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x00c TypeIndex        : 0x7 &apos;&apos;</span><br><span class="line">   +0x00d TraceFlags       : 0 &apos;&apos;</span><br><span class="line">   +0x00e InfoMask         : 0x8 &apos;&apos;</span><br><span class="line">   +0x00f Flags            : 0 &apos;&apos;</span><br><span class="line">   +0x010 ObjectCreateInfo : 0x83f78cc0 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x010 QuotaBlockCharged : 0x83f78cc0 Void</span><br><span class="line">   +0x014 SecurityDescriptor : 0x8c6f64fe Void</span><br><span class="line">   +0x018 Body             : _QUAD</span><br></pre></td></tr></table></figure><p>PointerCount保存的是对象的指针计数，HandeCount保存的是对象句柄计数（也就是我们说的引用计数）<br>当我们通过API得到对象的句柄：   </p><ul><li>打开一个对象时，对象指针计数（差了下windows内核情景分析一书，这个翻译成引用计数，感觉更好一些，因为如果是引用计数，后面获得对象就不会增加句柄计数，指挥增加引用计数）与句柄计数都会被加1。   </li><li>关闭句柄的时候，对象的指针计数和句柄计数都会被减一。   </li><li>我们在内核层获得对象时，会增加其指针计数，一般我们需要通过ObDeferenceObject降低计数。   </li><li>当指针计数与句柄计数都为0，内核对象回本销毁。  </li><li>TypeIndex表示对象的类型，他是一个数组的下标，数组名叫做ObTypeIndexTable.由nt模块导出   </li></ul><p>下面查看一下ObTypeIndexTable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd ObTypeIndexTable</span><br><span class="line">83f86900  00000000 bad0b0b0 86544768 865446a0</span><br><span class="line">83f86910  865445d8 865de040 865def00 865dee38</span><br><span class="line">83f86920  865ded70 865deca8 865debe0 865de528</span><br><span class="line">83f86930  866059c8 86601418 86601350 866094d0</span><br><span class="line">83f86940  86609408 86609340 865f5de8 865f5d20</span><br><span class="line">83f86950  865f5c58 865fac90 865fabc8 865fab00</span><br><span class="line">83f86960  865faa38 865fa970 865fa8a8 865fa7e0</span><br><span class="line">83f86970  865fa718 86603f78 86603eb0 86603de8</span><br></pre></td></tr></table></figure><p>上面的对象是这个里面第七个位置的类型，查看一下，7号位置就是865dee38，他是_OBJECT_TYPE的地址。我们查看_OBJECT_TYPE的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE 865dee38</span><br><span class="line">ntdll!_OBJECT_TYPE</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY [ 0x865dee38 - 0x865dee38 ]</span><br><span class="line">   +0x008 Name             : _UNICODE_STRING &quot;Process&quot;</span><br><span class="line">   +0x010 DefaultObject    : (null) </span><br><span class="line">   +0x014 Index            : 0x7 &apos;&apos;</span><br><span class="line">   +0x018 TotalNumberOfObjects : 0x23</span><br><span class="line">   +0x01c TotalNumberOfHandles : 0xcc</span><br><span class="line">   +0x020 HighWaterNumberOfObjects : 0x2a</span><br><span class="line">   +0x024 HighWaterNumberOfHandles : 0x104</span><br><span class="line">   +0x028 TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x078 TypeLock         : _EX_PUSH_LOCK</span><br><span class="line">   +0x07c Key              : 0x636f7250</span><br><span class="line">   +0x080 CallbackList     : _LIST_ENTRY [ 0x865deeb8 - 0x865deeb8 ]</span><br></pre></td></tr></table></figure><p>接下来，我们再分析一下_OBJECT_TYPE,其中有一个TypeInfo类型是OBJECT_TYPE_INITIALIZER</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE_INITIALIZER</span><br><span class="line">ntdll!_OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x000 Length           : Uint2B</span><br><span class="line">   +0x002 ObjectTypeFlags  : UChar</span><br><span class="line">   +0x002 CaseInsensitive  : Pos 0, 1 Bit</span><br><span class="line">   +0x002 UnnamedObjectsOnly : Pos 1, 1 Bit</span><br><span class="line">   +0x002 UseDefaultObject : Pos 2, 1 Bit</span><br><span class="line">   +0x002 SecurityRequired : Pos 3, 1 Bit</span><br><span class="line">   +0x002 MaintainHandleCount : Pos 4, 1 Bit</span><br><span class="line">   +0x002 MaintainTypeList : Pos 5, 1 Bit</span><br><span class="line">   +0x002 SupportsObjectCallbacks : Pos 6, 1 Bit</span><br><span class="line">   +0x004 ObjectTypeCode   : Uint4B</span><br><span class="line">   +0x008 InvalidAttributes : Uint4B</span><br><span class="line">   +0x00c GenericMapping   : _GENERIC_MAPPING</span><br><span class="line">   +0x01c ValidAccessMask  : Uint4B</span><br><span class="line">   +0x020 RetainAccess     : Uint4B</span><br><span class="line">   +0x024 PoolType         : _POOL_TYPE</span><br><span class="line">   +0x028 DefaultPagedPoolCharge : Uint4B</span><br><span class="line">   +0x02c DefaultNonPagedPoolCharge : Uint4B</span><br><span class="line">   +0x030 DumpProcedure    : Ptr32     void </span><br><span class="line">   +0x034 OpenProcedure    : Ptr32     long </span><br><span class="line">   +0x038 CloseProcedure   : Ptr32     void </span><br><span class="line">   +0x03c DeleteProcedure  : Ptr32     void </span><br><span class="line">   +0x040 ParseProcedure   : Ptr32     long </span><br><span class="line">   +0x044 SecurityProcedure : Ptr32     long </span><br><span class="line">   +0x048 QueryNameProcedure : Ptr32     long </span><br><span class="line">   +0x04c OkayToCloseProcedure : Ptr32     unsigned char</span><br></pre></td></tr></table></figure><p>我们在内核层经常需要使用一个内核对象句柄获得内核对象，比如用户层传入一个时间对象句柄，用于分析内核层与用户层进行同步。<br>我们可以使用ObReferenceObjectByHandle函数根据句柄获得内核对象<br>注意：   </p><ul><li>当你调用这个函数时候，需要确保处于当前进程环境。   </li><li>用户模式的句柄，将AccessMode指定为userMode   </li><li>使用完毕，请调用ObDererfanceObject降低指针引用计数。   </li></ul><h1 id="下面就是相关的代码"><a href="#下面就是相关的代码" class="headerlink" title="下面就是相关的代码"></a>下面就是相关的代码</h1><p>通过内核对下头部，能够获得此类型内核对象的创建信息，在这些信息中有一组函数指针非常重要。<br>我们通过Hook这些函数指针，能够达到监控内核对象操作的目的。<br>这种Hook被称为Object-Hook，下面的代码平台是Win32<br>总得来说就是找到地址然后把在OBJECT_TYPE里OBJECT_TYPE_INITIALIZER的参数ParseProcedure替换成自己的    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT objDriver)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ULONG</span><span class="params">(*OBGETOBJECTTYPE)</span><span class="params">(PVOID Object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(*PARSEPRODECEDURE)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID ParseObject,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PVOID ObjectType,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PACCESS_STATE AccessState,</span></span></span><br><span class="line"><span class="function"><span class="params">IN KPROCESSOR_MODE AccessMode,</span></span></span><br><span class="line"><span class="function"><span class="params">IN ULONG Attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING CompleteName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING RemainingName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PVOID Context OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">OUT PVOID *Object)</span></span>;</span><br><span class="line">PARSEPRODECEDURE g_OldFun;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">NewParseProcedure</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID ParseObject,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PVOID ObjectType,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PACCESS_STATE AccessState,</span></span></span><br><span class="line"><span class="function"><span class="params">IN KPROCESSOR_MODE AccessMode,</span></span></span><br><span class="line"><span class="function"><span class="params">IN ULONG Attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING CompleteName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PUNICODE_STRING RemainingName,</span></span></span><br><span class="line"><span class="function"><span class="params">IN OUT PVOID Context OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">OUT PVOID *Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">KdPrint((<span class="string">"Hook Success\n"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> g_OldFun(ParseObject, ObjectType, AccessState, AccessMode, Attributes,</span><br><span class="line">CompleteName,</span><br><span class="line">RemainingName, Context, SecurityQos, Object);</span><br><span class="line">&#125;</span><br><span class="line">OBGETOBJECTTYPE g_OBGetObjectType;</span><br><span class="line"><span class="comment">//获得一个函数地址，这个函数能够通过内核对象得到内核对象的类型</span></span><br><span class="line"><span class="function">VOID <span class="title">GetObjectTypeAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PUCHAR addr;</span><br><span class="line">UNICODE_STRING pslookup;</span><br><span class="line">RtlInitUnicodeString(&amp;pslookup, <span class="string">L"ObGetObjectType"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//               类似于应用层的GetProcAddress</span></span><br><span class="line">addr = (PUCHAR)MmGetSystemRoutineAddress(&amp;pslookup);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_OBGetObjectType = (OBGETOBJECTTYPE)addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span> &#123;</span></span><br><span class="line">USHORT Length;</span><br><span class="line">UCHAR ObjectTypeFlags;</span><br><span class="line">UCHAR CaseInsensitive;</span><br><span class="line">UCHAR UnnamedObjectsOnly;</span><br><span class="line">UCHAR  UseDefaultObject;</span><br><span class="line">UCHAR  SecurityRequired;</span><br><span class="line">UCHAR MaintainHandleCount;</span><br><span class="line">UCHAR MaintainTypeList;</span><br><span class="line">UCHAR SupportsObjectCallbacks;</span><br><span class="line">UCHAR CacheAligned;</span><br><span class="line">ULONG ObjectTypeCode;</span><br><span class="line">BOOLEAN InvalidAttributes;</span><br><span class="line">GENERIC_MAPPING GenericMapping;</span><br><span class="line">BOOLEAN   ValidAccessMask;</span><br><span class="line">BOOLEAN   RetainAccess;</span><br><span class="line">POOL_TYPE PoolType;</span><br><span class="line">BOOLEAN DefaultPagedPoolCharge;</span><br><span class="line">BOOLEAN DefaultNonPagedPoolCharge;</span><br><span class="line">PVOID DumpProcedure;</span><br><span class="line">ULONG OpenProcedure;</span><br><span class="line">PVOID CloseProcedure;</span><br><span class="line">PVOID DeleteProcedure;</span><br><span class="line">ULONG ParseProcedure;</span><br><span class="line">ULONG SecurityProcedure;</span><br><span class="line">ULONG QueryNameProcedure;</span><br><span class="line">UCHAR OkayToCloseProcedure;</span><br><span class="line">&#125; OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE</span> &#123;</span></span><br><span class="line">LIST_ENTRY TypeList;</span><br><span class="line">UNICODE_STRING Name;</span><br><span class="line">PVOID DefaultObject;</span><br><span class="line">ULONG Index;</span><br><span class="line">ULONG TotalNumberOfObjects;</span><br><span class="line">ULONG TotalNumberOfHandles;</span><br><span class="line">ULONG HighWaterNumberOfObjects;</span><br><span class="line">ULONG HighWaterNumberOfHandles;</span><br><span class="line">OBJECT_TYPE_INITIALIZER TypeInfo;</span><br><span class="line">ULONG  TypeLock;</span><br><span class="line">ULONG   Key;</span><br><span class="line">LIST_ENTRY   CallbackList;</span><br><span class="line">&#125; OBJECT_TYPE, *POBJECT_TYPE;</span><br><span class="line"><span class="function">HANDLE <span class="title">KernelCreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IN PUNICODE_STRING pstrFile, <span class="comment">// 文件路径符号链接</span></span></span></span><br><span class="line"><span class="function"><span class="params">IN BOOLEAN         bIsDir)</span>   <span class="comment">// 是否为文件夹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE          hFile = <span class="literal">NULL</span>;</span><br><span class="line">NTSTATUS        Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">IO_STATUS_BLOCK StatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ULONG           ulShareAccess =</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;</span><br><span class="line">ULONG           ulCreateOpt =</span><br><span class="line">FILE_SYNCHRONOUS_IO_NONALERT;</span><br><span class="line"><span class="comment">// 1. 初始化OBJECT_ATTRIBUTES的内容</span></span><br><span class="line">OBJECT_ATTRIBUTES objAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ULONG             ulAttributes =</span><br><span class="line">OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;</span><br><span class="line">InitializeObjectAttributes(</span><br><span class="line">&amp;objAttrib,    <span class="comment">// 返回初始化完毕的结构体</span></span><br><span class="line">pstrFile,      <span class="comment">// 文件对象名称</span></span><br><span class="line">ulAttributes,  <span class="comment">// 对象属性</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>);   <span class="comment">// 一般为NULL</span></span><br><span class="line"><span class="comment">// 2. 创建文件对象</span></span><br><span class="line">ulCreateOpt |= bIsDir;</span><br><span class="line">FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE;</span><br><span class="line">Status = ZwCreateFile(</span><br><span class="line">&amp;hFile,                <span class="comment">// 返回文件句柄</span></span><br><span class="line">GENERIC_ALL,           <span class="comment">// 文件操作描述</span></span><br><span class="line">&amp;objAttrib,            <span class="comment">// OBJECT_ATTRIBUTES</span></span><br><span class="line">&amp;StatusBlock,          <span class="comment">// 接受函数的操作结果</span></span><br><span class="line"><span class="number">0</span>,                     <span class="comment">// 初始文件大小</span></span><br><span class="line">FILE_ATTRIBUTE_NORMAL, <span class="comment">// 新建文件的属性</span></span><br><span class="line">ulShareAccess,         <span class="comment">// 文件共享方式</span></span><br><span class="line">FILE_OPEN_IF,          <span class="comment">// 文件存在则打开不存在则创建</span></span><br><span class="line">ulCreateOpt,           <span class="comment">// 打开操作的附加标志位</span></span><br><span class="line"><span class="literal">NULL</span>,                  <span class="comment">// 扩展属性区</span></span><br><span class="line"><span class="number">0</span>);                   <span class="comment">// 扩展属性区长度</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line"><span class="keyword">return</span> (HANDLE)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> hFile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 随便打开一个文件，得到一个文件对象</span></span><br><span class="line">UNICODE_STRING ustrFilePath;</span><br><span class="line">RtlInitUnicodeString(&amp;ustrFilePath,</span><br><span class="line"><span class="string">L"\\??\\D:\\123.txt"</span>);</span><br><span class="line">HANDLE hFile = KernelCreateFile(&amp;ustrFilePath, FALSE);</span><br><span class="line">PVOID pObject;</span><br><span class="line">ObReferenceObjectByHandle(hFile, GENERIC_ALL, <span class="literal">NULL</span>, KernelMode, &amp;pObject, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 通过这个文件对象得到OBJECT_TYPE这个结构体</span></span><br><span class="line">OBJECT_TYPE * FileType = <span class="literal">NULL</span>;</span><br><span class="line">FileType = (OBJECT_TYPE *)g_OBGetObjectType(pObject);</span><br><span class="line"><span class="comment">//3 把这个函数地址保存起来</span></span><br><span class="line">g_OldFun = (PARSEPRODECEDURE)FileType-&gt;TypeInfo.ParseProcedure;</span><br><span class="line"><span class="comment">//4 把这个函数地址替换为自己的函数。</span></span><br><span class="line">FileType-&gt;TypeInfo.ParseProcedure = (ULONG)NewParseProcedure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OffHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PDRIVER_OBJECT  pDriver,</span></span></span><br><span class="line"><span class="function"><span class="params">PUNICODE_STRING strRegPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 避免编译器报未引用参数的警告</span></span><br><span class="line">UNREFERENCED_PARAMETER(strRegPath);</span><br><span class="line"><span class="comment">// 打印一行字符串，并注册驱动卸载函数，以便于驱动卸载</span></span><br><span class="line">DbgBreakPoint();<span class="comment">//_asm int 3</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">GetObjectTypeAddress();</span><br><span class="line">OnHook();</span><br><span class="line">&#125;</span><br><span class="line">except(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">"掠过一个异常\n"</span>));</span><br><span class="line">&#125;</span><br><span class="line">KdPrint((<span class="string">"My First Dirver!"</span>));</span><br><span class="line">pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT objDriver)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 避免编译器报未引用参数的警告</span></span><br><span class="line">UNREFERENCED_PARAMETER(objDriver);</span><br><span class="line"><span class="comment">// 什么也不做，只打印一行字符串</span></span><br><span class="line">KdPrint((<span class="string">"My Dirver is unloading..."</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：毛德操，《Windows内核情景分析》<br>[2]: 一大堆的别人的博客  </p>]]></content>
      
      <categories>
          
          <category> 笔记 - Hook笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object—Hook </tag>
            
            <tag> 内核学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>保护模式之页相关的笔记</title>
      <link href="/2018/06/25/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/25/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>如下指令：<br>MOV eax,dword ptr ds:[0x12345678]<br>其中,0x12345678 是有效地址<br>ds.Base + 0x12345678 是线性地址  </p><h3 id="物理地址在哪里？"><a href="#物理地址在哪里？" class="headerlink" title="物理地址在哪里？"></a>物理地址在哪里？</h3><p>CR3寄存器是所有寄存器里面，唯一一个存储物理地址的寄存器，其他都是线性地址。<br>每个进程都有一个CR3,(准确的说是都一个CR3的值，CR3本身是个寄存器，一个核，只有一套寄存器)，CR3指向一个物理页，一共4096字节（4KB）,如图：</p><h3 id="10-10-12分页"><a href="#10-10-12分页" class="headerlink" title="10-10-12分页"></a>10-10-12分页</h3><table><thead><tr><th>31到22</th><th>21到12</th><th>11到0</th></tr></thead><tbody><tr><td>10</td><td>10</td><td>12</td></tr><tr><td>目录</td><td>目录</td><td>当前这个物理页的哪个位置</td></tr></tbody></table><p>设置分页方式<br>boot里的noexecute 改成 execute   </p><h2 id="PDE与PTE"><a href="#PDE与PTE" class="headerlink" title="PDE与PTE"></a>PDE与PTE</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/11.png" alt="分页机制"></p><h2 id="分析为什么是10-10-12"><a href="#分析为什么是10-10-12" class="headerlink" title="分析为什么是10-10-12"></a>分析为什么是10-10-12</h2><p>因为每个单元4字节，后3位是属性，倒着来看，比如12的原因，2的12次方是4K，所以12才能寻找所有的物理页，第二个10，每个PTE成员4字节，整个表4kB，所以有2的10次方个单元，所以有10位，第一个10位也是相同原因。   </p><h2 id="PTE特征"><a href="#PTE特征" class="headerlink" title="PTE特征"></a>PTE特征</h2><ul><li>PTE既可以指向物理页，也可以没有物理页。   </li><li>多个PTE可以指向同一个物理页。   </li><li>一个PTE只能指向一个物理页。   </li></ul><h2 id="物理页的属性"><a href="#物理页的属性" class="headerlink" title="物理页的属性"></a>物理页的属性</h2><p>物理页的属性 = PDE属性 &amp; PTE属性   </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/12.png" alt="物理页属性"></p><h3 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h3><p>线性地址0 为什么不能访问呢？<br>没有指定物理页，指定物理页就一定能访问吗？<br>先看PDE与PTE的P位  P=1 才是有效的物理页   </p><h3 id="R-W-位"><a href="#R-W-位" class="headerlink" title="R/W 位"></a>R/W 位</h3><p>R/W = 0 只读<br>R/W = 1 可读可写</p><h3 id="U-S-位"><a href="#U-S-位" class="headerlink" title="U/S 位"></a>U/S 位</h3><p>U/S = 0 特权用户<br>U/S = 1 普通用户</p><h3 id="P-S位（PageSize）"><a href="#P-S位（PageSize）" class="headerlink" title="P/S位（PageSize）"></a>P/S位（PageSize）</h3><p>对PDE有意义，PS == PageSize的意思  当PS==1的时候 PDE直接指向物理页无PTE,低22位全是页内偏移。因为后面的偏移，线性地址只能拆成2段：大小为4MB，俗称“大页”</p><h3 id="A-位"><a href="#A-位" class="headerlink" title="A 位"></a>A 位</h3><p>是否被访问（读或者写）过访问过置1，即使只访问一个字节也会导致PDE PTE置1  </p><h3 id="D-位"><a href="#D-位" class="headerlink" title="D 位"></a>D 位</h3><p>脏位，是否被写过，0没有被写过，1被写过   </p><p>在上一节课课后题中我们提到过，如果系统要保证某个线性地址是有效的，那么必须为其填充正确的PDE与PTE，如果我们想填充PDE与PTE那么必须能够访问PDT与PTT，那么存在2个问题：<br>1、一定已经有“人”为我们访问PDT与PTT挂好了PDE与PTE,我们只有找到这个线性地址就可以了。<br>2、这个为我们挂好PDE与PTE的“人”是谁？</p><p>拆分C0300000<br>结论：C0300000存储的值就是PDT<br>如果我们要访问第N个PDE，那么有如下公式：<br>0xC0300000 + N*4   </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/13.png" alt="段页"></p><p>PDT总结：<br>1、通过0xC0300000找到的物理页就是页目录表</p><p>2、这个物理页即是页目录表本身也是页表</p><p>3、页目录表是一张特殊的页表，每一项PTE指向的不是普通的物理页，而是指向其他的页表.</p><p>4、如果我们要访问第N个PDE，那么有如下公式：<br>0xC0300000 + N*4 </p><p>PTT总结：<br>1、页表被映射到了从0xC0000000到0xC03FFFFF的4M地址空间（一个页表是4KB，一共1024）<br>2、在这1024个表中有一张特殊的表：页目录表<br>3、页目录被映射到了0xC0300000开始处的4K地址空间</p><p>有了0xC0300000和0xC0000000能做什么？</p><p>掌握了这两个地址，就掌握了一个进程所有的物理内存读写权限。</p><p>公式总结：<br>1、什么是PDI与PTI<br>10-10-12  <br>2、访问页目录表的公式：<br>0xC0300000 + PDI<em>4<br>3、访问页表的公式<br>0xC0000000 + PDI</em>4096 + PTI*4</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/20.png" alt="image"></p><h1 id="首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。"><a href="#首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。" class="headerlink" title="首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。"></a>首先要明白一点，PAE和非PAE指的是物理寻址扩不扩大，也就是PTE的位数扩不扩大，原来的内存大小是4G，因为首先PTE是寻物理地址的，记录了寻址时物理地址的起始地址。PTE的大小是4字节32位寻址范围是2的32次方，寻址范围就是4G，因为线性地址是32位，所以是10-10-12（10是因为4k大小能存2的10次方个，12是页内偏移，因为不管PAE还是不PAE页大小都是4K），PAE技术就是把PTE变为8个字节（64位），所以寻址理论上就能变成2的64次方（但是这个太大，一般用不了那么多）。所以是2-9-9-12。</h1><h1 id="2-9-9-12分页"><a href="#2-9-9-12分页" class="headerlink" title="2-9-9-12分页"></a>2-9-9-12分页</h1><p>10-10-12分页方式，在这种分页方式下物理地址最多可达4GB。但随着硬件发展，4GB的物理地址范围已经无法满足要求，Intel在1996年就已经意识到这个问题了，所以设计了新的分页方式.也就是我们本节课要讲的2-9-9-12分页,又称为PAE（物理地址扩展）分页.   </p><h2 id="为什么是10-10-12"><a href="#为什么是10-10-12" class="headerlink" title="为什么是10-10-12"></a>为什么是10-10-12</h2><ul><li>先确定了页的大小4K，所以后面的12位的功能就确定了，（一个页4K是4096个字节，所以想让每个页内偏移的字节都能寻址到，就需要4096个地址，即2的12次方个，即12位）   </li><li>当初的物理内存比较小，所以4个字节的PTE就够了，加上页的尺寸是4K，所以一个页能存储1024个PTE， 也就是2的10次方，第二个10也就确定了.   </li><li>剩下的10为PDI  10+10+12刚好32位    </li></ul><h2 id="为什么是2-9-9-12"><a href="#为什么是2-9-9-12" class="headerlink" title="为什么是2-9-9-12"></a>为什么是2-9-9-12</h2><ul><li>页的大小是确定的，4KB不能随便改，所以12确定了。   </li><li>如果想增大物理内存的访问范围，就需要增大PTE,增大多少了呢？考虑对齐的因素，增加到8个字节，所以4K/8=512,一个页PTE就是512个，如下图。</li><li>同理PDI也是2的9次方 32 - 9 - 9 - 12 还差2位 所以就再做一级，叫PDPI  </li></ul><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/14.png" alt="PAE技术"></p><h2 id="2-9-9-12分页结构-PAE-物理地址扩展"><a href="#2-9-9-12分页结构-PAE-物理地址扩展" class="headerlink" title="2-9-9-12分页结构(PAE,物理地址扩展)"></a>2-9-9-12分页结构(PAE,物理地址扩展)</h2><p>CR3此时指向PDPTE</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/15.png" alt="2-9-9-12分页"></p><h2 id="如何开启PAE模式"><a href="#如何开启PAE模式" class="headerlink" title="如何开启PAE模式"></a>如何开启PAE模式</h2><p>将C:\boot.ini文件中的execute改为noexecute 重启   </p><h2 id="Page-Directory-Point-Table-Entry"><a href="#Page-Directory-Point-Table-Entry" class="headerlink" title="Page-Directory-Point-Table Entry"></a>Page-Directory-Point-Table Entry</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/16.png" alt="Page-Directory-Point-Table Entry"></p><ul><li>PDPTE共有四项(第一个2)。</li><li>35-12 存储的是页目录表的基址，低12位补0，共36位，即页目录基址。    </li></ul><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/17.png" alt="PAE的PDE结构"></p><p>特别说明：</p><ul><li>当PS=1时（第7位）是大页，35-21位是大页的物理地址，这样36位的物理地址的低21位为0，这就意味着页的大小为2MB，且都是2MB对齐。   </li><li>当PS=0时，35-12位是页表基址,低12位补0，共36位。   </li></ul><p>特别说明</p><ul><li>PTE中35-12是物理页基址，24位，低12位补0   </li><li>物理页基址+12位的页内偏移指向具体数据   </li></ul><h2 id="XD标志位（AMD中称为NX-即No-Excetion-）"><a href="#XD标志位（AMD中称为NX-即No-Excetion-）" class="headerlink" title="XD标志位（AMD中称为NX,即No Excetion ）"></a>XD标志位（AMD中称为NX,即No Excetion ）</h2><p>PDE/PTE结构</p><table><thead><tr><th>X</th><th>保留</th><th>35-12  物理地址</th><th>低12位（属性）</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>段的属性有可读、可写和可执行<br>页的属性有可读、可写<br>当RET执行返回的时候，如果我修改堆栈里面的数据指向一个我提前准备好的数据（把数据当作代码来执行，漏洞都是依赖这点，比如SQL注入也是）<br>所以，Intel就做了硬件保护，做了一个不可执行位，XD=1时。那么你的软件溢出了也没有关系，即使你的EIP蹦到了危险的“数据区”，也是不可以执行的！<br>在PAE分页模式下，PDE与PTE的最高位为XD/NX位.   </p><h1 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h1><h2 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h2><ol><li>通过一个线性地址访问一个物理页。比如：一个DWORD，其实未必真正读的是4个字节，我们先读的PDE再读PTE 最后才读的4个字节的页。   </li><li>在2-9-9-12会读24个字节 如果跨页可能更多。   </li></ol><p>为了提高效率，只能做记录。<br>CPU内部做了一个表，来记录这些东西，这个表格是CPU内部的，和寄存器一样快，这个表格：TLB（Translation Lookaside Buffer）。</p><h2 id="TLB结构"><a href="#TLB结构" class="headerlink" title="TLB结构"></a>TLB结构</h2><table><thead><tr><th>LA（线性地址）</th><th>PA（物理地址）</th><th>ATTR（属性）</th><th>LRU（统计）</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>说明：</p><ol><li>ATTR（属性）：属性是PDPE，PDE，PTE三个属性AND起来的. 如果是10-10-12，就是PDE and PTE   </li><li>不同的CPU 这个表的大小不一样.</li><li>只要Cr3变了，TLB立马刷新，一核一套TLB.</li></ol><p>操作系统的高2G映射基本不变，如果Cr3改了，TLB刷新 重建高2G以上很浪费。所以PDE和PTE中有个G标志位（PDE是大页时有效），如果G位为1刷新TLB时将不会刷新PDE/PTE的G位为1的页，当TLB满了，根据统计信息将不常用的地址废弃，最近最常用的保留.   </p><h2 id="TLB种类"><a href="#TLB种类" class="headerlink" title="TLB种类"></a>TLB种类</h2><p>TLB在X86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在X86体系的CPU里边，一般都设有如下4组TLB:<br>第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）；<br>第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）；<br>第三组：缓存大尺寸页表（2M/4M字节页面）的指令页表缓存（Instruction-TLB）；<br>第四组：缓存大尺寸页表（2M/4M字节页面）的数据页表缓存（Data-TLB）   </p><h1 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h1><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><ol><li>中断通常是由CPU外部的输入输出设备(硬件)所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫中断请求(Interrupt Request).   </li><li>中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程(中断处理程序在哪有IDT表决定)    </li><li>80x86有两条中断请求线：<br> 非屏蔽中断线，称为NMI（NonMaskable Interrupt）<br> 可屏蔽中断线，称为INTR（Interrupt Require</li></ol><h2 id="非可屏蔽中断如何处理"><a href="#非可屏蔽中断如何处理" class="headerlink" title="非可屏蔽中断如何处理"></a>非可屏蔽中断如何处理</h2><p>（固定IDT第二个门）</p><table><thead><tr><th>(IDT表)中断号</th><th>NMI</th><th>说明</th></tr></thead><tbody><tr><td>0x2</td><td>不可屏蔽中断</td><td>80x86中固定为0x2</td></tr></tbody></table><p>特别说明：<br>当非可屏蔽中断产生时，CPU在执行完当前指令后会里面进入中断处理程序<br>非可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须处理<br>非可屏蔽中断处理程序位于IDT表中的2号位置    </p><h2 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h2><p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器.它负责分配中断资源和管理各个中断源发出的中断请求.为了便于标识各个中断请求，中断管理器通常用IRQ(Interrupt Request)后面加上数字来表示不同的中断.</p><p>比如：在Windows中时钟中断的IRQ编号为0，也就是：IRQ0    </p><p>中断的实质是改变程序执行流程   </p><h2 id="可屏蔽中断如何处理？"><a href="#可屏蔽中断如何处理？" class="headerlink" title="可屏蔽中断如何处理？"></a>可屏蔽中断如何处理？</h2><table><thead><tr><th>（IDT表）中断号</th><th>IRQ</th><th>说明</th></tr></thead><tbody><tr><td>0x30</td><td>IRQ0</td><td>时钟中断</td></tr><tr><td>0x31-0x3F</td><td>IRQ1-IRQ15</td><td>其他硬件设备的中断</td></tr></tbody></table><p>特别说明：</p><ol><li>如果自己的程序执行时不希望CPU去处理这些中断，可以<br>用CLI指令清空EFLAG寄存器中的IF位<br>用STI指令设置EFLAG寄存器中的IF位   </li><li>硬件中断与IDT表中的对应关系并非固定不变的，<br>参见：APIC（高级可编程中断控制器）   </li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常通常是CPU在执行指令时检测到的某些错误，比如除0、访问无效页面等。</p><h3 id="中断与异常的区别："><a href="#中断与异常的区别：" class="headerlink" title="中断与异常的区别："></a>中断与异常的区别：</h3><ol><li>中断来自于外部设备，是中断源（比如键盘）发起的，CPU是被动的.</li><li>异常来自于CPU本身，是CPU主动产生的.</li><li>INT N虽然被称为“软件中断”，但其本质是异常。EFLAG的IF位对INT N无效。   </li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>无论是由硬件设备触发的中断请求还是由CPU产生的异常，处理程序都在IDT表。   </p><table><thead><tr><th>错误类型</th><th>（IDT表）中断号</th></tr></thead><tbody><tr><td>页错误</td><td>0xE</td></tr><tr><td>段错误</td><td>0xD</td></tr><tr><td>除0错误</td><td>0x0</td></tr><tr><td>双重</td><td>0x8</td></tr></tbody></table><h2 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h2><p>缺页异常的产生：<br>1、当PDE/PTE的P=0时<br>2、当PDE/PTE的属性为只读但程序试图写入的时<br>一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统来接管。   </p><h1 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h1><p>控制寄存器用于控制和确定CPU的操作模式。<br>Cr0 Cr1 Cr2 Cr3 Cr4<br>Cr1 保留<br>Cr3 页目录表基址   </p><h2 id="Cr0寄存器"><a href="#Cr0寄存器" class="headerlink" title="Cr0寄存器"></a>Cr0寄存器</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/18.png" alt="CR0寄存器"></p><p>说明：<br>PE：CR0的位0是启用保护（Protection Enable）标志。<br>PE=1保护模式，PE=0实地址模式，这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。<br>PG：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或者同时开启PE标志。<br>PG=0且PE=0，处理器工作在实地址模式下<br>PG=0且PE=1，处理器工作在没有开启分页机制的保护模式下<br>PG=1且PE=0，在PE没有开启的情况下，无法开启PG<br>PG=1且PE=1，处理器工作在开启了分页机制的保护模式下  </p><p>WP：对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页<br>面执行写操作；<br>当CPL&lt;3的时候：<br>如果 WP=0 可以读写任意用户级物理页，只要线性地址有效.<br>如果 WP=1 可以读取任意用户级物理页，但对于只读的物理页，则不能写.   </p><h2 id="Cr2寄存器"><a href="#Cr2寄存器" class="headerlink" title="Cr2寄存器"></a>Cr2寄存器</h2><p>当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。   </p><h2 id="Cr4寄存器"><a href="#Cr4寄存器" class="headerlink" title="Cr4寄存器"></a>Cr4寄存器</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/19.png" alt="Cr4寄存器"></p><h1 id="PWT-PCD"><a href="#PWT-PCD" class="headerlink" title="PWT/PCD"></a>PWT/PCD</h1><h2 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h2><p>1) CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。<br>2) CPU缓存可以做的很大，有几K、几十K、几百K甚至上M的也有。<br>CPU缓存与TLB的区别：<br>TLB：<br>    线性地址  <----->  物理地址<br>CPU缓存：<br>    物理地址  <----->  内容   </-----></-----></p><h2 id="关于PWT-PCD属性"><a href="#关于PWT-PCD属性" class="headerlink" title="关于PWT/PCD属性"></a>关于PWT/PCD属性</h2><p>PWT：Page Write Through</p><pre><code>PWT =  1 时 写Cache的时候也要将数据写入内存中。</code></pre><p>PCD：Page Cache Disable</p><pre><code>PCD = 1时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。</code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 保护模式页 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>保护模式之段相关的笔记</title>
      <link href="/2018/06/23/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%AE%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/23/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%AE%B5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="段寄存器简介"><a href="#段寄存器简介" class="headerlink" title="段寄存器简介"></a>段寄存器简介</h1><table><thead><tr><th>段寄存器</th><th>Selector</th><th>Attribute</th><th>Base</th><th>Limit</th></tr></thead><tbody><tr><td>ES</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>CS</td><td>++001B++</td><td>可读可执行</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>SS</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>DS</td><td>++0023++</td><td>可读可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>FS</td><td>++003B++</td><td>可读可写</td><td>++ 0x7FFDE000++</td><td>0xFFF</td></tr><tr><td>GS</td><td>windows没有使用</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h3 id="注释：加了下划线可能会变"><a href="#注释：加了下划线可能会变" class="headerlink" title="注释：加了下划线可能会变!"></a>注释：加了下划线可能会变!</h3><h2 id="探测Attribute存在"><a href="#探测Attribute存在" class="headerlink" title="探测Attribute存在"></a>探测Attribute存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> int <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">char</span>* argu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov ax,ss;<span class="comment">//cs不行，cs是不可写的</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov dword ptr ds:[var],eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="探测Base存在"><a href="#探测Base存在" class="headerlink" title="探测Base存在"></a>探测Base存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov ax,fs</span><br><span class="line">mov gs,ax</span><br><span class="line">mov eax,gs:[<span class="number">0x1000</span>]<span class="comment">//读取不成功，因为fs大小是FFF//不要用DS 否则编译不过，这个不是真正0地址，而是关于基址的偏移</span></span><br><span class="line">mov dword ptr ds:[var],eax</span><br><span class="line"></span><br><span class="line"><span class="comment">//mov edx,dword ptr ds:[0x7FFDF000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="探测Limit存在"><a href="#探测Limit存在" class="headerlink" title="探测Limit存在"></a>探测Limit存在</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov ax,fs</span><br><span class="line">mov gs,ax</span><br><span class="line">mov eax,gs:[<span class="number">0</span>]<span class="comment">//不要用DS 否则编译不过去</span></span><br><span class="line">mov dword ptr ds:[var],eax</span><br><span class="line"></span><br><span class="line"><span class="comment">//mov edx,dword ptr ds:[0x7FFDF000]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GDT-全局描述符表-LDT-局部描述符表"><a href="#GDT-全局描述符表-LDT-局部描述符表" class="headerlink" title="GDT(全局描述符表)LDT(局部描述符表)"></a>GDT(全局描述符表)LDT(局部描述符表)</h1><p>当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定<br>查找GDT还是LDT,查找表的什么位置，查出多少数据.GDT是一张表，GDTR是个寄存器，存了GDT起始位置和有多少个元素。</p><h1 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h1><h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/1.png" alt="段描述符"></p><h2 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h2><p>段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符.<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/2.png" alt="段选择子"></p><p>RPL：请求特权级别</p><p>TI：<br>TI=0  查GDT表<br>TI=1  查LDT表</p><p>Index：<br>处理器将索引值乘以8<br>在加上GDT或者LDT的<br>基地址，就是要加载的<br>段描述符</p><h2 id="加载段描述符至段寄存器"><a href="#加载段描述符至段寄存器" class="headerlink" title="加载段描述符至段寄存器"></a>加载段描述符至段寄存器</h2><p>除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器.<br>CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，后面会讲.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">6</span>];</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">les ecx,fword ptr ds:[buffer] <span class="comment">//高2个字节给es，低四个字节给ecx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：RPL&lt;=DPL(在数值上)    </p><h1 id="段描述符属性"><a href="#段描述符属性" class="headerlink" title="段描述符属性"></a>段描述符属性</h1><h2 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h2><p>P = 1 段描述符有效<br>P = 0 段描述符无效<br>3、段描述符与段寄存器的对应关系    </p><p>WORD  Selector;//16位<br>WORD  Atrribute;//16位<br>DWORD Base;//32位<br>DWORD Limit;//32位      FFFFFFFF</p><h2 id="S位"><a href="#S位" class="headerlink" title="S位"></a>S位</h2><p>S = 1 代码段或者数据段描述符<br>S = 0 系统段描述符</p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/3.png" alt="Tpye域"></p><p>因为P，DPL，S位，Type要么是1001（访问本段权限0），要么是1111（访问本段权限3），所以GDT表里第五5要是9或者F才是代码段或者数据段。又因为Type与第一位为1是代码段，所以第六位要是大于8就是代码段。<br>E 向上就是LImit里有效，扩展方向向下是Limit取反才是有效的。  </p><h2 id="系统段描述符"><a href="#系统段描述符" class="headerlink" title="系统段描述符"></a>系统段描述符</h2><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/4.png" alt="系统段Type域"></p><h2 id="DB位"><a href="#DB位" class="headerlink" title="DB位"></a>DB位</h2><p>情况一：对CS段的影响<br>D = 1 采用32位寻址方式<br>D = 0 采用16位寻址方式<br>前缀67 改变寻址方式</p><p>情况二：对SS段的影响<br>D = 1 隐式堆栈访问指令（如：PUSH POP CALL）使用32位堆栈指针寄存器ESP<br>D = 0 隐式堆栈访问指令（如：PUSH POP CALL） 使用16位堆栈指针寄存器SP   </p><p>情况三：向下拓展的数据段   </p><p>D = 1 段上线为4GB<br>D = 0 段上线为64KB<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/5.png" alt="向上与向下扩展"></p><h1 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h1><table><thead><tr><th></th><th></th><th>位置</th><th>用途</th></tr></thead><tbody><tr><td> CPL</td><td>存放在CS和SS段选择子的最后两位更其他无关</td><td>当前程序特权级 ，CPU处于哪一环</td><td></td></tr><tr><td> DPL</td><td>存放在段描述符中</td><td>要访问该段需要什么权限才能访问</td><td></td></tr><tr><td>RPL</td><td>存放在段选择子的最后两位</td><td></td><td></td></tr></tbody></table><p>如何查看程序处于几环?</p><p>CPL(Current Privilege Level) ：当前特权级<br>CS和SS中存储的段选择子后2位，要一致，另外跟这两个有关，跟其他的东西无关<br>DPL(Descriptor Privilege Level)  描述符特权级别</p><p>DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么.<br>通俗的理解：<br>如果你想访问我，那么你应该具备什么特权.<br>举例说明：<br>mov DS,AX  如果AX指向的段DPL = 0  但当前程序的CPL = 3 这行指令是不会成功的！<br>RPL(Request Privilege Level)  请求特权级别<br>RPL是针对段选择子而言的，每个段的选择子都有自己的RPL</p><p>举例说明：</p><p>Mov ax,0008    与    Mov ax,000B//段选择子<br>Mov ds,ax        Mov ds,ax//将段描述<br>指向的是同一个段描述符,但RPL是不一样的.   </p><h2 id="数据段的权限检查"><a href="#数据段的权限检查" class="headerlink" title="数据段的权限检查"></a>数据段的权限检查</h2><p>参考如下代码：<br>比如当前程序处于0环，也就是说CPL=0<br>Mov ax,000B    //1011   RPL = 3<br>Mov ds,ax    //ax指向的段描述符的DPL = 0<br>数据段的权限检查：<br>CPL &lt;= DPL  并且 RPL &lt;= DPL (数值上的比较)<br>注意：<br>代码段和系统段描述符中的检查方式并不一样,具体参加后面课程.</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>CPL  CPU当前的权限级别<br>DPL  如果你想访问我，你应该具备什么样的权限<br>RPL  用什么权限去访问一个段  </p><h4 id="为啥要有RPL"><a href="#为啥要有RPL" class="headerlink" title="为啥要有RPL?"></a>为啥要有RPL?</h4><p>我们本可以用“读写”的权限去打开一个文件，但为了避免出错，有些时候我们使用“只读”的权限去打开。  </p><h1 id="跨段跳转"><a href="#跨段跳转" class="headerlink" title="跨段跳转"></a>跨段跳转</h1><h2 id="代码间的跳转-段间跳转-非调用门之类的"><a href="#代码间的跳转-段间跳转-非调用门之类的" class="headerlink" title="代码间的跳转(段间跳转  非调用门之类的)"></a>代码间的跳转(段间跳转  非调用门之类的)</h2><p>段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段<br>同时修改CS与EIP的指令<br>JMP FAR / CALL FAR / RETF / INT /IRETED<br><strong>注意：</strong><br>只改变EIP的指令<br>JMP / CALL / JCC / RET    </p><p>JMP 0x20:0x004183D7 CPU如何执行这行代码?</p><p>(1) 段选择子拆分</p><pre><code>0x20 对应二进制形式 0000 0000 0010 0000RPL = 00   TI = 0Index = 4</code></pre><p>(2) 查表得到段描述符</p><pre><code>TI = 0 所以查GDT表Index = 4 找到对应的段描述符四种情况可以跳转：代码段、调用门、TSS任务段、任务门</code></pre><p>(3) 权限检查</p><pre><code>如果是非一致代码段，要求:CPL == DPL 并且 RPL &lt;= DPL如果是一致代码段，要求:CPL &gt;= DPL</code></pre><p>(4) 加载段描述符</p><pre><code>通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中.</code></pre><p>(5) 代码执行</p><pre><code>CPU将 CS.Base + Offset 的值写入EIP 然后执行CS:EIP处的代码，段间跳转结束.</code></pre><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><ol><li><p>对于一致代码段:也就是共享的段</p><ol><li>特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据</li><li>特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态</li></ol></li><li>对于普通代码段：也就是非一致代码段<ol><li>只允许同级访问</li><li>绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态.</li></ol></li></ol><p>直接对代码段进行JMP 或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变.如果要提升CPL的权限，只能通过调用门.</p><h1 id="长调用与短调用"><a href="#长调用与短调用" class="headerlink" title="长调用与短调用"></a>长调用与短调用</h1><p>短调用<br>指令格式：CALL  立即数/寄存器/内存  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/6.png" alt="三种调用图"></p><h1 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h1><p>调用门执行流程</p><p>指令格式：CALL  CS:EIP(EIP是废弃的)<br>执行步骤：    </p><ol><li>根据CS的值 查GDT表，找到对应的段描述符，这个描述符是一个调用门.  </li><li>在调用门描述符中存储另一个代码段段的选择子.  </li><li>这个调用门的选择子指向的段  段.Base +这个调用门的 偏移地址，就是真正要执行的地址.  </li></ol><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/7.png" alt="门描述符"></p><p>构造一个调用门（无参，提权，不提权8的位置是1B）</p><p>0040EC00 000810D0放入gdt里没用到的位置。</p><p>构造一个带参数的调用门   </p><p>调用门描述符：0040EC03 00081030</p><blockquote><p>eq 8003f048 0040EC03`00081030</p></blockquote><p>调用门总结：</p><p>1) 当通过门，权限不变的时候，只会PUSH两个值：CS  返回地址<br>新的CS的值由调用门决定</p><p>2) 当通过门，权限改变的时候，会PUSH四个值：SS ESP CS  返回地址   新的CS的值由调用门决定  新的SS和ESP由TSS提供</p><p>3) 通过门调用时，要执行哪行代码有调用门决定，但使用RETF返回时，由堆栈中压人的值决定，这就是说，进门时只能按指定路线走，出门时可以翻墙(只要改变堆栈里面的值就可以想去哪去哪)<br>4) 可不可以再建个门出去呢?也就是用Call  当然可以了 前门进 后门出    </p><h1 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h1><p>Windows没有使用调用门，但是使用了中断门：</p><pre><code>&lt;1&gt; 系统调用&lt;2&gt; 调试</code></pre><p>IDT</p><pre><code>IDT即中断描述符表,同GDT一样，IDT也是由一系列描述符组成的，每个描述符占8个字节。但要注意的是，IDT表中的第一个元素不是NULL。在windbg中查看IDT表的基址和长度:</code></pre><p>老的CPU用的中断门，新的用的快速调用</p><p>IDT表都是系统段描述符，都不是空（调用门就有可能是代码数据段，和有空了）</p><p>中断门Type是1110，陷阱门是1111</p><h2 id="陷阱门与中断门的区别"><a href="#陷阱门与中断门的区别" class="headerlink" title="陷阱门与中断门的区别"></a>陷阱门与中断门的区别</h2><p>中断门执行时，将IF位清零,但陷阱门不会。</p><p>在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。</p><pre><code>切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)这2个值从哪里来的呢？答案：TSS (Task-state segment )，任务状态段.</code></pre><h2 id="TSS的结构"><a href="#TSS的结构" class="headerlink" title="TSS的结构"></a>TSS的结构</h2><p>TSS是一块内存，不是寄存器不在CPU中，内存结构如下图，大小104字节  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/8.png" alt="TSS的结构"></p><p>TSS的作用</p><pre><code>Intel的设计思想操作系统的设计思想本质：    不要把TSS与“任务切换”联系到一起    TSS的意义就在于可以同时换掉”一堆”寄存器</code></pre><p>CPU如何找到TSS呢?  TR段寄存器  </p><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/9.png" alt="TR寄存器"></p><p>CPU找TSS直接在TR寄存器，TR的Base指向TSS，Limit是Tss有多大，TSS是操作系统启动时从GDT加载的。TSS是系统段的一种。所以S为是0，Type是1001，说明没有加载到TR寄存器中，1011时是已经加载到TR寄存器。  </p><h2 id="TR寄存器读写"><a href="#TR寄存器读写" class="headerlink" title="TR寄存器读写"></a>TR寄存器读写</h2><ol><li>将TSS段描述符加载到TR寄存器  <pre><code>指令：LTR  说明：用LTR指令去装载的话 仅仅是改变TR寄存器的值(96位) 并没有真正改变TSS  LTR指令只能在系统层使用加载后TSS段描述符会状态位会发生改变就是上面9变B</code></pre></li><li><p>读TR寄存器  </p><pre><code>1. 指令：STR  说明：如果用STR去读的话，只读了TR的16位 也就是选择子  </code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p> TSS是一块内存，大小104字节.通过TSS可以同时替换“一堆”寄存器，包括通用寄存器和段寄存器等.</p><p> CPU通过TR段寄存器来找到TSS.如果我们想用自己的TSS段来替换原来的寄存器，就要修改TR寄存器，TR寄存器的值又是来自TSS段描述符，那么我们接下来先构造一个段描述符。</p></li></ol><p>修改TR寄存器</p><pre><code>1) 在Ring0 我们可以通过LTR指令去修改TR寄存器2) 在Ring3 我们可以通过CALL FAR 或者 JMP FAR指令来修改</code></pre><p>用JMP去访问一个代码段的时候，改变的是CS和EIP ：</p><pre><code>JMP 0x48:0x123456  如果0x48是代码段  执行后：CS--&gt;0x48  EIP--&gt;0x123456</code></pre><p>用JMP去访问一个任务段的时候：</p><pre><code>如果0x48是TSS段描述符，先修改TR寄存器，在用TR.Base指向的TSS中的值修改当前的寄存器</code></pre><h1 id="任务门描述符"><a href="#任务门描述符" class="headerlink" title="任务门描述符"></a>任务门描述符</h1><p>Type为0101即5.<br><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/baohumoshi/10.png" alt="任务门"> </p><p>这是TSS段的描述符（在GDT表），任务门本身在IDT表</p><p>任务门执行过程：</p><p>INT N</p><p>查IDT表，找到中断门描述符</p><p>通过中断门描述符，查GDT表，找到任务段描述符</p><p>使用TSS段中的值修改寄存器</p><p>IRETD返回</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：滴水视频</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式段 </tag>
            
            <tag> 保护模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>段使用时相关的检查与调用门实验</title>
      <link href="/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/"/>
      <url>/2018/06/22/%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E9%97%A8%E5%AE%9E%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="段类型检查"><a href="#段类型检查" class="headerlink" title="段类型检查"></a>段类型检查</h1><p>加载段选择符进入段寄存器时候</p><ul><li>CS只能存放可执行的选择符</li><li>不可读可执行不能被加载到数据段寄存器</li><li>只有可写的数据段才能加载到SS</li></ul><h1 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h1><p>当给段寄存器赋值，实际是从GDT中获取相应的段描述符加载到段寄存器的不可见部分。这个时候有个权限检查，有三个概念：</p><ul><li>CPL：当前代码执行权限</li><li>DPL：存在段描述符中，描述访问本段内存需要的权限</li><li>RPL：存在于段寄存器加载时的段选择子中，描述了使用什么样的权限对目标进行访问</li></ul><p>从数值上MAX（CPL，RPL）&lt;DPL.  </p><p>段内跳转不会产生权限检查（JMP，CALL，RET），段间会。 </p><p>当S为0时：</p><ul><li>调用门：Type=12。</li><li>中断门：Type=14。</li><li>陷阱门：Type=15。</li><li>任务门：Type=5。</li></ul><h1 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/duanshiyongjiancha/1.png" alt="调用门图片"><br>调用门描述符中存储了一个代码段的段选择子。<br>指令格式：CALL CS：EIP（EIP废弃的）</p><ul><li>根据CS的值查GDT表，找到对应段描述符，之歌描述符是一个调用门。</li><li>在调用门描述符中存储着另一个代码段的段选择子。</li><li>选择子指向的段，段Base+偏移地址，就是真正要执行的地址。<br>通过调用门可以原图，不过Windows并没有用调用门。 </li></ul><p>段寄存器一共有 96 位，其中16可见部分来源于段选择子的索引部分。剩下80位来源于 GDT表。++<strong>那GDT表64位是怎么表示80位的段描述符呢？</strong>++ 是有一部分是G位为零代表粒度是1字节，在段限长前面补12位000，如果G为1在段限长前面补FFF，FFF刚好4KB。（段限长就是FFFFF）,所以当G=0，即粒度是1B时候，范围就是<br>2^00000000^到2^000FFFFF^即1B到4MB,当G=1，即粒度是1B时候，范围就是2^FFF00000^到2^FFFFFFFF^，即4KB到4GB。</p><h1 id="中断门和陷阱门"><a href="#中断门和陷阱门" class="headerlink" title="中断门和陷阱门"></a>中断门和陷阱门</h1><p>除了GDT外，还有一个地方也存着门描述符，被称为IDT（中断描述符表）。<br>IDT中存着3种门描述符： </p><ul><li>中断门描述符 </li><li>陷阱门描述符</li><li>任务门描述符 </li></ul><p>当S为0，type为1110是个中断门<br>中断门描述符存储着一个断码段选择子。<br>当S为0，type为1111是陷阱门 </p><ul><li>陷阱门用于存放异常处理函数</li><li>中断门用于存放中断处理函数地址</li><li>中断门执行时候IF位会清零，屏蔽可屏蔽中断，陷阱门不会。 </li></ul><h1 id="调用门提权实验"><a href="#调用门提权实验" class="headerlink" title="调用门提权实验"></a>调用门提权实验</h1><p>先确定一个事情，怎么提权？是要构造一个调用门描述符，然后CALL这个段的一个地址所以这个段的DPL得是3环的，所以，在构造的调用门描述符里，DPL位是3即11b，即3环就能访问本段的程序。然后这个调用门里的段选择子（就是13位可见的那部分个）是要执行的段，所以他的段选择子的RPL要是高权限，所以他的RPL应该是00，Ti也0，查GDT第二个就行所以索引是1，所以合起来是1000b，所以段选择子是8，所以要构造的调用门描述符里8，的作用是让其RPL是00为0，环以0环权限去访问，Ti为是0找GDT表，其他位置弄成如下<br>XXXXEC000008XXXX<br>下面的代码相关信息如下</p><ul><li>前后XXXX为偏移，比如你要执行的代码的偏移，即下文函数的入口，构造下面代码</li><li>0x80b95500为任意一个内核空间（高地址空间），为了验证能不能提权，得到内核的信息。</li><li>retf为不仅像ret一样pop ip，还pop cs</li><li>0x00,0x00,0x00,0x00,0x63,0x00 为CS：IP，因为内存以小端寸断存储。所以是这样，IP可以任意</li><li>fword为远跳，6字节的，用于段间跳转。</li><li>CS为0x63，即下面代码要CALL的段选择是0x63，是因为我们找了一个GDT里的空位为第12个位置，所以是1100,然后找GDT，权限是3环，所以段选择子是1100011b，所以这个是63</li><li>注意vs要关闭随机基址，虚拟机要单核，比较好做这个实验</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_num = <span class="number">0</span>;</span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里如果用了 int 3 那么回到3环的时候，会造成程序崩溃，因为回去的时候，FS会被置0；</span></span><br><span class="line">_asm &#123;</span><br><span class="line">push eax;</span><br><span class="line">mov eax, DWORD ptr ds : [<span class="number">0x80b95500</span>];</span><br><span class="line">mov g_num, eax;</span><br><span class="line">pop eax;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">6</span>] = &#123; <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x63</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">_asm &#123;</span><br><span class="line">call fword ptr ds : [buf];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, g_num);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节<br>[2]:<code>https://blog.csdn.net/q1007729991/article/details/52538080</code><br>[3]：李忠，《x86汇编语言:从实模式到保护模式》，电子工业出版社</p>]]></content>
      
      <categories>
          
          <category> 笔记 - 内核笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 调用门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>段描述符浅谈</title>
      <link href="/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/"/>
      <url>/2018/06/21/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B5%85%E8%B0%88/</url>
      <content type="html"><![CDATA[<h1 id="描述符表中存放的是段描述符，如下图所示"><a href="#描述符表中存放的是段描述符，如下图所示" class="headerlink" title="描述符表中存放的是段描述符，如下图所示"></a>描述符表中存放的是段描述符，如下图所示</h1><p><img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/2.PNG" alt="图1-1 段描述符通用格式"></p><h1 id="段描述符基本属性"><a href="#段描述符基本属性" class="headerlink" title="段描述符基本属性"></a>段描述符基本属性</h1><p>段描述符是GDT和LDT中的一个数据结构项，用于向处理器提供有关一个段的位置大小访问控制的信息状态信息，每个段描述符的长度是8个字节，含有3个主要字段</p><ul><li>段基地址</li><li>段限长</li><li>段属性 </li></ul><h2 id="基地址字段Base"><a href="#基地址字段Base" class="headerlink" title="基地址字段Base"></a>基地址字段Base</h2><p>描述了一个短的起始位置，由三个部分组成一共32位，段基地址可以是0~4GB范围内的任意地址(这同实模式不同，实模式下段基地址要求16字节对齐)，但是为了让程序具有最佳性能，还是建议16字节对齐。</p><h2 id="粒度G位"><a href="#粒度G位" class="headerlink" title="粒度G位"></a>粒度G位</h2><p>为0，Limit单位是字节。为1，Limit单位是4KB。</p><h2 id="B-D位-数据段时是B，代码段时是D"><a href="#B-D位-数据段时是B，代码段时是D" class="headerlink" title="B/D位 (数据段时是B，代码段时是D)"></a>B/D位 (数据段时是B，代码段时是D)</h2><ul><li>为B时<ul><li>为0，内存寻址是16位，堆栈使用SP，段的最大大小是64KB。</li><li>为1，内存寻址是32位，堆栈使用ESP，段的最大大小是4GB。</li></ul></li><li>为D时<ul><li>为0，默认值是16位的地址和16位或者8为操作数。</li><li>为1，默认值是32位的地址和32位或者8为操作数。<h2 id="L位（21）"><a href="#L位（21）" class="headerlink" title="L位（21）"></a>L位（21）</h2>是64位代码段标志，保留给64位处理器使用，目前在分析32位时置零即可<h2 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h2>是软件可以使用的位，通常由操作系统使用，处理器不使用它<h2 id="段限长Limit"><a href="#段限长Limit" class="headerlink" title="段限长Limit"></a>段限长Limit</h2>处理器会把段描述符中两个段限长字段组合成一个20位的值，并根据颗粒度标志G来知道段限长Limit值的实际含义。<h2 id="描述符有效位P位"><a href="#描述符有效位P位" class="headerlink" title="描述符有效位P位"></a>描述符有效位P位</h2>为1则段描述符有效，为0则段描述符无效<h2 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h2>存在于段描述符中，描述了访问本地内存需要的权限。<h2 id="S与TYPE"><a href="#S与TYPE" class="headerlink" title="S与TYPE"></a>S与TYPE</h2>应用程序有数据段和代码段，cpu还有系统段和门描述符，用来管理任务，异常，中断。并非所有的描述符都定义一个段，门描述符中存放着一个指向过程入口点的指针，S和Type字段表明了描述符的类型信息。</li></ul></li></ul><table><thead><tr><th>S位</th><th>Type域</th></tr></thead><tbody><tr><td>为1代码是一个代码段或者数据段，0是一个系统段</td><td>一共4位，在S位不同时，含义不同</td><td></td></tr></tbody></table><p>当S为1时，Tpye的四位，11位为0时是数据段，1时是代码段。</p><ul><li><p>当时数据段时，后面10,9,8位为EWA</p><ul><li>10号位为E扩展位，0向上扩展，1向下扩展，向上扩展就是正常的扩展，向上扩展一段空间，扩展的空间可用，向下扩展就是向上扩展一下，除了这段，其他的都在段内，如图<img src="https://raw.githubusercontent.com/yangruiqiyr/MarkdownPhotos/master/note/DuanMiaoShuFu/1.png" alt="图1-2 向上扩展和向下扩展"></li><li>9号位为W，为是否可写（代码段可定都是可读的所以不需要这样的属性标志）</li><li>8号位为A，为是否已被访问</li></ul></li><li><p>当时代码段时，后面10,9,8位为CRA  </p><ul><li>10号位为一致性段位，0是非一致性段，1是一致性段  <ul><li><strong>非一致代码段：</strong>  受到隔离的代码，只能在同一级别间互相访问。</li><li><strong>一致性代码段：</strong>  不受隔离，允许被同等级货低等级代码调用。</li></ul></li><li>9号位为R，为是否可读（代码段都是可执行的）</li><li>8号位为A，为是否已被访问</li></ul></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1]：赵炯，《Linux内核完全剖析》，机械工业出版社. 4.3.4节</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown用法之表格单元格合并</title>
      <link href="/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/"/>
      <url>/2018/06/21/MarkDown%E7%94%A8%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p>Markdown语法本身不包含复杂表格的插入，但是可以使用html语法来实现。</p><p>水平单元格的合并：基于colspan属性，即使一个单元格占多列的空间<br>纵向单元格的合并：基于rowspan属性，即使一个单元格占多行的空间<br>要想MarkDown中插入复杂表格时，可以先在word或excel中把表格写好，然后在如下网站进行转化为标记对形式：</p><p><a href="http://pressbin.com/tools/excel_to_html_table/index.html" target="_blank" rel="noopener">http://pressbin.com/tools/excel_to_html_table/index.html</a></p><p>然后删除空标记对，并设置colspan和rowspan属性即可。<br>比如  <code>&lt;td colspan=&quot;8&quot;&gt;基地址Base31到24&lt;/td&gt;</code>就是合并8列单元格</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> 文本编辑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序二进制特征</title>
      <link href="/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/"/>
      <url>/2018/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E5%BE%81/</url>
      <content type="html"><![CDATA[<h1 id="常用程序的特征"><a href="#常用程序的特征" class="headerlink" title="常用程序的特征"></a>常用程序的特征</h1><h2 id="1-BC"><a href="#1-BC" class="headerlink" title="1.BC++"></a>1.BC++</h2><h2 id="2Delphi"><a href="#2Delphi" class="headerlink" title="2Delphi"></a>2Delphi</h2><h2 id="3易语言"><a href="#3易语言" class="headerlink" title="3易语言"></a>3易语言</h2><h2 id="4VB"><a href="#4VB" class="headerlink" title="4VB"></a>4VB</h2><h2 id="3VC"><a href="#3VC" class="headerlink" title="3VC++"></a>3VC++</h2><h1 id="分析BC-程序特征"><a href="#分析BC-程序特征" class="headerlink" title="分析BC++程序特征"></a>分析BC++程序特征</h1><p>OPE特征    EB 10  Fb c++hook<br>二进制特征：EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90</p><p>第一个CALL内有API调用 GetMouduleHandleA</p><h1 id="分析Delphi程序特征"><a href="#分析Delphi程序特征" class="headerlink" title="分析Delphi程序特征"></a>分析Delphi程序特征</h1><p>OPE特征  5个Call ，上面全是地址，后面全是0，第一个CALL内有API调用 GetMouduleHandleA</p><p>调用函数时，跳转IAT时OPCODE跳转是FF25，VC是FF15</p><p>区段名比较细致</p><p>CODE，DATA，BSS（），idata，tls，rdata，reloc，rsrc</p><p>链接器版本<br>2.25</p><h1 id="分析VS程序"><a href="#分析VS程序" class="headerlink" title="分析VS程序"></a>分析VS程序</h1><p>VC6.0  6.0<br>VC2003 7.0 7.1<br>VC2005 8.0<br>VC2008   9.0<br>VS2010   10<br>VS2012   11<br>VS2015   14.0<br>VS2017  14.1  </p><h1 id="分析VC6-0和易语言程序特征"><a href="#分析VC6-0和易语言程序特征" class="headerlink" title="分析VC6.0和易语言程序特征"></a>分析VC6.0和易语言程序特征</h1><p>这两个编译器一样，链接器都是6.0版本，第一个api调用getversion，<br>Sub esp，0x58</p><h1 id="逆向步骤"><a href="#逆向步骤" class="headerlink" title="逆向步骤"></a>逆向步骤</h1><p>拿到程序  </p><h2 id="1-确定格式和加密"><a href="#1-确定格式和加密" class="headerlink" title="1.确定格式和加密"></a>1.确定格式和加密</h2><h2 id="2-根据分析，选择工具全面静态分析"><a href="#2-根据分析，选择工具全面静态分析" class="headerlink" title="2.根据分析，选择工具全面静态分析"></a>2.根据分析，选择工具全面静态分析</h2><p>1.查看链接器版本（4.20-VB5，2.25-Delphi7）<br>2.查看OEP代码，是否加壳，未加壳的编译器环境（代码是否正常，pushad这类不正常）<br>3.查看区段（.text 微软 CODE 宝蓝）<br>4.查看导入导出 表（函数名）<br>5.查看资源信息（有无自定义资源）<br>6.查看TLS信息息（有无设置TLS回调函数）<br>7.文件大小，图标  </p><h2 id="3-使用完PE工具，在使用其他工具进行分析"><a href="#3-使用完PE工具，在使用其他工具进行分析" class="headerlink" title="3.使用完PE工具，在使用其他工具进行分析"></a>3.使用完PE工具，在使用其他工具进行分析</h2><p>1.如果加壳，就脱壳，如果是强壳还是需要脱壳才能分析，那就先找OEP再转存到文件，结合IDA进行分析。<br>2.若果程序为保护，看引用了API之类的，根据API确定实现的功能，比如文件操作，网络操作，注册表操作。用监控类工具分析，分析日志，，再进行下一步分析，如果需要分析网络数据可以使用抓包工具。<br>3.如果其他的文件，如资源文件，分析字符串推测功能<br>4.如果程序有安装目录，目录每个文件子目录都要查看  </p><h2 id="4-根据静态分析情况，再动态分析"><a href="#4-根据静态分析情况，再动态分析" class="headerlink" title="4.根据静态分析情况，再动态分析"></a>4.根据静态分析情况，再动态分析</h2><p>第一种，单步跟踪调试，就是从程序加载开始跟踪，一直到找到需要的信息。<br>第二种，附加调试程序，这是在程序运行的状态下，附加进程，进行分析，一般在API下断，然后栈回溯进行分析，还有一种就是如果是窗口程序，我们可以通过窗口回调函数然后进行分析。  </p><h2 id="5-动静结合"><a href="#5-动静结合" class="headerlink" title="5.动静结合"></a>5.动静结合</h2><p>OD，IDA<br>如果分析中还是有很多困难，那么就需要使用IDA/OD等工具进行进一步的分析，尤其是字符串。<br>根据字符串，下断栈回溯分析。  </p><h2 id="6-使用源码对比法，辅助逆向"><a href="#6-使用源码对比法，辅助逆向" class="headerlink" title="6.使用源码对比法，辅助逆向"></a>6.使用源码对比法，辅助逆向</h2><p>分析程序，用了什么库，写代码demo反汇编我们的程序进行对比，提高逆向效率  </p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 反汇编 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/20/hello-world/"/>
      <url>/2018/06/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
